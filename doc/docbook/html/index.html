<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Covered - Verilog Code Coverage Analyzer</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"></HEAD
><BODY
CLASS="BOOK"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="BOOK"
><A
NAME="AEN1"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
><A
NAME="AEN2"
>Covered - Verilog Code Coverage Analyzer</A
></H1
><H3
CLASS="AUTHOR"
><A
NAME="AEN4"
></A
>Trevor Williams</H3
><DIV
CLASS="AFFILIATION"
><DIV
CLASS="ADDRESS"
><P
CLASS="ADDRESS"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<CODE
CLASS="EMAIL"
>&#60;<A
HREF="mailto:phase1geo@gmail.com"
>phase1geo@gmail.com</A
>&#62;</CODE
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P
></DIV
></DIV
><P
CLASS="COPYRIGHT"
>Copyright &copy; 2008 Trevor Williams</P
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>I. <A
HREF="#AEN13"
>Overview</A
></DT
><DD
><DL
><DT
>1. <A
HREF="#AEN15"
>Introduction</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN17"
>What is Covered?</A
></DT
><DT
><A
HREF="#AEN20"
>What can code coverage do?</A
></DT
><DT
><A
HREF="#AEN41"
>What can't code coverage do?</A
></DT
><DT
><A
HREF="#AEN45"
>What does Covered do?</A
></DT
><DT
><A
HREF="#AEN48"
>What does Covered NOT do?</A
></DT
><DT
><A
HREF="#AEN51"
>What makes Covered different?</A
></DT
></DL
></DD
><DT
>2. <A
HREF="#CHAPTER.METRICS"
>Coverage Metrics</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN59"
>Line Coverage</A
></DT
><DT
><A
HREF="#AEN74"
>Toggle Coverage</A
></DT
><DT
><A
HREF="#AEN90"
>Memory Coverage</A
></DT
><DT
><A
HREF="#AEN137"
>Combinational Logic Coverage</A
></DT
><DT
><A
HREF="#AEN164"
>Finite State Machine (FSM) Coverage</A
></DT
><DT
><A
HREF="#SECTION.METRIC.ASSERT"
>Assertion Coverage</A
></DT
></DL
></DD
><DT
>3. <A
HREF="#AEN229"
>Coverage Boundaries</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN233"
>What logic can be analyzed?</A
></DT
><DT
><A
HREF="#AEN369"
>What logic cannot be currently analyzed?</A
></DT
></DL
></DD
><DT
>4. <A
HREF="#CHAPTER.RACE"
>Race Condition Checking</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN393"
>Checked Coding Guidelines</A
></DT
><DT
><A
HREF="#SECTION.RACE.HANDLING"
>Race Condition Handling</A
></DT
><DT
><A
HREF="#SECTION.RACE.AVOIDING"
>Avoiding Race Condition Checking</A
></DT
><DT
><A
HREF="#AEN434"
>Reporting Race Conditions</A
></DT
></DL
></DD
><DT
>5. <A
HREF="#CHAPTER.ATTR"
>Inline Attributes</A
></DT
><DD
><DL
><DT
><A
HREF="#SECTION.ATTR"
>What are inline attributes?</A
></DT
><DT
><A
HREF="#SECTION.ATTR.FSM"
>Adding FSM attributes</A
></DT
></DL
></DD
></DL
></DD
><DT
>II. <A
HREF="#AEN544"
>Installation</A
></DT
><DD
><DL
><DT
>6. <A
HREF="#CHAPTER.INSTALLATION"
>Installation</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN548"
>Prerequisites</A
></DT
><DT
><A
HREF="#AEN576"
>Downloading source</A
></DT
><DT
><A
HREF="#SECTION.CONFIGURING"
>Configuring the build</A
></DT
><DT
><A
HREF="#AEN626"
>Compiling and Installing</A
></DT
></DL
></DD
></DL
></DD
><DT
>III. <A
HREF="#AEN637"
>Command-line Usage</A
></DT
><DD
><DL
><DT
>7. <A
HREF="#CHAPTER.START"
>Getting Started</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN644"
>What is needed for dumpfile scoring?</A
></DT
><DT
><A
HREF="#SECTION.VPI"
>What is needed for VPI scoring?</A
></DT
></DL
></DD
><DT
>8. <A
HREF="#CHAPTER.USING"
>Using Covered</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN692"
>Work Flow</A
></DT
><DT
><A
HREF="#AEN727"
>Covered usage</A
></DT
><DT
><A
HREF="#AEN741"
>Covered global options</A
></DT
></DL
></DD
><DT
>9. <A
HREF="#CHAPTER.SCORE"
>The score Command</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN775"
>Usage</A
></DT
><DT
><A
HREF="#AEN786"
>Options</A
></DT
><DT
><A
HREF="#SECTION.SCORE.T"
>Specifying What to Cover</A
></DT
><DT
><A
HREF="#SECTION.SCORE.E"
>Specifying What Not to Cover (Coverage Exclusions)</A
></DT
><DT
><A
HREF="#SECTION.SCORE.PARAM"
>Overriding Parameters (-P option)</A
></DT
><DT
><A
HREF="#SECTION.SCORE.FSM"
>Scoring FSMs</A
></DT
><DT
><A
HREF="#SECTION.SCORE.OTHER"
>Other Notes</A
></DT
></DL
></DD
><DT
>10. <A
HREF="#CHAPTER.MERGE"
>The merge Command</A
></DT
><DD
><DL
><DT
><A
HREF="#SECTION.MERGE.USING"
>Usage</A
></DT
><DT
><A
HREF="#SECTION.MERGE.OPTIONS"
>Options</A
></DT
></DL
></DD
><DT
>11. <A
HREF="#CHAPTER.REPORT"
>The report Command</A
></DT
><DD
><DL
><DT
><A
HREF="#SECTION.REPORT.USAGE"
>Usage</A
></DT
><DT
><A
HREF="#SECTION.REPORT.OPTIONS"
>Options</A
></DT
><DT
><A
HREF="#SECTION.REPORT.SDV"
>Summary Vs. Detailed Vs. Verbose</A
></DT
><DT
><A
HREF="#SECTION.REPORT.MI"
>Module Vs. Instance</A
></DT
><DT
><A
HREF="#SECTION.REPORT.CU"
>Covered Vs. Uncovered</A
></DT
></DL
></DD
><DT
>12. <A
HREF="#CHAPTER.RANK"
>The rank Command</A
></DT
><DD
><DL
><DT
><A
HREF="#SECTION.RANK.OPTIONS"
>Options</A
></DT
><DT
><A
HREF="#SECTION.RANK.INPUTTING"
>Methods for specifying CDDs to rank</A
></DT
><DT
><A
HREF="#SECTION.RANK.WEIGHTING"
>Specifying metric weights</A
></DT
><DT
><A
HREF="#SECTION.RANK.ALGORITHM"
>Description of ranking algorithm</A
></DT
></DL
></DD
><DT
>13. <A
HREF="#CHAPTER.READING"
>Reading the Report</A
></DT
><DD
><DL
><DT
><A
HREF="#SECTION.READING.LINE"
>Reading Line Coverage</A
></DT
><DT
><A
HREF="#SECTION.READING.TOGGLE"
>Reading Toggle Coverage</A
></DT
><DT
><A
HREF="#SECTION.READING.MEMORY"
>Reading Memory Coverage</A
></DT
><DT
><A
HREF="#SECTION.READING.LOGIC"
>Reading Combinational Logic Coverage</A
></DT
><DT
><A
HREF="#SECTION.READING.FSM"
>Reading FSM Coverage</A
></DT
><DT
><A
HREF="#SECTION.READING.ASSERT"
>Reading Assertion Coverage</A
></DT
></DL
></DD
><DT
>14. <A
HREF="#CHAPTER.DEBUG"
>Debugging</A
></DT
><DD
><DL
><DT
><A
HREF="#SECTION.DEBUG.OUTPUT"
>Verbose Debug Output</A
></DT
><DT
><A
HREF="#SECTION.CLI"
>Command-Line Interface (CLI)</A
></DT
><DT
><A
HREF="#SECTION.PROFILING"
>Source Code Profiling</A
></DT
></DL
></DD
></DL
></DD
><DT
>IV. <A
HREF="#AEN1657"
>Graphical User Interface</A
></DT
><DD
><DL
><DT
>15. <A
HREF="#CHAPTER.GUI.INTRO"
>Introduction to the GUI</A
></DT
><DT
>16. <A
HREF="#CHAPTER.GUI.MAIN"
>Navigating the Main Window</A
></DT
><DD
><DL
><DT
><A
HREF="#SECTION.GUI.MAIN.MENUBAR"
>The Main Menu Bar</A
></DT
><DT
><A
HREF="#SECTION.GUI.MAIN.COVBAR"
>The Coverage Type View Bar</A
></DT
><DT
><A
HREF="#SECTION.GUI.MAIN.SUMCOV"
>The Summary Coverage Bar</A
></DT
><DT
><A
HREF="#SECTION.GUI.MAIN.LISTBOX"
>The Module/Instance Listbox</A
></DT
><DT
><A
HREF="#SECTION.GUI.MAIN.VIEWER"
>The Coverage File Viewer</A
></DT
><DT
><A
HREF="#SECTION.GUI.MAIN.INFOBAR"
>The Information Bar</A
></DT
></DL
></DD
><DT
>17. <A
HREF="#CHAPTER.GUI.LINE"
>Navigating the Line Coverage Window</A
></DT
><DD
><DL
><DT
><A
HREF="#SECTION.GUI.LINE.UNCOV"
>Viewing Uncovered Lines</A
></DT
><DT
><A
HREF="#SECTION.GUI.LINE.EXCL"
>Excluding/Included Uncovered Lines from Line Coverage</A
></DT
><DT
><A
HREF="#SECTION.GUI.LINE.COV"
>Viewing Covered Lines</A
></DT
></DL
></DD
><DT
>18. <A
HREF="#CHAPTER.GUI.TOGGLE"
>Navigating the Toggle Coverage Window</A
></DT
><DD
><DL
><DT
><A
HREF="#SECTION.GUI.TOGGLE.LAYOUT"
>Understanding the Layout</A
></DT
><DT
><A
HREF="#SECTION.GUI.TOGGLE.EXCL"
>Excluding/Including a Signal for Toggle Coverage</A
></DT
><DT
><A
HREF="#SECTION.GUI.TOGGLE.DISPLAY"
>Displaying a New Signal for Toggle Coverage</A
></DT
></DL
></DD
><DT
>19. <A
HREF="#CHAPTER.GUI.MEMORY"
>Navigating the Memory Coverage Window</A
></DT
><DD
><DL
><DT
><A
HREF="#SECTION.GUI.MEMORY.LAYOUT"
>Understanding the Layout</A
></DT
><DT
><A
HREF="#SECTION.GUI.MEMORY.EXCL"
>Excluding/Including a Memory for Memory Coverage</A
></DT
><DT
><A
HREF="#SECTION.GUI.MEMORY.DISPLAYING"
>Displaying a New Memory for Memory Coverage</A
></DT
></DL
></DD
><DT
>20. <A
HREF="#CHAPTER.GUI.LOGIC"
>Navigating the Combinational Logic Window</A
></DT
><DD
><DL
><DT
><A
HREF="#SECTION.GUI.LOGIC.NAVIGATE"
>Navigating a Statement</A
></DT
><DT
><A
HREF="#SECTION.GUI.LOGIC.INFO"
>Understanding the Coverage Information</A
></DT
><DT
><A
HREF="#SECTION.GUI.LOGIC.EXCL"
>Excluding/Including a Subexpression</A
></DT
><DT
><A
HREF="#SECTION.GUI.LOGIC.DISPLAY"
>Displaying a New Statement</A
></DT
></DL
></DD
><DT
>21. <A
HREF="#CHAPTER.GUI.FSM"
>Navigating the FSM State/State Transition Coverage Window</A
></DT
><DD
><DL
><DT
><A
HREF="#SECTION.GUI.FSM.NAVIGATE"
>Navigating the FSM Window</A
></DT
><DT
><A
HREF="#SECTION.GUI.FSM.EXCL"
>Excluding/Including a State Transition</A
></DT
><DT
><A
HREF="#SECTION.GUI.FSM.DISPLAY"
>Displaying a New FSM</A
></DT
></DL
></DD
><DT
>22. <A
HREF="#CHAPTER.GUI.ASSERT"
>Navigating the Assertion Coverage Window</A
></DT
><DD
><DL
><DT
><A
HREF="#SECTION.GUI.ASSERT.NAVIGATE"
>Navigating the Assertion Coverage Window</A
></DT
><DT
><A
HREF="#SECTION.GUI.ASSERT.EXCL"
>Excluding/Including Assertion Coverage Points</A
></DT
><DT
><A
HREF="#SECTION.GUI.ASSERT.DISPLAY"
>Displaying a New Assertion Instance</A
></DT
></DL
></DD
><DT
>23. <A
HREF="#CHAPTER.GUI.ASSERT.SOURCE"
>Navigating the Assertion Source Code Window</A
></DT
><DD
><DL
><DT
><A
HREF="#SECTION.GUI.ASSERT.SOURCE.NAVIGATE"
>Navigating the Source Code</A
></DT
></DL
></DD
><DT
>24. <A
HREF="#CHAPTER.GUI.GENREPORT"
>Navigating the ASCII Report Generator Window</A
></DT
><DD
><DL
><DT
><A
HREF="#SECTION.GUI.GENREPORT.NAVIGATE"
>Navigating the Window</A
></DT
></DL
></DD
><DT
>25. <A
HREF="#CHAPTER.GUI.PREFERENCES"
>Navigating the Preferences Window</A
></DT
><DD
><DL
><DT
><A
HREF="#SECTION.GUI.PREF.CATEGORIES"
>Option Categories</A
></DT
><DT
><A
HREF="#SECTION.GUI.PREF.BUTTONS"
>Preference Buttons</A
></DT
><DT
><A
HREF="#SECTION.GUI.PREF.CONFIGFILE"
>Preferences Configuration File</A
></DT
><DT
><A
HREF="#SECTION.GUI.PREF.GENERAL"
>Preferences General Pane</A
></DT
><DT
><A
HREF="#SECTION.GUI.PREF.COLOR"
>Preferences Color Pane</A
></DT
><DT
><A
HREF="#SECTION.GUI.PREF.GOALS"
>Preference Coverage Goals Pane</A
></DT
><DT
><A
HREF="#SECTION.GUI.PREF.SYNTAX"
>Preferences Syntax Highlighting Pane</A
></DT
><DT
><A
HREF="#SECTION.GUI.PREF.REPORT"
>Preferences ASCII Report Options Pane</A
></DT
></DL
></DD
><DT
>26. <A
HREF="#CHAPTER.GUI.WIZARD"
>Navigating the Wizard Window</A
></DT
><DT
>27. <A
HREF="#CHAPTER.GUI.NEW"
>Creating a New CDD</A
></DT
><DD
><DL
><DT
><A
HREF="#SECTION.GUI.NEW.SELECT"
>Navigating the New CDD Creation Option Selection Window</A
></DT
><DT
><A
HREF="#SECTION.GUI.NEW.NAME"
>Navigating the New CDD Creation CDD Name Page</A
></DT
><DT
><A
HREF="#SECTION.GUI.NEW.TYPE"
>CDD Creation Type Page</A
></DT
><DT
><A
HREF="#SECTION.GUI.NEW.OPTIONS1"
>CDD Creation Options1 Page</A
></DT
><DT
><A
HREF="#SECTION.GUI.NEW.OPTIONS2"
>CDD Creation Options2 Page</A
></DT
></DL
></DD
></DL
></DD
><DT
>V. <A
HREF="#AEN3128"
>FAQ</A
></DT
><DD
><DL
><DT
>28. <A
HREF="#CHAPTER.FAQ"
>FAQ</A
></DT
></DL
></DD
><DT
>VI. <A
HREF="#AEN3200"
>Epilogue</A
></DT
><DD
><DL
><DT
>29. <A
HREF="#CHAPTER.EPILOGUE"
>Epilogue</A
></DT
><DD
><DL
><DT
><A
HREF="#SECTION.EPI.AUTHOR"
>Author</A
></DT
><DT
><A
HREF="#SECTION.EPI.THANKS"
>Special Thanks</A
></DT
><DT
><A
HREF="#SECTION.EPI.BUGS"
>Reporting Bugs</A
></DT
><DT
><A
HREF="#SECTION.EPI.MAILING.LIST"
>Mailing List</A
></DT
><DT
><A
HREF="#SECTION.EPI.HOMEPAGE"
>Homepage</A
></DT
><DT
><A
HREF="#SECTION.EPI.LICENSE"
>Copyright and Licensing</A
></DT
></DL
></DD
></DL
></DD
></DL
></DIV
><DIV
CLASS="LOT"
><DL
CLASS="LOT"
><DT
><B
>List of Tables</B
></DT
><DT
>8-1. <A
HREF="#AEN744"
>Global Options to Covered</A
></DT
><DT
>9-1. <A
HREF="#AEN790"
>Options to score Command</A
></DT
><DT
>10-1. <A
HREF="#AEN1073"
>Options to merge Command</A
></DT
><DT
>11-1. <A
HREF="#AEN1118"
>Options to report Command</A
></DT
><DT
>12-1. <A
HREF="#AEN1194"
>Options to rank Command</A
></DT
><DT
>14-1. <A
HREF="#AEN1523"
>CLI Command-line Options</A
></DT
><DT
>25-1. <A
HREF="#AEN2674"
>Location of Written .coveredrc File According to the Location of Read .coveredrc File</A
></DT
></DL
></DIV
><DIV
CLASS="LOT"
><DL
CLASS="LOT"
><DT
><B
>List of Figures</B
></DT
><DT
>2-1. <A
HREF="#FIGURE.METRICS.FSM"
>Digraph Version of Example FSM</A
></DT
><DT
>16-1. <A
HREF="#FIGURE.GUI.MAIN.WINDOW"
>Covered Main Window</A
></DT
><DT
>16-2. <A
HREF="#FIGURE.GUI.MAIN.MENUBAR"
>Covered Main Window Highlighting the Menu Bar</A
></DT
><DT
>16-3. <A
HREF="#FIGURE.GUI.MAIN.FILEMENU"
>The File Menu</A
></DT
><DT
>16-4. <A
HREF="#SECTION.GUI.MAIN.FILE.OPENMERGE"
>The Open/Merge CDD Selection Window</A
></DT
><DT
>16-5. <A
HREF="#SECTION.GUI.MAIN.FILE.VIEWER"
>The CDD Opened File Viewer</A
></DT
><DT
>16-6. <A
HREF="#FIGURE.GUI.MAIN.CLOSE"
>The Close Warning Window</A
></DT
><DT
>16-7. <A
HREF="#FIGURE.GUI.MAIN.GENERATE"
>The Generate Menu List</A
></DT
><DT
>16-8. <A
HREF="#FIGURE.GUI.MAIN.EXIT"
>The Exit Warning Window</A
></DT
><DT
>16-9. <A
HREF="#FIGURE.GUI.MAIN.REPORT.MENU"
>The Report Menu</A
></DT
><DT
>16-10. <A
HREF="#FIGURE.GUI.MAIN.VIEW.MENU"
>The View Menu</A
></DT
><DT
>16-11. <A
HREF="#FIGURE.GUI.MAIN.HELP.MENU"
>The Help Menu</A
></DT
><DT
>16-12. <A
HREF="#FIGURE.GUI.MAIN.COVBAR"
>Covered Main Coverage Type View Bar</A
></DT
><DT
>16-13. <A
HREF="#FIGURE.GUI.MAIN.SUMBAR"
>Covered Main Summary Coverage Bar</A
></DT
><DT
>16-14. <A
HREF="#FIGURE.GUI.MAIN.LISTBOX"
>Populated Module/Instance Selection Box</A
></DT
><DT
>16-15. <A
HREF="#FIGURE.GUI.MAIN.VIEWER"
>Covered Main Coverage File Viewer</A
></DT
><DT
>16-16. <A
HREF="#FIGURE.GUI.MAIN.INFOBAR"
>Covered Main Information Bar</A
></DT
><DT
>17-1. <A
HREF="#FIGURE.GUI.LINE.INCLUDE"
>Example of uncovered line included for line coverage consideration</A
></DT
><DT
>17-2. <A
HREF="#FIGURE.GUI.LINE.EXCLUDE"
>Example of uncovered line excluded for line coverage consideration</A
></DT
><DT
>18-1. <A
HREF="#FIGURE.GUI.TOGGLE"
>Verbose Toggle Window</A
></DT
><DT
>19-1. <A
HREF="#FIGURE.GUI.MEMORY"
>Verbose Memory Window</A
></DT
><DT
>20-1. <A
HREF="#FIGURE.GUI.LOGIC"
>Example of the verbose combinational logic window</A
></DT
><DT
>20-2. <A
HREF="#FIGURE.GUI.LOGIC.UNCOV.EVENT"
>Example Coverage Output for an Uncovered Event Subexpression</A
></DT
><DT
>20-3. <A
HREF="#FIGURE.GUI.LOGIC.UNCOV.UNARY"
>Example Coverage Output for an Uncovered Unary Subexpression</A
></DT
><DT
>20-4. <A
HREF="#FIGURE.GUI.INFO.SIMPLE.AND"
>Example Coverage Output for an Uncovered Simple AND-type Combinational Subexpression</A
></DT
><DT
>20-5. <A
HREF="#FIGURE.GUI.INFO.SIMPLE.OR"
>Example Coverage Output for an Uncovered Simple OR-type Combinational Subexpression</A
></DT
><DT
>20-6. <A
HREF="#FIGURE.GUI.INFO.SIMPLE.OTHER"
>Example Coverage Output for an Uncovered Simple Combinational Subexpression</A
></DT
><DT
>20-7. <A
HREF="#FIGURE.GUI.LOGIC.COMPLEX"
>Example Coverage Output for an Uncovered Complex Combinational Subexpression</A
></DT
><DT
>20-8. <A
HREF="#FIGURE.GUI.LOGIC.EXCL"
>Example of an excluded subexpression</A
></DT
><DT
>21-1. <A
HREF="#FIGURE.GUI.FSM"
>Verbose FSM Coverage Window</A
></DT
><DT
>21-2. <A
HREF="#FIGURE.GUI.FSM.EXCL"
>Example of excluded state transitions</A
></DT
><DT
>22-1. <A
HREF="#FIGURE.GUI.ASSERT"
>Verbose Assertion Coverage Window</A
></DT
><DT
>22-2. <A
HREF="#FIGURE.GUI.ASSERT.EXCLUDE"
>Example of excluded ACP</A
></DT
><DT
>23-1. <A
HREF="#FIGURE.GUI.ASSERT.SOURCE"
>Assertion Source Viewer Window</A
></DT
><DT
>24-1. <A
HREF="#FIGURE.GUI.GENREPORT"
>The ASCII Report Generate Window</A
></DT
><DT
>25-1. <A
HREF="#FIGURE.GUI.PREF.MAIN"
>Main Preferences Window</A
></DT
><DT
>25-2. <A
HREF="#FIGURE.GUI.PREF.COLOR"
>The Color Preferences Pane</A
></DT
><DT
>25-3. <A
HREF="#FIGURE.GUI.PREF.GOALS"
>Coverage Goals Window</A
></DT
><DT
>25-4. <A
HREF="#FIGURE.GUI.PREF.SYNTAX"
>Syntax Highlighting Preferences Pane</A
></DT
><DT
>25-5. <A
HREF="#FIGURE.GUI.PREF.REPORT"
>ASCII Report Preferences Pane</A
></DT
><DT
>26-1. <A
HREF="#FIGURE.GUI.WIZARD"
>Covered GUI Wizard Window</A
></DT
><DT
>27-1. <A
HREF="#FIGURE.GUI.NEW.SELECT"
>CDD Creation Option Selection Page</A
></DT
><DT
>27-2. <A
HREF="#FIGURE.GUI.NEW.NAME"
>CDD Creation Output Name Page</A
></DT
><DT
>27-3. <A
HREF="#FIGURE.GUI.NEW.TYPE"
>CDD Creation Type Page</A
></DT
><DT
>27-4. <A
HREF="#FIGURE.GUI.NEW.OPTIONS1"
>CDD Creation Options1 Page</A
></DT
><DT
>27-5. <A
HREF="#FIGURE.GUI.NEW.OPTIONS2"
>CDD Creation Options2 Page</A
></DT
><DT
>27-6. <A
HREF="#FIGURE.GUI.NEW.OPTIONS2.INSMENU"
>CDD Creation Insert Menubutton</A
></DT
><DT
>27-7. <A
HREF="#FIGURE.GUI.NEW.OPTIONS2.LIBEXT"
>CDD Creation Library Extension Window</A
></DT
><DT
>27-8. <A
HREF="#FIGURE.GUI.NEW.OPTIONS2.DEFINE"
>CDD Creation Define Window</A
></DT
><DT
>27-9. <A
HREF="#FIGURE.GUI.NEW.OPTIONS2.PARAM"
>CDD Creation Parameter Override Window</A
></DT
><DT
>27-10. <A
HREF="#FIGURE.GUI.NEW.OPTIONS2.FSM"
>CDD Creation FSM Specification Window</A
></DT
><DT
>27-11. <A
HREF="#FIGURE.GUI.NEW.OPTIONS2.MODGEN"
>CDD Creation Module Generation Window</A
></DT
><DT
>27-12. <A
HREF="#FIGURE.GUI.NEW.OPTIONS2.MODEXCL"
>CDD Creation Module Exclusion Window</A
></DT
></DL
></DIV
><DIV
CLASS="PART"
><A
NAME="AEN13"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
>I. Overview</H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>1. <A
HREF="#AEN15"
>Introduction</A
></DT
><DT
>2. <A
HREF="#CHAPTER.METRICS"
>Coverage Metrics</A
></DT
><DT
>3. <A
HREF="#AEN229"
>Coverage Boundaries</A
></DT
><DT
>4. <A
HREF="#CHAPTER.RACE"
>Race Condition Checking</A
></DT
><DT
>5. <A
HREF="#CHAPTER.ATTR"
>Inline Attributes</A
></DT
></DL
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="AEN15"
></A
>Chapter 1. Introduction</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN17"
>What is Covered?</A
></H2
><P
>				Covered is a Verilog code coverage analysis tool that can be useful for determining how well a diagnostic 
				test suite is covering the design under test (DUT). It is command-line based with an optional Tcl/Tk GUI 
				report viewer, making it portable across almost all platforms.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN20"
>What can code coverage do?</A
></H2
><P
>				Typically, in the design verification work flow, a design verification engineer will develop a self-checking 
				test suite to verify design elements/functions specified by a design's specification document. When the test 
				suite contains all of the tests required by the design specification, the test writer may ask:
				</P
><P
>					 <P
></P
><UL
><LI
><P
>"How much logic in the design is actually being exercised?"</P
></LI
><LI
><P
>"Does my test suite cover all of the DUT?"</P
></LI
><LI
><P
>"Am I done writing tests for the logic?"</P
></LI
></UL
>
				</P
><P
>				When the design verification gets to this point, it is often useful to get some metrics for determining logic 
				coverage. This is where a code coverage utility, such as Covered, is very useful.
				</P
><P
>				The metrics obtained by using a code coverage analysis tool can be very useful for determining the following 
				about a design and the test suite testing that design:
				</P
><P
>					 <P
></P
><OL
TYPE="1"
><LI
><P
>Completeness of the test suite in terms of logic coverage.</P
></LI
><LI
><P
>Unexercised logic in the design (useful in helping to determine what types of tests need to be added to the test suite).</P
></LI
><LI
><P
>Corner cases in design that are untestable.</P
></LI
></OL
>
				</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN41"
>What can't code coverage do?</A
></H2
><P
>				It is important to note that any code coverage tool is only useful in indicating how much logic is being 
				covered by a test suite. It does not indicate that the covered logic works appropriately. This, of course, 
				can only be verified by the diagnostics themselves.
				</P
><P
>				Additionally, it is possible that two or more diagnostics can achieve the same coverage and yet be 
				functionally testing different characteristics of a design. Since the coverage metrics are not improved in 
				this case, one may conclude that the second test is unnecessary. This may or may not be true depending on 
				what is being tested; it is always up to the test writer to determine the necessity of a diagnostic. Using 
				the code coverage tool results as the sole means of making this determination is not recommended. Use common 
				sense in these areas.
				</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN45"
>What does Covered do?</A
></H2
><P
>				Covered is a tool that uses your design files along with standard VCD or LXT dump files to analyze the code 
				coverage of the DUT. The code coverage information is stored in a special database file that can be retrieved 
				and "merged" with new coverage information to create a summed coverage total for several tests. After a database 
				file has been created, the user may generate various ASCII reports that summarize the coverage information or 
				run Covered's GUI to interactively analyze the coverage information.
				</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN48"
>What does Covered NOT do?</A
></H2
><P
>				Though Covered does perform some resimulation of the design to derive line, combinational logic, memory, and 
				assertion coverage, Covered is NOT a full-fledged compiler/simulator and should not be used for such purposes. 
				Additionally, Covered is NOT a linting tool. Many syntax/semantic issues that are not allowed by the LRM are 
				allowed by Covered for purposes of making Covered's core more generic and/or simplistic. Please make sure that 
				your code is properly linted in your design flow using an appropriate tool.
				</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN51"
>What makes Covered different?</A
></H2
><P
>				Most Verilog code coverage tools perform a pre-compilation procedure known as instrumenting. During this procedure, 
				the coverage tool will read in the DUT and generate its own version of the DUT with additional code added to aid 
				in calculating coverage after the simulation is complete. The benefits to this style are higher performance of the 
				coverage tool when it is run after the simulation. The drawbacks to this approach are that it slows down simulation 
				speed and a trust issue that the coverage tool did not alter your simulation model when it performed the 
				instrumentation.
				</P
><P
>				Covered, on the other hand, omits the instrumenting procedure all-together and only performs its analysis on a 
				pre-simulated design. This means that Covered cannot make a mistake to your simulation and the simulation is allowed 
				to run faster since there is no additional code that must be run to get coverage data. The drawback is that there is 
				some overhead in post-simulation for extracting coverage data but this is typically less than the simulation overhead 
				in the other method.
				</P
><P
>				Additionally, unlike all other commercial coverage tools, Covered is free! No license managers to invoke and maintain. 
				No licensing fees and negotiations. The only thing the developers of Covered want in return are bug reports and user 
				input (and perhaps a donation if you find the software useful and want to see its development continue). Isn't the 
				open source life grand?!
				</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER.METRICS"
></A
>Chapter 2. Coverage Metrics</H1
><P
>		Covered currently generates six types of code coverage metrics.
		</P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN59"
>Line Coverage</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN61"
>Description</A
></H3
><P
>				  Line coverage simply answers the question, "Was this line of code executed during simulation?"
				  </P
><P
>				  Covered will display the number of logical lines of code that exist in a particular file with the number of logical 
				  lines that were executed during the simulation along with a percentage indicating the percentage of lines executed. 
				  If verbose mode is selected for a report, Covered will display the lines of logic that were not executed during the 
				  simulation run.
				  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN65"
>Example</A
></H3
><P
>					 Suppose that the following module was specified in your DUT that is being analyzed:
					 </P
><P
>						  <PRE
CLASS="PROGRAMLISTING"
>  module test;

    reg a, b, c;

    initial begin
      a = 0;    // Line 1
      b = 1;    // Line 2
      if( a )
        c = b;  // Line 3
      else
        c = ~b; // Line 4
    end

  endmodule
						  </PRE
>
					 </P
><P
>					 If this code were simulated as stated, the simulator would execute lines 1 and 2, and due to the value assigned 
					 to a, line 4 would be executed. This means that during execution, out of a possibility of 4 lines, only 3 were 
					 executed. Therefore, Covered would state that for this module the line coverage percentage would be 75% (or 3 
					 out of 4).
					 </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN71"
>Recommendations</A
></H3
><P
>					 For a design to pass full coverage, it is recommended that the line coverage for all modules in a design receive 
					 100% coverage. If a line of logic is not executed during simulation, the design has not been fully exercised. Line 
					 coverage is useful for determining holes in the test suite.
					 </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN74"
>Toggle Coverage</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN76"
>Description</A
></H3
><P
>				  Toggle coverage answers the question, "Did this bit of this wire/register change from a value of zero (0) to one 
				  (1) and back from one (1) to zero (0) during simulation?"
				  </P
><P
>				  A bit is said to be fully covered when it toggles back and forth at least once. This metric does not indicate to 
				  the user that every value of a multi-bit vector was seen. For example, if we have a two bit vector called "foo", 
				  toggle coverage will not tell you that the value of foo was set to the values of 0, 1, 2 and 3. However, it will 
				  tell you that all bits in that vector were toggled back and forth.
				  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN80"
>Example</A
></H3
><P
>				  Suppose that a DUT was comprised of the following module:
				  </P
><P
>				    <PRE
CLASS="PROGRAMLISTING"
>  module test;

    reg [2:0] a;

    initial begin
      a = 3'b0;
      #10;
      a = 3'b110;
      #10;
      a = 3'b010;
      #10;
    end

  endmodule
				    </PRE
>
				  </P
><P
>				  The register called "a", after being simulated, would have achieved a total toggle percentage of 50% (or 3 out of 
				  6). Can you see which toggles are missing?
				  </P
><P
>				  Bit 0 has never toggled to 1 (and has never been at a value of 1 and toggled to 0); therefore, bit-0 has toggled 
				  0% (0 out of 2). Bit 1 has toggled from a value of 0 to 1, but has not toggled from a value of 1 to 0; therefore, 
				  bit-1 has toggled 50% (0 out of 2). Bit 2 is the only bit that has fully toggled, achieving a toggle percentage of 
				  100% (2 out of 2). If you add all of the possible toggles to the number of achieved toggles, you end up with 3 out 
				  of 6 (or 50% total toggle coverage).
				  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN87"
>Recommendations</A
></H3
><P
>				  For a design to pass full coverage, it is recommended that the toggle coverage for all modules in a design received 
				  100% coverage. If a bit is never changes value, it is usually an indication that a mode is not being exercised in 
				  the design or a datapath has a stuck-at issue.
				  </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN90"
>Memory Coverage</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN92"
>Description</A
></H3
><P
>      Memory coverage answers a number of questions about memories/multi-dimensional arrays being used in your design, including 
      the following:
      </P
><P
>        <P
></P
><OL
TYPE="1"
><LI
><P
>Did all bits of each addressable memory element toggle from 0 to 1?</P
></LI
><LI
><P
>Did all bits of each addressable memory element toggle from 1 to 0?</P
></LI
><LI
><P
>Did every addressable memory element get written?</P
></LI
><LI
><P
>Did every addressable memory element get read?</P
></LI
></OL
>
      </P
><P
>      Memories/multi-dimensional arrays can have two types of dimensions, packed and unpacked. Packed dimensional information is 
      specified to the left of an array declaration while unpacked dimensional information is specified to the right of an array 
      declaration. Consider the following example:
      </P
><P
>        <PRE
CLASS="PROGRAMLISTING"
>  reg [3:0][2:0] foo[0:15];
        </PRE
>
      </P
><P
>      The memory "foo" consists of three dimensions. The first dimension is an unpacked dimension which specifies that there are 
      16 addressable memory elements (AME). The number of AMEs are determined by multiplying the unpacked dimension of an array. 
      The second two dimensions are packed dimensions, creating a total of 12 bits for each AME.
      </P
><P
>      Other than getting toggle coverage information for each AME, memory coverage also allows us to easily see which AMEs were 
      written and read during simulation. If all entries of a memory have not been written during a regression run, it could indicate 
      several shortcomings of either the testbench or a logical problem with the write control logic, including, but not limited to, 
      the following:
      </P
><P
>        <P
></P
><OL
TYPE="1"
><LI
><P
>            If no AMEs for a given memory were written, it could indicate that the testsuite was never able to get out of bypass mode 
            for that memory.
            </P
></LI
><LI
><P
>            If fewer AMEs for a given memory were written than were read, it could indicate that there is a read controller issue leading 
            to an underflow issue with the memory.
            </P
></LI
><LI
><P
>            For memories that act like stacks or use lowest/highest address first write selection scheme, indicates that the memory was 
            never completely filled (may miss out on things like buffer overflow errors).
            </P
></LI
><LI
><P
>            For memories that are written in a round-robin fashion, indicates that either not enough entries were written (could miss a 
            write pointer wrap bug) or that there is a logical issue by which the write pointer did not properly increment in a 
            round-robin fashion.
            </P
></LI
><LI
><P
>            If there are "holes" in the write coverage of the AMEs (that is an AME is found to not have been written while those above 
            and below it have been), this could indicate a corner case logic bug or other testsuite issue that needs to be addressed.
            </P
></LI
></OL
>
      </P
><P
>      If all entries of a memory have not been read during a regression run, it could indicate several other shortcomings of either the
      testbench or a logical problem with the read control logic, including, but not limited to, the following:
      </P
><P
>        <P
></P
><OL
TYPE="1"
><LI
><P
>            If no AMEs for a given memory were read, it could indicate that the testsuite was never able to get out of bypass mode for 
            that memory.
            </P
></LI
><LI
><P
>            If fewer AMEs for a given memory were read than written, it could indicate that a resource allocation issue.
            </P
></LI
><LI
><P
>            For memories that are written in a round-robin fashion, indicates that either not enough entries were read (could miss a 
            read pointer wrap bug) or that there is a logical issue by which the read pointer did not properly increment in a 
            round-robin fashion.
            </P
></LI
><LI
><P
>            If there are "holes" in the read coverage of the AMEs (that is an AME is found to not have been read while those above and 
            below it have been), this could indicate a corner case logic bug or other testsuite issue that needs to be addressed.
            </P
></LI
></OL
>
      </P
><P
>      Currently, Covered simulates all memories/multi-dimensional arrays and its coverage is automatically accumulated during the score 
      command. To see its report information, either specify the -m m option to the report command or bring up the GUI for interactive 
      analysis.
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN134"
>Recommendations</A
></H3
><P
>      For a design to pass full coverage, it is recommended that the write/read memory coverage for all modules in a design receive 100% 
      coverage. If every AME was not both written and read during simulation, the design has not been fully exercised. Toggle coverage 
      per AME need not receive 100% since a memory element that is written once will not cause toggle coverage to change.
      </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN137"
>Combinational Logic Coverage</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN139"
>Description</A
></H3
><P
>      Combinational logic coverage answers the question, "What values did an expression (or subexpression) evaluate to (or not evaluate 
      to) during the course of the simulation?"
      </P
><P
>      This type of coverage is extremely useful in determining logical combinations of signals that were not tried during simulation, 
      exposing potential holes in verification.
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN143"
>Example</A
></H3
><P
>      Suppose the DUT comprised of the following module:
      </P
><P
>        <PRE
CLASS="PROGRAMLISTING"
>  module test;

    reg  a;
    reg  b;
    wire c;

    initial begin
      a = 1'b0;
      b = 1'b1;
      #10;
      a = 1'b1;
      #10;
    end

    assign c = a | b;

  endmodule
        </PRE
>
      </P
><P
>      This module comprises of only one expression: a | b. If this module were simulated it would result in a combinational coverage 
      value of 50% (2 out of 4). Can you determine which cases are not being covered?
      </P
><P
>      The expression "a | b" can result in two values, 0 and 1, but can do so in four combinations:
      </P
><P
>        <P
></P
><OL
TYPE="1"
><LI
><P
>a = 0, b = 0, c = 0</P
></LI
><LI
><P
>a = 0, b = 1, c = 1</P
></LI
><LI
><P
>a = 1, b = 0, c = 1</P
></LI
><LI
><P
>a = 1, b = 1, c = 1</P
></LI
></OL
>
      </P
><P
>      Noticing the values assigned to a and b during simulation, shows that combinations (2) and (4) were hit during execution while 
      combinations (1) and (3) were not (2 out of 4 - 50%). This also shows us that the value of c was never 0 during simulation.
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN161"
>Recommendations</A
></H3
><P
>      For a design to pass full coverage, it is recommended that the combinational logic coverage for all modules be 80% or higher. 
      If the expression coverage for an expression is not 100%, it is recommended that the verification engineer closely examine these 
      missed cases to determine if more testing is required. Sometimes certain combinations of signals are unachievable due to design 
      constraints, keeping the expression coverage from ever reaching a value of 100% but still can be considered fully covered.
      </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN164"
>Finite State Machine (FSM) Coverage</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN166"
>Description</A
></H3
><P
>      Finite state machine (FSM) coverage answers the question, "Did I reach all of the states and traverse all possible paths through 
      a given state machine?"
      </P
><P
>      There are two types of coverage detail for FSMs that Covered can handle:
      </P
><P
>        <P
></P
><OL
TYPE="1"
><LI
><P
>            State coverage - answers the question "Were all states of an FSM hit during simulation?"
            </P
></LI
><LI
><P
>            State transition coverage - answers the question "Did the FSM transition between all states (that are achievable) in 
            simulation?"
            </P
></LI
></OL
>
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN176"
>Example</A
></H3
><P
>      Suppose the DUT comprised of the following finite state machine:
      </P
><P
>        <PRE
CLASS="PROGRAMLISTING"
>          
  module test( clock );
  
    input clock;

    reg [1:0] state;
    reg req, gnt;

    parameter IDLE 2'b00;
    parameter REQ  2'b01;
    parameter WAIT 2'b10;
    parameter GNT  2'b11;

    initial begin
      req = 1'b0;
      gnt = 1'b0;
      repeat(4) @(posedge clock);
      req &#60;= 1'b1;
      @(posedge clock);
      req &#60;= 1'b0;
      gnt &#60;= 1'b1;
      @(posedge clock);
      gnt &#60;= 1'b0;
      repeat(2) @(posedge clock);
    end

    always @(posedge clock)
      case( state )
        IDLE : state &#60;= req ? REQ : IDLE;
        REQ  : state &#60;= gnt ? GNT : WAIT;
        WAIT : state &#60;= gnt ? GNT : WAIT;
        GNT  : state &#60;= IDLE;
        default : state &#60;= 2'bx;
    endcase

  endmodule
          
        </PRE
>
      </P
><P
>      To help visualize this state machine, let's also display it as a digraph.
      </P
><P
>        <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.METRICS.FSM"
></A
><P
><B
>Figure 2-1. Digraph Version of Example FSM</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/fsm_example.png"></P
></DIV
></DIV
>
      </P
><P
>      This state machine has four states: IDLE, REQ, WAIT, GNT. During simulation, 75% of the states were hit 
      (3 out of 4) including IDLE, REQ and GNT. You can see that the WAIT state was never hit during simulation 
      since the gnt signal was asserted the clock period after the req signal asserted.
      </P
><P
>      Additionally, this state machine contains 7 state "arcs" which are represented in the digraph as arrowed lines. 
      They are the following:
      </P
><P
>        <P
></P
><OL
TYPE="1"
><LI
><P
><PRE
CLASS="PROGRAMLISTING"
>IDLE -&#62; IDLE  (HIT)</PRE
></P
></LI
><LI
><P
><PRE
CLASS="PROGRAMLISTING"
>IDLE -&#62; REQ   (HIT)</PRE
></P
></LI
><LI
><P
><PRE
CLASS="PROGRAMLISTING"
>REQ  -&#62; WAIT  (MISSED)</PRE
></P
></LI
><LI
><P
><PRE
CLASS="PROGRAMLISTING"
>REQ  -&#62; GNT   (HIT)</PRE
></P
></LI
><LI
><P
><PRE
CLASS="PROGRAMLISTING"
>WAIT -&#62; WAIT  (MISSED)</PRE
></P
></LI
><LI
><P
><PRE
CLASS="PROGRAMLISTING"
>WAIT -&#62; GNT   (MISSED)</PRE
></P
></LI
><LI
><P
><PRE
CLASS="PROGRAMLISTING"
>GNT  -&#62; IDLE  (HIT)</PRE
></P
></LI
></OL
>
      </P
><P
>      Counting the number of traversed arcs during simulation, we can see that we have covered 4 out of 7 (or 57%) of 
      the possible arcs in this state machine.
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN214"
>Recommendations</A
></H3
><P
>      For a design to pass full coverage, it is recommended that the FSM coverage for all finite state machines in the 
      design to receive 100% coverage for the state coverage and 100% for all achievable state transitions. Since Covered 
      will not determine which state transitions are achievable, it is up to the verification engineer to examine the 
      executed state transitions to determine if 100% of possible transitions occurred.
      </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.METRIC.ASSERT"
>Assertion Coverage</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN219"
>Description</A
></H3
><P
>      Assertion coverage answers the question, "Did I hit all of the possible coverage points of the assertions that I 
      included in the design?"
      </P
><P
>      Currently, Covered is capable of finding all OVL (Open Verification Language) assertion modules instantiated within 
      the design (when the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>-A ovl</B
></SPAN
> option has been specified to the score command). Within 
      most OVL assertion modules are one or more built-in coverage points. When the user has specified a particular assertion 
      instance to check for a coverage point, Covered simulates this assertion module, keeping track of which coverage 
      points within the assertion have been hit during simulation (and how many times each coverage point has been hit) and 
      which have not. This allows the user to check for more complex coverage scenarios within the design.
      </P
><P
>      Currently, only <A
HREF="http://www.accellera.org/activities/ovl"
TARGET="_top"
>OVL version 1.6</A
> (and newer) are supported. 
      Older versions of the OVL may not work and are not planned to be supported.
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN226"
>Recommendations</A
></H3
><P
>      For a design to pass full coverage, it is recommended that the assertion coverage for all modules in a design receive 
      100% coverage. If an assertion coverage point is not hit during simulation, the design has not been fully exercised. 
      Assertion coverage is useful for determining more specific corner case holes in the test suite.
      </P
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="AEN229"
></A
>Chapter 3. Coverage Boundaries</H1
><P
>	To properly evaluate the effectiveness of any coverage tool, it is necessary to understand what kinds of logic are 
	able to be analyzed and which kinds of logic are unable to be analyzed (along with a reason for why the logic cannot 
	be adequately covered). Understanding the limitations of tools up front can often guide the user of those tools to 
	make better decisions in their usage. In the case of Covered and the open source community, it may also help drive 
	ideas to how to correct or get around these limitations.
  </P
><P
>  For these reasons, a list of what type of logic can be analyzed and what type of logic cannot be currently analyzed 
  is listed below. Note that both of these lists may not be exhaustive and are subject to change between releases of 
  the tool. Also note that it is the goal of Covered to be able to parse all of the Verilog-1995, Verilog-2001, and a 
  subset of SystemVerilog constructs though some portions of these may be ignored for coverage purposes.
  </P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN233"
>What logic can be analyzed?</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN235"
>Verilog-1995 constructs</A
></H3
><P
>        <P
></P
><OL
TYPE="1"
><LI
><P
>            All expressional logic which is comprised of the following data types and operators which exist in an assign 
            block, always block, initial block, task, function or named begin/end block:
            <P
></P
><UL
><LI
><P
>Nets: wire, tri, tri0, tri1, wor, wand, trior, triand, supply0, suppl1</P
></LI
><LI
><P
>Triregs: trireg</P
></LI
><LI
><P
>Registers: reg</P
></LI
><LI
><P
>Parameter values</P
></LI
><LI
><P
>String values</P
></LI
><LI
><P
>Integer values</P
></LI
><LI
><P
>Unary operators: +, -, ~, &#38;, |, ^, ~&#38;, ~|, ~^</P
></LI
><LI
><P
>Arithmetic operators: +, -, *, /, %</P
></LI
><LI
><P
>Logical operators: &#38;&#38;, ||, !</P
></LI
><LI
><P
>Relational operators: &#62; &#60; &#62;= &#60;=</P
></LI
><LI
><P
>Equality operators: ==, ===, !=, !==</P
></LI
><LI
><P
>Bitwise operators: &#38;, |, ^, ~&#38;, ~|, ~^</P
></LI
><LI
><P
>Shift operators: &#60;&#60; &#62;&#62;</P
></LI
><LI
><P
>Concatentation/replication operators: {}, {{}}</P
></LI
><LI
><P
>Bit select operators: [], [:]</P
></LI
><LI
><P
>Conditional operator: ?:</P
></LI
></UL
>
            </P
></LI
><LI
><P
>case, casex, casez statements</P
></LI
><LI
><P
>if, if/else statements</P
></LI
><LI
><P
>Delays when delay value is integer</P
></LI
><LI
><P
>Delayed procedural assignments (i.e., "a = #5 b;" or "a = @(c) b;")</P
></LI
><LI
><P
>Event waits and triggers: wait, @(posedge), @(negedge), @(), -&#62;</P
></LI
><LI
><P
>Repetition statements (for, while and repeat)</P
></LI
><LI
><P
>Fork/join statements</P
></LI
><LI
><P
>Memories</P
></LI
><LI
><P
>$finish and $stop system calls</P
></LI
></OL
>
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN292"
>Verilog-2001 constructs</A
></H3
><P
>        <P
></P
><OL
TYPE="1"
><LI
><P
>`ifndef and `elsif directives</P
></LI
><LI
><P
>`file and `line directives</P
></LI
><LI
><P
>Constant functions calls</P
></LI
><LI
><P
>Inline parameter passing by name</P
></LI
><LI
><P
>Localparam support</P
></LI
><LI
><P
>Implicit event sensitivity lists (@*)</P
></LI
><LI
><P
>Comma-separated event lists (alternative to the "or" keyword)</P
></LI
><LI
><P
>Signed value support</P
></LI
><LI
><P
>Immediate register assignment (i.e., <FONT
COLOR="RED"
>reg a = 1'b0</FONT
>)</P
></LI
><LI
><P
>Variable multi-bit selects (i.e., <FONT
COLOR="RED"
>a[b+:3]</FONT
>, <FONT
COLOR="RED"
>a[b-:3]</FONT
>)</P
></LI
><LI
><P
>Exponential power operator (<FONT
COLOR="RED"
>a**b</FONT
>)</P
></LI
><LI
><P
>Arithmetic shift operators: &#60;&#60;&#60; &#62;&#62;&#62;</P
></LI
><LI
><P
>Pre-port parameter listing (i.e., <FONT
COLOR="RED"
>module foo #(parameter a=0) (...);</FONT
>)</P
></LI
><LI
><P
>Inline port listing (i.e., <FONT
COLOR="RED"
>module foo (input wire a, output reg b);</FONT
>)</P
></LI
><LI
><P
>Attributes (note: Covered only performs attributes that it recognizes)</P
></LI
><LI
><P
>Arrays of instances</P
></LI
><LI
><P
>Generate blocks</P
></LI
><LI
><P
>"Automatic" or reentrant tasks/recursive functions</P
></LI
></OL
>
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN338"
>SystemVerilog constructs</A
></H3
><P
></P
><OL
TYPE="1"
><LI
><P
>New integer types: char, byte, bit, logic, int, shortint, longint</P
></LI
><LI
><P
>Op-and-assign statements: +=, -=, *=, /=, %=, &#38;=, |=, ^=, &#60;&#60;=, &#62;&#62;=, &#60;&#60;&#60;=, &#62;&#62;&#62;=, ++, --</P
></LI
><LI
><P
>Proper support for always_comb, always_latch, always_ff and final blocks</P
></LI
><LI
><P
>do..while loops</P
></LI
><LI
><P
>Enumerations</P
></LI
><LI
><P
>Typedefs</P
></LI
><LI
><P
>$root scope support</P
></LI
><LI
><P
>Unnamed scope support</P
></LI
><LI
><P
>Multi-dimensional arrays including packed/unpacked dimensions and bit-select, part-select and slicing</P
></LI
><LI
><P
>Parsing support for unique and priority if/case labels</P
></LI
><LI
><P
>Parsing support for implicit .name ports (i.e., <FONT
COLOR="RED"
>foo f( .a, .b, .c );</FONT
>)</P
></LI
><LI
><P
>Parsing support for implicit .* ports (i.e., <FONT
COLOR="RED"
>foo f( .* );</FONT
>)</P
></LI
><LI
><P
>Parsing support for assertions, properties and sequences</P
></LI
></OL
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN369"
>What logic cannot be currently analyzed?</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN371"
>Verilog-1995 constructs</A
></H3
><P
>        <P
></P
><OL
TYPE="1"
><LI
><P
>All gate types (i.e., buf, not, or, and, etc.)</P
></LI
><LI
><P
>All user defined primitives (UDPs)</P
></LI
><LI
><P
>All expressions containing types: time, real, realtime</P
></LI
><LI
><P
>System task calls (or any $... call) that are not mentioned in the supported list above</P
></LI
></OL
>
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN383"
>Verilog-2001 constructs</A
></H3
><P
>        <P
></P
><OL
TYPE="1"
><LI
><P
>Configuration statements</P
></LI
></OL
>
      </P
></DIV
></DIV
><P
>  When logic is encountered that cannot be analyzed within an always, initial, task, function or named block, Covered will 
  disregard the entire always block. If the entire block cannot be analyzed, it does not try to get coverage statistics as 
  these will most likely be incorrect (i.e., disregarded logic could affect the state of the logic that is being covered).
  </P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER.RACE"
></A
>Chapter 4. Race Condition Checking</H1
><P
>  Due to Covered's method of abstracting coverage from a dumpfile, a partial "resimulation" of the design is needed 
  to obtain proper statistics for line, combinational logic and FSM metrics. Therefore, accurately resimulating what 
  occurred in the actual simulation is a requirement for obtaining correct results. This can be easily achieved so 
  long as the design doesn't contain any code that could result in potential race conditions.
  </P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN393"
>Checked Coding Guidelines</A
></H2
><P
>    To avoid this problem Covered performs automatic race condition checking on the specified design after parsing 
    has been completed but before simulation/scoring is performed. All statement blocks in the design that don't 
    adhere to certain coding guidelines are removed from coverage consideration by Covered. By following these coding 
    guidelines, a design should be void of race condition scenarios that would lead to faulty simulation results. The 
    following coding guidelines are applied by Covered when checking for race conditions:
    </P
><P
>      <P
></P
><OL
TYPE="1"
><LI
><P
>All sequential logic and latches use non-blocking assignments.</P
></LI
><LI
><P
>All combinational logic in an always block uses blocking assignments.</P
></LI
><LI
><P
>          All mixed sequential and combinational logic in the same always block uses non-blocking assignments.
          </P
></LI
><LI
><P
>Blocking and non-blocking assignments should not be used in the same always block.</P
></LI
><LI
><P
>Assignments made to a variable should only be done within one always block.</P
></LI
><LI
><P
>          The $strobe system call should only be used to display variables that were assigned using non-blocking 
          assignments. (Not currently implemented)
          </P
></LI
><LI
><P
>No #0 procedural assignments should exist. (Not currently implemented)</P
></LI
></OL
>
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.RACE.HANDLING"
>Race Condition Handling</A
></H2
><P
>    If Covered detects a block as violating any one of the above mentioned coding guidelines, it will do one of two 
    things depending on options specified to the score command by the user.
    </P
><P
>      <P
></P
><OL
TYPE="1"
><LI
><P
>          If the -rS, -rW or none of the -r options are specified, Covered will simply remove the non-conforming always 
          block from coverage consideration and continue with scoring. -rW will display a message describing detected 
          race conditions during the scoring command while the -rS option will display no messages.
          </P
></LI
><LI
><P
>          If the -rE option is specified, Covered will halt the score command after all race condition checking has 
          been performed with a message to the user specifying how many always blocks were found to be in 
          non-compliance to the race-condition-free coding guidelines.
          </P
></LI
></OL
>
    </P
><P
>    The first mode of operation is the recommended mode of operation as this will allow Covered to continue calculating 
    coverage information for the design while still providing accurate coverage information for the logic that is still 
    under consideration. The second mode of operation is meant to allow the user to use Covered as a race-condition 
    checking tool.
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.RACE.AVOIDING"
>Avoiding Race Condition Checking</A
></H2
><P
>    Covered has two means of avoiding race condition checking: (1) skip race condition checking for the entire design 
    altogether or (2) place inline pragmas around specific logic blocks to avoid checking. The main advantage for using 
    either of these two methods is to allow Covered to score more of the design that would otherwise be excluded due to
    failing a static race condition checkpoint.  The main disadvantage to avoiding race condition checking using either 
    of these methods is that you could potentially be ignoring code that contains an actual race condition, causing 
    Covered to potentially generate incorrect coverage information without warning. These types of "errors" are not 
    assumed to be Covered bugs.
    </P
><P
>    To exclude the entire design from race condition checking, simply specify the -rI option on the score command-line. 
    This will cause Covered to skip the race condition checking phase entirely, outputting a warning message (unless 
    the global -Q option has been specified). The use of this command-line option is highly discouraged due to its 
    general assumption by the user that the entire design is void of race conditions.
    </P
><P
>    To exclude portions of the design from race condition checking, the user may also place inline comment-based 
    pragmas in the design and specify the -rP option to the score command-line. The inline pragmas look like the 
    following:
    </P
><P
>      <PRE
CLASS="PROGRAMLISTING"
>  module foobar;
      
    ...
      
    // racecheck off 
    always @(posedge clock) begin
      ...
    end
    // racecheck on
      
    ...
      
  endmodule
      </PRE
>
    </P
><P
>    This example will cause the initial block surrounded by the "racecheck" pragmas to be ignored from race condition
    checking, thus making it available for coverage consideration. If there are any race condition rules that this block
    contains or is a part of, they will not be reported.
    </P
><P
>    The keyword "racecheck" is the default pragma keyword for race condition checking avoidance; however, if this name
    needs to be changed to something else by the user (i.e., if a "racecheck" is used by another tool and has a 
    different meaning or format), the user may make this keyword anything they please as long as the meaning is 
    preserved (i.e., "<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>keyword</I
></SPAN
> off" means that race condition checking should be turned off for all 
    subsequent code until its matching "<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>keyword</I
></SPAN
> on" pragma is seen). The new name of this keyword 
    is passed to the -rP option by specifying -rP=<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>keyword</I
></SPAN
>. It should also be noted that race 
    condition pragmas can be embedded within each other (all code within the outside pair are removed from race 
    checking) and race condition avoidance pragmas ("racecheck off") are in effect on a file-basis -- that is, they are 
    in effect even beyond their current scope but are no longer in effect after the current file.
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN434"
>Reporting Race Conditions</A
></H2
><P
>    Even though race condition information is displayed (assuming the -rS option was not specified in the score 
    command-line) during the scoring process, it may be convenient to view this information in a generated report as 
    well. Because of this need, Covered saves all race condition information to the CDD file for use in using the 
    report command. By specifying 'r' in the -m option to the report command (race condition report output is not 
    turned on by default), the statement blocks which were eliminated from coverage consideration will be output to the 
    coverage report file. Summary coverage will contain the total number of statement blocks eliminated for each 
    module. Verbose coverage will contain each eliminated statement block, organized by module, specifying both the 
    starting line of the eliminated statement block and the reason for why the statement block was removed.
    </P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER.ATTR"
></A
>Chapter 5. Inline Attributes</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="SECTION.ATTR"
>What are inline attributes?</A
></H2
><P
>    In the IEEE Verilog 1364-2001 standard, an attribute is a way to add information to a Verilog object, statement or 
    groups of statements that is tool-specific and does not affect simulation of that design. All Verilog-2001 
    attributes begin with the token (* and end with the token *). An attribute can be multi-line and is "attached" to 
    the Verilog object, statement, or group of statements that is specified immediately beneath the attribute.
    </P
><P
>    Covered uses the Verilog-2001 attribute for allowing users to specify coverage-specific information about embedded 
    objects within a particular design. When an attribute is found, it is interrogated to see if it is a Covered 
    attribute. If the attribute is a Covered attribute, its contents are parsed. If the attribute is not found to be a 
    Covered attribute, it is ignored and parsing continues normally.
    </P
><P
>    The rest of this chapter specifies the attributes that Covered is capable of handling, along with their use and 
    syntax.
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.ATTR.FSM"
>Adding FSM attributes</A
></H2
><P
>    There are two ways that Covered currently allows the user to specify the location of and information about FSMs 
    embedded in a particular design. The first way to specify an FSM is on the score command-line. The benefit to 
    specifying the location of a state machine this way is that the source code does not need to be modified. The 
    potential disadvantage to this method is that the FSM location and coverage information can get lost if the FSM is 
    used in a different testbench (or even a different project if the FSM code is reused in a later project). For more 
    information on specifying an FSM on the score command-line, please refer to 
    <A
HREF="#SECTION.SCORE.FSM"
>Scoring FSMs</A
>.
    </P
><P
>    The second way that an FSM can be specified to Covered is through the use of the Verilog-2001 attribute. The 
    advantages to using this method are that the FSM information specified in an attribute stays embedded in the design 
    (for ease of reusing the FSM and still retaining information relevent to coverage). Additionally, at the current 
    release of Covered, using attributes to specify an FSM is the only way to tell Covered what all of the valid states 
    and state-transitions are for a specific FSM (the command-line specification does not allow for this). This 
    provides a unique advantage of this method over the command-line method. The potential disadvantage of this method 
    for specifying FSM information is that source code needs to be modified.
    </P
><P
>    To learn how to specify an FSM attribute within a design, let's use an example of an FSM that is embedded in a 
    design.
    </P
><P
>      <PRE
CLASS="PROGRAMLISTING"
>  module foo (
    input clk,
    input reset,
    input head,
    input tail,
    input valid
  );
      
    parameter STATE_IDLE = 2'b00,
              STATE_HEAD = 2'b01,
              STATE_DATA = 2'b10,
              STATE_TAIL = 2'b11;
                
    reg [1:0] state;
    reg [1:0] next_state;
      
    always @(posedge clock)
      state &#60;= reset ? STATE_IDLE : next_state;
        
    always @(reset or state or head or valid or tail)
      begin
        case( state )
          STATE_IDLE: next_state = (valid &#38; head) ?
                                     STATE_HEAD : STATE_IDLE;
          STATE_HEAD: next_state = (valid &#38; tail) ?
                                     STATE_TAIL : STATE_DATA;
          STATE_DATA: next_state = (valid &#38; tail) ?
                                     STATE_TAIL : STATE_DATA;
          STATE_TAIL: next_state = (valid &#38; head) ?
                                     STATE_HEAD : STATE_IDLE;
        endcase
      end   
      
  endmodule 
      </PRE
>
    </P
><P
>    This example shows an FSM that has an input FSM variable called "state" and an output FSM variable called 
    "next_state". There are four states in the state machine that are represented with the parameters located in this 
    module (STATE_IDLE, STATE_HEAD, STATE_DATA, STATE_TAIL). There are a total of eight (8) state transitions that this 
    FSM can take. They are the following:
    </P
><P
>      <P
></P
><OL
TYPE="1"
><LI
><P
>STATE_IDLE -&#62; STATE_IDLE (loopback)</P
></LI
><LI
><P
>STATE_IDLE -&#62; STATE_HEAD</P
></LI
><LI
><P
>STATE_HEAD -&#62; STATE_DATA</P
></LI
><LI
><P
>STATE_HEAD -&#62; STATE_TAIL</P
></LI
><LI
><P
>STATE_DATA -&#62; STATE_DATA (loopback)</P
></LI
><LI
><P
>STATE_DATA -&#62; STATE_TAIL</P
></LI
><LI
><P
>STATE_TAIL -&#62; STATE_HEAD</P
></LI
><LI
><P
>STATE_TAIL -&#62; STATE_IDLE</P
></LI
></OL
>
    </P
><P
>    All attributes that specify information for an FSM are a comma-separated list of values that contain the following 
    information:
    </P
><P
>      <P
></P
><OL
TYPE="1"
><LI
><P
>"covered_fsm" attribute keyword</P
><P
>            <P
></P
><UL
><LI
><P
>                MUST be first value in the attribute list
                </P
></LI
><LI
><P
>                Specifies to Covered that this attribute contains information for an FSM that Covered needs to handle.
                </P
></LI
></UL
>
          </P
></LI
><LI
><P
>FSM identifier</P
><P
>            <P
></P
><UL
><LI
><P
>                MUST be second value in the attribute list
                </P
></LI
><LI
><P
>                Specifies a alphanumeric name for this FSM.
                </P
></LI
><LI
><P
>                The name will eventually be used to tie individual attributes that specify information for the same FSM.
                </P
></LI
></UL
>
          </P
></LI
><LI
><P
>Input state expression (optional)</P
><P
>            <P
></P
><UL
><LI
><P
>                Syntax: <FONT
COLOR="RED"
>is="<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>expression</I
></SPAN
>"</FONT
>
                </P
></LI
><LI
><P
>                If this is specified, MUST be specified third in the list.
                </P
></LI
><LI
><P
>                Specifies the input state expression.
                </P
></LI
><LI
><P
>                Can be a combination of signal names, signal bit selects, and concatenation operators.
                </P
></LI
><LI
><P
>                See <A
HREF="#SECTION.SCORE.FSM"
>Scoring FSMs</A
> for more information on the specification of an input 
                state expression.
                </P
></LI
></UL
>
          </P
></LI
><LI
><P
>Output state expression</P
><P
>            <P
></P
><UL
><LI
><P
>                Syntax: <FONT
COLOR="RED"
>os="<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>expression</I
></SPAN
>"</FONT
>
                </P
></LI
><LI
><P
>                If the input state expression is specified, MUST be fourth value in list; otherwise, MUST be third 
                value in list.
                </P
></LI
><LI
><P
>                Specifies the output state expression of the FSM.
                </P
></LI
><LI
><P
>                Can be a combination of signal names, signal bit selects, and concatenation operators.
                </P
></LI
><LI
><P
>                See <A
HREF="#SECTION.SCORE.FSM"
>Scoring FSMs</A
> for more information on the specification of an output 
                state expression.
                </P
></LI
></UL
>
          </P
></LI
><LI
><P
>State-transition specifiers (optional)</P
><P
>            <P
></P
><UL
><LI
><P
>                Syntax: <FONT
COLOR="RED"
>trans="<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>from_state</I
></SPAN
>-&#62;<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>to_state</I
></SPAN
>"</FONT
>
                </P
></LI
><LI
><P
>                MUST be specified after the above has been specified in the list.
                </P
></LI
><LI
><P
>                Arguments MUST be constant values (parameters; numerical values -- binary, octal, decimal, hexidecimal; 
                and defines that equate to one of these two types of values).
                </P
></LI
><LI
><P
>                Each transition that is specified is a unique value in the attribute list.
                </P
></LI
></UL
>
          </P
></LI
></OL
>
    </P
><P
>    To specify the FSM attribute in the above example, including input state, output state and all state transitions, 
    the code would be modified to look like:
    </P
><P
>      <PRE
CLASS="PROGRAMLISTING"
>  ...
      
  (* covered_fsm, channel, is="state", os="next_state",
                           trans="STATE_IDLE-&#62;STATE_IDLE",
                           trans="STATE_IDLE-&#62;STATE_HEAD",
                           trans="STATE_HEAD-&#62;STATE_DATA",
                           trans="STATE_HEAD-&#62;STATE_TAIL",
                           trans="STATE_DATA-&#62;STATE_DATA",
                           trans="STATE_DATA-&#62;STATE_TAIL",
                           trans="STATE_TAIL-&#62;STATE_HEAD",
                           trans="STATE_TAIL-&#62;STATE_IDLE" *)
  always @(reset or state or head or tail or valid)
    ...    
      </PRE
>
    </P
></DIV
></DIV
></DIV
><DIV
CLASS="PART"
><A
NAME="AEN544"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
>II. Installation</H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>6. <A
HREF="#CHAPTER.INSTALLATION"
>Installation</A
></DT
></DL
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER.INSTALLATION"
></A
>Chapter 6. Installation</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN548"
>Prerequisites</A
></H2
><P
>    The goal of Covered was to create a tool that has very few requirements to allow it to be compiled and run on all 
    platforms. The following is a list of all utilities/resources required to compile Covered. However, Covered is 
    primarily developed on RedHat/Fedora Core Linux and Mac OS X and as such is primarily tested by the developers on these
    platforms.
    </P
><P
>      <P
></P
><UL
><LI
><P
><A
HREF="http://www.gnu.org/software/gcc/"
TARGET="_top"
>gcc</A
> (Version 2.96 or higher)</P
></LI
><LI
><P
><A
HREF="http://www.gnu.org/software/flex/"
TARGET="_top"
>flex</A
> (Version 2.5.4 or higher)</P
></LI
><LI
><P
><A
HREF="http://www.gnu.org/software/bison/"
TARGET="_top"
>bison</A
> (Version 1.28 or higher)</P
></LI
><LI
><P
><A
HREF="http://www.gnu.org/software/make/"
TARGET="_top"
>GNU make</A
> (Version 3.27.1 or higher)</P
></LI
><LI
><P
><A
HREF="http://www.gnu.org/software/gperf/"
TARGET="_top"
>GNU gperf</A
> (Version 2.7.2 or higher)</P
></LI
><LI
><P
>            <A
HREF="http://tcl.sourceforge.net/"
TARGET="_top"
>Tcl/Tk</A
> (Versions 8.4 or higher)
            <P
></P
><UL
><LI
><P
><A
HREF="http://www.nemethi.de/"
TARGET="_top"
>tablelist Tcl/Tk widget</A
> (Version 4.9 or higher)</P
></LI
></UL
>
          </P
></LI
></UL
>
    </P
><P
>    Covered is primarily developed on Fedora Core but has been known to compile with both 32-bit and 64-bit compilers 
    that contain the general GNU library of tools. It has also been compiled and run on Cygwin and Mac OS X.
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN576"
>Downloading source</A
></H2
><P
>    To download the source files in .tar.gz format, go to the following URL:
    </P
><P
>      <A
HREF="http://covered.sourceforge.net/downloads/"
TARGET="_top"
>http://covered.sourceforge.net/downloads/</A
>
    </P
><P
>    Double-click on the .tar.gz version that you wish to install. The browser should immediately bring up a window asking 
    if you would like to save to disk or open immediately. Choose the "Save to Disk" option. Another window will pop up, 
    allowing you to choose the directory to store the tarball in. After selecting a directory, click the "Save" button. The 
    download utility will begin downloading the tarball to the selected directory.
    </P
><P
>    Once you have downloaded a tarball, enter the following to unzip and untar the package:
    </P
><P
>      <FONT
COLOR="RED"
>&#62; gzip -dc <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>tarball_filename</I
></SPAN
> | tar xvf -</FONT
>
    </P
><P
>    This will create a directory called covered-<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>version</I
></SPAN
>, where <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>version</I
></SPAN
> will be of the
    form <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>major version.minor version</I
></SPAN
> for stable releases or <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>date</I
></SPAN
> for development
    releases.  Enter that directory to begin configuring, building and compiling Covered from source.
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.CONFIGURING"
>Configuring the build</A
></H2
><P
>    At this point, you are ready to configure the build environment to create the executables, libraries and/or documentation 
    for Covered. However, before you configure the build environment, you will need to make a few decisions which will lead to 
    different options given to the configure script. These questions are the following:
    </P
><P
>      <P
></P
><OL
TYPE="1"
><LI
><P
>Do you need to debug Covered?  (for most users, the answer to this will be "no")</P
></LI
><LI
><P
>Do you want to profile Covered's internal functionality?  (for most users, the answer to this will be "no")</P
></LI
><LI
><P
>Will you being using Covered as a VPI module and, if so, what simulator(s) will you need VPI modules built for?</P
></LI
><LI
><P
>Do you want to use Covered's Tcl/Tk GUI for interactive coverage analysis or just the command-line created reports?</P
></LI
></OL
>
    </P
><P
>    If the answer to question (1) is yes, configure the build environment with the --enable-debug option to the configure script. Doing so will 
    allow you to use the global -D option and/or the -cli (<A
HREF="#SECTION.CLI"
>Command-Line Interface</A
>&#62;) score command option for debugging; however, it will also 
    have the side effect of causing the score command to run noticably slower. For normal usage of Covered, this option should not be specified 
    when configuring.
    </P
><P
>    If the answer to question (2) is yes, configure the build environment with the --enable-profiling option to the configure script. Doing so 
    will allow you to use the global -P option to generate an output file containing internal profiling information for the run command. See 
    <A
HREF="#SECTION.PROFILING"
>Source Code Profiling</A
>&#62; for more information on the -P option.
    </P
><P
>    If the answer to question (3) is yes and you need to build a VPI module for the Icarus Verilog simulation tool, simply add --with-iv on the 
    configure command-line. If a VPI shared object module is needed for the Cver simulator, simply add 
    <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>--with-cver=<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>cver_include_dir</I
></SPAN
></B
></SPAN
> on the configure command line, where 
    <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>cver_include_dir</I
></SPAN
> specifies the directory that contains the vpi_user.h file. If a VPI shared object module is needed for the 
    VCS simulator, simply add <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>--with-vcs=<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>vcs_include_dir</I
></SPAN
></B
></SPAN
> on the configure command line, where 
    <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>vcs_include_dir</I
></SPAN
> specifies the directory that contains the vpi_user.h file.
    </P
><P
>    If the answer to question (4) is yes and you have a Tcl/Tk distribution that the configure script cannot find (i.e., the tcl-config and tk-config
    scripts exist in a non-standard directory location), please specify the <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>--with-tcl-config=<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>tcl-config_pathname</I
></SPAN
></I
></SPAN
> 
    and <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>--with-tk-config=<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>tk-config_pathname</I
></SPAN
></B
></SPAN
> options to the configure script.  If the answer to 
    question (4) is no, specify the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>--with-tcltk=no</B
></SPAN
> option to the configure script to cause the GUI to not be built.
    </P
><P
>    Once you have determined which configuration options you need, simply enter the following command:
    </P
><P
>      <FONT
COLOR="RED"
>      &#62; ./configure <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>options</I
></SPAN
>
      </FONT
>
    </P
><P
>    This command will create the Makefiles/include files necessary for your machine to compile the source code correctly. If any errors are generated 
    during this command run, it is usually an indication that some program or library is missing from your computer that is necessary for Covered 
    to compile/run. Please install any missing programs/libraries and type this command again.
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN626"
>Compiling and Installing</A
></H2
><P
>    If the configure script completes successfully, you may compile the source with the following command:
    </P
><P
>      <FONT
COLOR="RED"
>      &#62; make
      </FONT
>
    </P
><P
>    This will begin the process of compiling/linking the source code for Covered. This stage may take a while. When the source files have been compiled, 
    the covered executable file will have been created. To install this executable in your <FONT
COLOR="RED"
>/usr/local/bin</FONT
> directory, enter the following command:
    </P
><P
>      <FONT
COLOR="RED"
>      &#62; make install
      </FONT
>
    </P
><P
>    This will install the covered executable and manpage help files. Once covered is installed, make sure that <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>/usr/local/bin</I
></SPAN
> is 
    in your environment path. You are now ready to run Covered.
    </P
></DIV
></DIV
></DIV
><DIV
CLASS="PART"
><A
NAME="AEN637"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
>III. Command-line Usage</H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>7. <A
HREF="#CHAPTER.START"
>Getting Started</A
></DT
><DT
>8. <A
HREF="#CHAPTER.USING"
>Using Covered</A
></DT
><DT
>9. <A
HREF="#CHAPTER.SCORE"
>The score Command</A
></DT
><DT
>10. <A
HREF="#CHAPTER.MERGE"
>The merge Command</A
></DT
><DT
>11. <A
HREF="#CHAPTER.REPORT"
>The report Command</A
></DT
><DT
>12. <A
HREF="#CHAPTER.RANK"
>The rank Command</A
></DT
><DT
>13. <A
HREF="#CHAPTER.READING"
>Reading the Report</A
></DT
><DT
>14. <A
HREF="#CHAPTER.DEBUG"
>Debugging</A
></DT
></DL
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER.START"
></A
>Chapter 7. Getting Started</H1
><P
>  Before you are ready to being scoring, merging and generating coverage reports from the design, you will first need to 
  decide whether you want to post-process VCD/LXT -formatted dumpfiles generated from simulation or whether you want to 
  accummulate coverage information alongside the simulator using the simulator's VPI interface. There are advantages and 
  disadvantages to either method, so select the method that will best work for you.
  </P
><P
>  Generating coverage information from VCD/LXT -formatted dumpfiles requires three steps: (1) compile the simulator to 
  dump in the specified format, (2) run the simulation, (3) run Covered's score command using the dumpfile as input along 
  with the design. Performing these steps will generate the needed CDD file that can be used for merging or reporting. 
  The advantages to this approach is that the steps are fairly simple and are compiler/simulator -independent. However, 
  there are two main drawbacks. First, compiling with dumping enabled often slows simulation by some significant factor. 
  Second, the dumpfiles generated from simulation can often be quite large (especially for VCD dumping), consuming a lot 
  of disk space. Additionally, if your simulator dumps in a format different from VCD or LXT, you will need to perform 
  an additional step in transforming the original dumpfile into one of these formats. This is often a time-consuming task 
  if the design and/or dumpfile is significantly large. If you are generating lots of dumpfiles for coverage (say from 
  running a regression), the amount of disk space needed to store these files can be tremendous, making this approach 
  almost not feasible.
  </P
><P
>  Generating coverage information using the VPI interface of the simulator requires three main steps: (1) create a base 
  CDD file from the design along with a top-level Verilog module and PLI table file (this second file is needed for the 
  commercial VCS compiler), (2) compile the simulator using the Covered VPI module (or shared object), (3) run the 
  simulation. The end result of these steps is the same CDD file that results from using the dumpfile method described 
  above. The primary advantage of this approach is that no dumpfiles are required, saving on disk space and dumpfile 
  processing time. The drawbacks of this approach are the following: (1) simulation runs much slower using the VPI and 
  Covered (most likely slower than creating dumpfiles from the simulator), (2) Covered VPI modules are only available 
  for certain compilers (Icarus Verilog, Cver and VCS currently); however, adding support for other compilers should not 
  be a difficult thing to do, (3) the VPI modules will only work for compilers that support the VPI interface (a 
  Verilog-2001 feature).
  </P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN644"
>What is needed for dumpfile scoring?</A
></H2
><P
>    Before Covered can be invoked for dumpfile scoring, you must have a simulatable Verilog design and a VCD or LXT dumpfile 
    containing information from a simulation run of the design that dumps the module(s) that you want to check for coverage. 
    The VCD dumpfile style was chosen due to its universal support by Verilog simulators while the LXT dumpfile style was 
    chosen due to its compactness and growing support by other open source simulators and dumpfile readers. Once you have 
    these two parts, you are ready to begin generating coverage results.
    </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN647"
>Creating a VCD dumpfile</A
></H3
><P
>      In Verilog, the way that you create the VCD dumpfile is by using two types of Verilog system calls (1) $dumpfile and 
      (2) $dumpvars. The following example shows how to create and generate a dumpfile called "test.vcd" that will dump the 
      submodule called "foo".
      </P
><P
>        <PRE
CLASS="PROGRAMLISTING"
>  module test;

    initial begin
      $dumpfile( "test.vcd" );
      $dumpvars( 1, test.foo );
    end

    foo_mod foo();

  endmodule

  module foo_mod;

    ...

  endmodule
        </PRE
>
      </P
><P
>      The $dumpfile system call takes in one parameter that is a string of the name of the dumpfile to create, in this case 
      the dumpfile we want to create is called "test.foo". The purpose of this function to create the file (open it for 
      writing) and outputs some initialization information to the file.
      </P
><P
>      The $dumpvars system call takes in two parameters. The first is the number of levels of hierarchy that you want to 
      dump. In the example, we want to only dump the module instance called "foo" which is why the dump level was set to 1. 
      To dump foo and the level of submodules just beneath it, you would set the dump level to 2 and so on. To dump a module 
      and all submodules beneath it, set the dump level value to 0 (this means the level specified and all levels below it). 
      The second parameter is a Verilog hierarchical reference to the top-level module instance that you want to dump.
      </P
><P
>      The $dumpfile system call may only be called once within a Verilog design. Typically, it is called in the top-most 
      level of the design (or testbench as it is commonly referred to as); however, the language allows you to call it from 
      anywhere in your design as long as it precedes any calls to $dumpvars.
      </P
><P
>      The $dumpvars system call may be called as many times as necessary to dump the Verilog that you need. For example, if 
      you want to get coverage results for several modules scattered around the design, you may make several $dumpvars calls 
      to dump exactly those modules that you want to see coverage for.
      </P
><P
>      For the most part, that is about all there is to creating VCD dumpfiles for the design. All you need to do is run a 
      simulation with these system calls in it and a dumpfile will be generated for that run. Once you have this file, you 
      are ready to see if your design is Covered!
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.LXT.DUMPFILE"
>Creating an LXT dumpfile</A
></H3
><P
>      An LXT dumpfile can be created in several different ways depending on the Verilog simulation tool that you are using. If 
      you are using the <A
HREF="http://www.icarus.com/eda/verilog"
TARGET="_top"
>Icarus Verilog</A
> open source simulator, you can 
      simply generate an LXT-style dumpfile by specifying the -lxt2 option to the simulator command-line. For example, if you 
      had a file called "foo.v" that contained the same $dumpfile and $dumpvars commands used for VCD dumping and compiled it 
      with Icarus Verilog into a VVP file called "a.out", you could cause Icarus Verilog to generate an LXT dumpfile (instead 
      of a VCD dumpfile by calling "vvp a.out -lxt2". This will cause an LXT style dumpfile instead of the standard VCD style 
      dumpfile.
      </P
><P
>      You can also transform many different dumpfile formats into an LXT style dumpfile with the helper programs that come with 
      the <A
HREF="http://home.nc.rr.com/gtkwave/"
TARGET="_top"
>GtkWave</A
> waveform viewer.
      </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.VPI"
>What is needed for VPI scoring?</A
></H2
><P
>    After Covered has been configured and built to include the creation of a VPI loadable module or shared object file (see 
    <A
HREF="#SECTION.CONFIGURING"
>Configuring the build</A
>&#62; for details), Covered is capable of scoring during a simulation run by using the VPI 
    (Verilog Procedural Interface) access mechanism. This is done by loading the Covered VPI module (or shared object) into the 
    simulator executable prior to running (depending on the simulator being used). The following steps should be taken to create 
    a scored CDD file using this method.
    </P
><P
>      <P
></P
><OL
TYPE="1"
><LI
><P
>          Create the Verilog file that will be compiled as a top-level module in the design (alongside the actual top-level(s)).
          </P
><P
>          This is done by running the score command with the -vpi option. The following example command-line shows how this step 
          is done, creating a file called "covered_vpi.v".
          </P
><P
>            <FONT
COLOR="RED"
>            covered score -t top -vpi
            </FONT
>
          </P
></LI
><LI
><P
>          Compile the simulator executable, including the previously generated file and the Covered VPI module. See the compile 
          instructions for the Icarus Verilog, Cver or VCS simulators below.
          </P
></LI
><LI
><P
>          Run the simulation. Once simulation is complete, the resulting CDD file will be a completely scored database, ready to be 
          merged with other CDD files from the same design or reported on.
          </P
></LI
></OL
>
    </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN678"
>Compiling for Icarus Verilog</A
></H3
><P
>      If you are compiling an Icarus Verilog simulation, simply add <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>-m /usr/local/libexec/covered.vpi covered_vpi.v</B
></SPAN
> 
      to the command-line.
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN682"
>Compiling for Cver</A
></H3
><P
>      If you are compiling a Cver simulation, simply add 
      <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>+loadvpi=/usr/local/libexec/covered.cver.so:vpi_compat_bootstrap covered_vpi.v</B
></SPAN
> to the command-line.
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN686"
>Compiling for VCS</A
></H3
><P
>      If you are compiling a VCS simulation, simply add 
      <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>+vpi -load /usr/local/libexec/covered.vcs.so:covered_register covered_vpi.v</B
></SPAN
> to the command-line.
      </P
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER.USING"
></A
>Chapter 8. Using Covered</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN692"
>Work Flow</A
></H2
><P
>    Covered has four basic commands that it uses for gaining coverage information about a design and displaying that information to the user.
    </P
><P
>      <P
></P
><UL
><LI
><P
>score</P
></LI
><LI
><P
>merge</P
></LI
><LI
><P
>report</P
></LI
><LI
><P
>rank</P
></LI
></UL
>
    </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN705"
>Scoring the Design</A
></H3
><P
>      To begin using Covered, you will need to create a special database file called a coverage description database (CDD). Covered uses this 
      file to store coverage-specific information about the DUT. This file is a text-based file that is written in a specific format (the 
      format of this file is not discussed in this document but can be found in the developer's document) that Covered understands.
      </P
><P
>      To create the CDD and populate it with the simulation dumpfile results, you must use the score (see <A
HREF="#CHAPTER.SCORE"
>The score Command</A
>&#62; for details) 
      command. This command parses in the DUT files and generates an initial CDD for the design. This CDD does not contain any coverage 
      details but only the design elements that Covered needs to gain coverage results.
      </P
><P
>      Once the initial CDD has been created, the score command reads in the specified VCD/LXT dumpfile from the given DUT. If Covered recognizes 
      that the VCD/LXT dumpfile does not correspond to the DUT that it parses (dumpfile was not generated from the DUT specified), an error 
      message is supplied to the user telling them this. Once the dumpfile has been parsed, Covered generates a new version of the CDD containing 
      a populated database. This CDD may be merged with another CDD from the same DUT and/or reports may be generated from this CDD.
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN711"
>Merging CDDs</A
></H3
><P
>When two or more CDDs have been generated from the same DUT. It is often desirable to merge their contents to see what the total 
      coverage is for both simulation runs. The reasons why merging is desirable is that often several tests are written to exercise the entire 
      design (not just one). This makes tests easier to write and maintain. Since, typically, only one test is run per simulation run and that 
      test does not fully test the DUT, it is necessary to combine the results of the multiple simulations to the see the combined effect of 
      the tests on the design. This is where merging comes into play.
      </P
><P
>      Merging multiple CDDs from the same design is easy with Covered, and is accomplished with the merge (see <A
HREF="#CHAPTER.MERGE"
>The merge Command</A
>&#62; 
      for details) command. This command reads in two or more CDDs, merges their results and outputs the merged CDD to a different file or 
      replaces the first CDD with the results of the merge.
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN716"
>Creating Coverage Reports</A
></H3
><P
>      After a CDD is created or merged, the contents of the CDD can be extracted and transformed into human readable coverage reports with 
      the report (see <A
HREF="#CHAPTER.REPORT"
>The report Command</A
>&#62; for details) command. A summary report containing the percentage of metrics covered is 
      generated for each module. Additionally, to aid in understanding what and why something was not covered, a verbose reporting mechanism 
      exists. Verbose reporting will explicitly point to and describe why something was not fully covered for a specific metric.
      </P
><P
>      Reports are text-based output that by default are directed toward standard output but may, with the use of an option flag, be output to 
      a specific file for storage purposes.
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN721"
>Ranking CDDs</A
></H3
><P
>      After a collection of CDDs have been generated from a single design (most likely due to a regression run), it is desirable to know
      which CDDs have an effect on coverage and which CDDs do not add any new coverage information.  The CDDs that do not provide additional
      coverage may be unnecessary for regression and removing them may significantly improve a regression runs time (which can help in a
      projects schedule).
      </P
><P
>      Additionally, it also good to know an order that simulations should be run in to produce the maximum amount of coverage the quickest.  
      This information can be useful for creating a quick (or "sanity check" or "confidence") regression that runs in a relatively short 
      period of time and, when run successfully, provides the engineer a level of confidence that recent changes have not severely broke
      the functionality of the design.
      </P
><P
>      This is the purpose of the rank (see <A
HREF="#CHAPTER.RANK"
>The rank Command</A
>&#62; for details) command.  It produces a report that shows the diagnostics
      that add to the overall coverage of the suite, the order that those diagnostics should run, and each diagnostic's overall effect on
      coverage when it is run.
      </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN727"
>Covered usage</A
></H2
><P
>    Covered is initiated with the following command:
    </P
><P
>      <FONT
COLOR="RED"
>      covered (-h | -v | [-P [<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>filename</I
></SPAN
>]] [-D|-Q] (score|merge|report|rank) <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>command_options</I
></SPAN
>)
      </FONT
>
    </P
><P
>    The -v command (described below) is mutually exclusive from the rest of the commands and has the highest priority. If Covered is called 
    with this option and any other options, the version will only be displayed.
    </P
><P
>    The -h command (described below) is mutually exclusive from the rest of the commands and has the second highest priority. If Covered is 
    called with this option and the -v option is not specified, the usage information will be displayed to the screen.
    </P
><P
>    The -Q option suppresses all normal user output from standard output. The only output that will not be suppressed are messages to standard 
    error. This option may be used with any of the Covered commands to achieve this effect. By default, normal user output is sent to standard 
    output.
    </P
><P
>    The -D option outputs debug information to standard output. Its effect overrides the -Q option. This option may be used in conjunction with 
    any other Covered command for the purposes of debugging tool failures. By default, debug mode is turned off and must be enabled in the build 
    of Covered (using the --enable-debug option to configure). This command should only be used for debugging as it generates an immense amount 
    of output which may hinder performance.
    </P
><P
>    The -B option obfuscates all design-sensitive signal, module, task, function, instance, file and parameter names when outputting them to 
    either stdout, stderr or a file (with the exception of CDD file output). This mode is intended to be used for sharing output information 
    with others (including the developer's of Covered) which is sensitive information for the purposes of debugging.
    </P
><P
>    The -P option causes Covered to enable internal code profiling and generates a profiling report that is output to either the given filename 
    or the default filename of "covered.prof". This option is only available if the --enable-profiling configuration option is specified and will 
    cause performance degradation. This option should only be used by Covered developers or those interested in finding performance bottlenecks 
    in Covered's code. It is not recommended that the --enable-profiling configuration option and the -P global option be specified for normal 
    users of Covered. See <A
HREF="#SECTION.PROFILING"
>Source Code Profiling</A
>&#62; for more information on profiling and understanding the profiling report file.
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN741"
>Covered global options</A
></H2
><P
>    The following table describes options that Covered will accept apart from its normal commands which are described in the next several chapters.
    </P
><DIV
CLASS="TABLE"
><A
NAME="AEN744"
></A
><P
><B
>Table 8-1. Global Options to Covered</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><THEAD
><TR
><TH
>            Option
            </TH
><TH
>            Description
            </TH
></TR
></THEAD
><TBODY
><TR
><TD
>            -Q
            </TD
><TD
>            Quiet mode. Suppresses user output to screen. Use in conjunction with a command.
            </TD
></TR
><TR
><TD
>            -D
            </TD
><TD
>            Debug mode. Outputs code debug information to screen. Use in conjunction with commands.
            </TD
></TR
><TR
><TD
>            -B
            </TD
><TD
>            Obfuscate. Obfuscates all design sensitive names before outputting them.
            </TD
></TR
><TR
><TD
>            -P [<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>filename</I
></SPAN
>]
            </TD
><TD
>            Profiling mode. Outputs profiling report to either the given <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>filename</I
></SPAN
> or "covered.prof" if no 
            <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>filename</I
></SPAN
> was specified.
            </TD
></TR
><TR
><TD
>            -h
            </TD
><TD
>            Generates usage output to standard output.
            </TD
></TR
><TR
><TD
>            -v
            </TD
><TD
>            Outputs current version of Covered.
            </TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER.SCORE"
></A
>Chapter 9. The score Command</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN775"
>Usage</A
></H2
><P
>    The score command is initiated with the following call:
    </P
><P
>      <FONT
COLOR="RED"
>      covered [<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>global_options</I
></SPAN
>] score -t <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>top_module</I
></SPAN
> [<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>options</I
></SPAN
>]
      </FONT
>
    </P
><P
>    The <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>top_module</I
></SPAN
> parameter is required for the scoring purposes and represents the top-most module that 
    will be covered. It is important to note that Covered does not need to parse the entire DUT. It only parses that part of 
    the design which will receive coverage results. More on this will be described <A
HREF="#SECTION.SCORE.T"
>Specifying What to Cover</A
>&#62; below.
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN786"
>Options</A
></H2
><P
>    The following table describes the additional options that can be passed to the score command. Note that it is optional in 
    how you tell Covered where to find the Verilog design files; however, it is not optional to exclude the Verilog files. If 
    no Verilog can be found that contains at least the top instance, Covered will generate an error message to the user 
    specifying that it was unable to find the required Verilog modules.
    </P
><P
>      <DIV
CLASS="TABLE"
><A
NAME="AEN790"
></A
><P
><B
>Table 9-1. Options to score Command</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><THEAD
><TR
><TH
>              Option
              </TH
><TH
>              Description
              </TH
></TR
></THEAD
><TBODY
><TR
><TD
>              -A ovl
              </TD
><TD
>              Causes OVL assertions to be used for assertion coverage. This flag must be given to the score command if assertion 
              coverage metrics are needed in the report command. See <A
HREF="#SECTION.METRIC.ASSERT"
>Assertion Coverage</A
>&#62;.
              </TD
></TR
><TR
><TD
>              -cli [<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>filename</I
></SPAN
>]
              </TD
><TD
>              Causes the command-line debugger to be used during VCD/LXT dumpfile scoring. If <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>filename</I
></SPAN
> is 
              specified, this file contains information saved in a previous call to savehist on the CLI and causes the history 
              contained in this file to be replayed prior to the CLI command prompt. If <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>filename</I
></SPAN
> is not 
              specified, the CLI prompt will be immediately available at the start of simulation. This option is only available 
              when Covered is configured with the --enable-debug option. See <A
HREF="#SECTION.CLI"
>Command-Line Interface</A
>&#62;.
              </TD
></TR
><TR
><TD
>              -D <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>name</I
></SPAN
>[=<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>value</I
></SPAN
>]
              </TD
><TD
>              Defines the specified name to 1 or the specified value.
              </TD
></TR
><TR
><TD
>              -e <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>module</I
></SPAN
>
              </TD
><TD
>              Name of module, task, function or named begin/end block to not score. You may specify this option more than once on a 
              command-line; one for each block to remove from coverage. See <A
HREF="#SECTION.SCORE.E"
>Specifying What Not to Cover (Coverage Exclusions)</A
>&#62;.
              </TD
></TR
><TR
><TD
>              -ea
              </TD
><TD
>              Specifies that all always blocks in the design should be excluded from coverage consideration. This option may help to increase 
              performance of the score command if all always blocks in the design do not need to be checked for coverage. By default, always blocks are 
              considered for coverage. See <A
HREF="#SECTION.SCORE.E"
>Specifying What Not to Cover (Coverage Exclusions)</A
>&#62;.
              </TD
></TR
><TR
><TD
>              -ec
              </TD
><TD
>              Specifies that all continuous assignments in the design should be excluded from coverage consideration. This option may help to increase 
              performance of the score command if all assign blocks in the design do not need to be checked for coverage. By default, continuous 
              assignments are considered for coverage. See <A
HREF="#SECTION.SCORE.E"
>Specifying What Not to Cover (Coverage Exclusions)</A
>&#62;.
              </TD
></TR
><TR
><TD
>              -ef
              </TD
><TD
>              Specifies that all final blocks in the design should be excluded from coverage consideration. This option may help to increase performance 
              of the score command if all final blocks in the design do not need to be checked for coverage. By default, final blocks are considered for 
              coverage. See <A
HREF="#SECTION.SCORE.E"
>Specifying What Not to Cover (Coverage Exclusions)</A
>&#62;.
              </TD
></TR
><TR
><TD
>              -ei
              </TD
><TD
>              Specifies that all initial blocks in the design should be excluded from coverage consideration. This option may help to increase 
              performance of the score command if all initial blocks in the design do not need to be checked for coverage. By default, initial blocks 
              are considered for coverage. See <A
HREF="#SECTION.SCORE.E"
>Specifying What Not to Cover (Coverage Exclusions)</A
>&#62;.
              </TD
></TR
><TR
><TD
>              -ep [<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>name</I
></SPAN
>]
              </TD
><TD
>              Causes any code that is inbetween inline coverage pragmas (eg. '// coverage off' ... '//coverage on') to be excluded from coverage 
              consideration. The code specified between these pragmas is not removed from resimulation but is marked as being excluded from coverage for 
              reporting purposes. These exclusions may be undone via the GUI, if necessary, without requiring the design to be resimulated by Covered. 
              If <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>name</I
></SPAN
> is specified, its value will be used by Covered as the pragma keyword to search for in the design (instead of  
              the default value of 'coverage'). This feature can be useful in the event that other tools being used on the design use a similar pragma  
              name and there are tool conflicts. See <A
HREF="#SECTION.SCORE.E"
>Specifying What Not to Cover (Coverage Exclusions)</A
>&#62;.
              </TD
></TR
><TR
><TD
>              -F <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>module</I
></SPAN
>=[<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>in_expr</I
></SPAN
>,]<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>out_expr</I
></SPAN
>
              </TD
><TD
>              Specifies the location to find an FSM to score where <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>module</I
></SPAN
> is the Verilog module containing the FSM,  
              <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>in_expr</I
></SPAN
> is the input state expression and <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>out_expr</I
></SPAN
> is the output state expression. If 
              <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>in_expr</I
></SPAN
> is not specified, out_expr is used as both the input and output state expression.
              </TD
></TR
><TR
><TD
>              -f <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>filename</I
></SPAN
>
              </TD
><TD
>              Name of file containing additional arguments to parse. You may specify this option more than once on a command-line.
              </TD
></TR
><TR
><TD
>              -g [<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>module</I
></SPAN
>=](1|2|3)
              </TD
><TD
>              Specifies what generation of Verilog to use for parsing the design. If <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>module</I
></SPAN
> is specified, uses the given generation 
              value for that module only. If <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>module</I
></SPAN
> is not specified, applies that generation to the entire design. This option may 
              be specified multiple times on the command-line, where options to the left take precedence over the values to the right. 1=Verilog-1995, 
              2=Verilog-2001, 3=SystemVerilog.
              </TD
></TR
><TR
><TD
>              -h
              </TD
><TD
>              Outputs usage information for the score command.
              </TD
></TR
><TR
><TD
>              -I <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>directory</I
></SPAN
>
              </TD
><TD
>              Directory to find included Verilog files. You may use this option as many times as necessary on the command-line, one for each directory.
              </TD
></TR
><TR
><TD
>              -i <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>instance</I
></SPAN
>
              </TD
><TD
>              Instance name of top-level module. Necessary if module to verify coverage is not the top-level module in the design. If not specified, -t 
              value is used. See <A
HREF="#SECTION.SCORE.T"
>Specifying What to Cover</A
>&#62;.
              </TD
></TR
><TR
><TD
>              -lxt <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>dumpfile</I
></SPAN
>
              </TD
><TD
>              Name of LXT/LXT2 dumpfile to score design with. If this option or the -vcd option is not used, Covered will only create an initial CDD 
              file from the design and will not attempt to score the design.
              </TD
></TR
><TR
><TD
>              -o <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>filename</I
></SPAN
>
              </TD
><TD
>              Name of CDD to write coverage information to.
              </TD
></TR
><TR
><TD
>              -p <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>filename</I
></SPAN
>
              </TD
><TD
>              Overrides filename used for outputting intermediate preprocessor output.  See <A
HREF="#SECTION.SCORE.OTHER"
>Other Notes</A
>&#62;.
              </TD
></TR
><TR
><TD
>              -P <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>parameter_scope</I
></SPAN
>=<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>value</I
></SPAN
>
              </TD
><TD
>              Performs a defparam on the specified parameter with value. See <A
HREF="#SECTION.SCORE.PARAM"
>Overriding Parameters</A
>&#62;.
              </TD
></TR
><TR
><TD
>              -r(S|W|E|I|P[=<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>name</I
></SPAN
>])
              </TD
><TD
>              Determines Covered's behavior for handling found race conditions in design (-rS = do not output information but continue scoring design, 
              -rW = output information and continue scoring design, -rE = output information and immediately exit the scoring process, -rI = skip the 
              race condition check for all modules, -rP = skip race condition check for all code surrounded by '// racecheck off' and '// racecheck on' 
              inline pragmas (the keyword "racecheck" may be substituted for another name by specifying -rP=<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>name</I
></SPAN
>). See <A
HREF="#SECTION.RACE.HANDLING"
>Race Condition Handling</A
>&#62;.
              </TD
></TR
><TR
><TD
>              -S
              </TD
><TD
>              Outputs simulation statistics after simulation has completed. This information is currently only useful for the developers of Covered.
              </TD
></TR
><TR
><TD
>              -ts <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>number</I
></SPAN
>
              </TD
><TD
>              When scoring occurs, this option allows the user to see how far the simulator has progressed by outputting the current timestep to 
              standard output. The value of <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>number</I
></SPAN
> specifies how many timesteps are allowed to be simulated before outputting the 
              current timestep (results in less calls to output stream).
              </TD
></TR
><TR
><TD
>              -T (min|typ|max)
              </TD
><TD
>              Specifies which value to use in min:typ:max delay expressions. Default is typ.
              </TD
></TR
><TR
><TD
>              -v <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>filename</I
></SPAN
>
              </TD
><TD
>              Name of specific Verilog file to score. You may specify this option more than once on a command-line; one for each filename to parse.
              </TD
></TR
><TR
><TD
>              -vcd <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>dumpfile</I
></SPAN
>
              </TD
><TD
>              Name of VCD dumpfile to score design with. If this option or the -lxt option is not used, Covered will only create an initial CDD file 
              from the design and will not attempt to score the design.
              </TD
></TR
><TR
><TD
>              -vpi [<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>filename</I
></SPAN
>]
              </TD
><TD
>              If this option is specified without the -vcd or -lxt options, the design is parsed, a CDD file is created and a top-level Verilog module 
              named <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>filename</I
></SPAN
> (if this value is specified) or "covered_vpi.v" (if filename is not specified) is created along with a 
              PLI table file called <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>filename</I
></SPAN
>.tab or "covered_vpi.v.tab". Both of these files are used in the compilation of the 
              simulator to use Covered as a VPI module. If either the -vcd or -lxt options are specified, this option has no effect. See <A
HREF="#SECTION.LXT.DUMPFILE"
>Creating an LXT dumpfile</A
>&#62;
              </TD
></TR
><TR
><TD
>              -vpi_ts (1|10|100)(s|ms|us|ns|ps|fs)/(1|10|100)(s|ms|us|ns|ps|fs)
              </TD
><TD
>              This option is only valid when the -vpi option has been specified. This option allows the user to specify a timescale for the generated 
              Verilog module created with the -vpi option. If this option is not specified, no timescale will be created for the generated module. If 
              whitespace is needed between the various values, place the entire contents of timescale in double quotes.
              </TD
></TR
><TR
><TD
>              -y <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>directory</I
></SPAN
>
              </TD
><TD
>              Directory to find unspecified Verilog files. You may specify this option more than once on a command-line; one for each directory 
              required.
              </TD
></TR
><TR
><TD
>              +libext+.extension[+.extension]*+
              </TD
><TD
>              Extensions of Verilog files to allow in scoring.
              </TD
></TR
></TBODY
></TABLE
></DIV
>
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.SCORE.T"
>Specifying What to Cover</A
></H2
><P
>    Covered is not a logic simulator and, therefore, is not required to parse the entire DUT. True simulation is performed by the Verilog simulator used 
    to generate the VCD/LXT dumpfile. Covered, therefore, is given the ability to parse only the part of the DUT that is to be scored for coverage. 
    Having this ability to ignore parts of the DUT has several advantages in the way of performance. Less memory is necessary for coverage simulation/
    calculation. Additionally, less processing is also required which leads to faster turnaround. On the other hand, since Covered ignores the parts of 
    the design not being scored, some information is not automatically extracted by Covered that is required for scoring the specified part of the DUT. 
    The <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>defparam</I
></SPAN
> statement is one such statement. More on this is mentioned in the following section.
    </P
><P
>    The following example describes a complete DUT and how to cause Covered to score various parts of the DUT.
    </P
><P
>      <DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/vhier.png"></P
></DIV
>
    </P
><P
>    Assume that the following Verilog modules are used to create this tree.
    </P
><P
>      <P
></P
><UL
><LI
><P
>module "test" instantiated as "test" in the above figure</P
></LI
><LI
><P
>module "foomod" instantiated as "foo"</P
></LI
><LI
><P
>module "barmod" instantiated as "bar"</P
></LI
><LI
><P
>module "amod" instantiated as "a"</P
></LI
><LI
><P
>module "bmod" instantiated as "b"</P
></LI
></UL
>
    </P
><P
>    To get coverage for the entire design, the covered command line would be:
    </P
><P
>      <FONT
COLOR="RED"
>covered score -t test -i test (rest of command-line)</FONT
>
    </P
><P
>    Because both the -t and -i options are the same value (the module name is the same as the instance name), only the -t option needs to be specified. 
    If the -i option is not specified, Covered will assume that the instance name of the top module is the same name as the top module itself. Note that 
    the -t option always needs to be specified for the score command.
    </P
><P
>    To get coverage for the instance foo and all modules below it, the covered command line would be:
    </P
><P
>      <FONT
COLOR="RED"
>covered score -t foomod -i test.foo (rest of command-line)</FONT
>
    </P
><P
>    In this case, we do not wish to score the module test (the top-level file for the design) but rather wish to gain coverage information for module 
    foomod and all instantiated modules underneath it. Since foomod is not the top-level design file, the -i option must be specified to tell Covered 
    what the hierarchical scope of the top-level score file is in relation to the entire design. The main reason why this is necessary is so that 
    Covered will be able to locate the dumpfile information for the modules/instances that need to be scored.
    </P
><P
>    To get coverage for only the instance foo (and none of the modules instantiated below it in the hierarchy), Covered command-line would look like the 
    following:
    </P
><P
>      <FONT
COLOR="RED"
>covered score -t foomod -i test.foo -e amod -e bmod</FONT
>
    </P
><P
>    Here we see the use of the -e option, it takes a module name as its value. When a module with the matching name is found in the hierarchy, it and 
    all of its submodules are removed from coverage. You may specify as many -e arguments as necessary to select the appropriate modules to cover.
    </P
><P
>    To get coverage for the instance foo and all modules below it, in addition to the instance bar, you would have to run Covered twice (once for each 
    top instance).
    </P
><P
>    The -vcd <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>vcd_dumpfile</I
></SPAN
> or -lxt <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>lxt_dumpfile</I
></SPAN
> parameter is simply the name of the VCD/LXT dumpfile that 
    contains all of the module instances selected by the -t parameter (in combination with the -e option -- see below).
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.SCORE.E"
>Specifying What Not to Cover (Coverage Exclusions)</A
></H2
><P
>    Besides the -e option (scope exclusion), Covered comes equipped with several other means of excluding codes from coverage consideration. The -ea, -
    ec, -ei and -ef exclusion options cause Covered to not simulate always blocks, continuous assignment blocks, initial blocks and final blocks, 
    respectively, allowing for additional score command performance enhancement opportunities. These options affect all code that is under coverage 
    consideration for the current score command, and cannot be turned on/off on an individual basis.
    </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.SCORE.EP"
>Using the -ep Option for Exclusion</A
></H3
><P
>      The -ep exclusion option allows Covered to exclude all code that has user-specified coverage pragmas embedded inline in the code being considered 
      for coverage. By default, these pragmas look like the following:
      </P
><P
>        <PRE
CLASS="PROGRAMLISTING"
>  module foo;
      
    // coverage off
    ...
    // coverage on
      
  endmodule;      
        </PRE
>
      </P
><P
>      Any registers, nets, variables, blocks, expressions, FSMs or assertions found within these pragmas within the design being parsed by Covered will 
      be excluded from coverage consideration when the -ep option is specified. If the -ep option is not specified, these pragmas are ignored by 
      Covered.
      </P
><P
>      The code that is found between these pragmas is not removed from resimulation, however. Therefore, if the user decides that any code found within 
      these pragmas needs to be considered, they may change the exclusion properties via the GUI without needing to rerun Covered's score command. 
      Coverage numbers in generated reports will treat excluded code as though it has been hit (i.e., the coverage points will be a part of the total 
      number and the hit counts will be increased as though these coverage points were hit during simulation).
      </P
><P
>      The coverage pragmas may use either the single-line C++ comment style (//) or the multi-line C comment style (/* */). By default, the pragma is 
      identified with the keyword 'coverage' following the comment characters. This value can be changed by the user, if needed, by specifying a string 
      value to the right of the -ep option in the score command. This can be useful if there are other programs that use the same pragma keyword and 
      causes conflicts with Covered's use of this pragma name. The value specified after the keyword is either 'off' (meaning that code should be 
      excluded from coverage consideration after this comment) or 'on' (meaning that code should be considered for coverage after this comment). The 
      values of 'off' and 'on' have the same meanings regardless of the pragma keyword so be sure to rename the pragma keyword to something that is 
      appropriate.
      </P
><P
>      Coverage pragmas may be embedded within each other, if desired. That is the following code example is allowed and handled properly by Covered' 
      parser:
      </P
><P
>        <PRE
CLASS="PROGRAMLISTING"
>  module foobar;
      
    reg b, c, d, e;
      
    // coverage off
      
    wire a;
      
    // coverage off
    assign a = b &#38; c;
    // coverage on
      
    assign e = ~d;
    // coverage on
      
  endmodule     
        </PRE
>
      </P
><P
>      The net effect of this example is that all code between the outer 'coverage off' and 'coverage on' pragmas are excluded from coverage.
      </P
><P
>      One last note about the -ep option is that coverage exclusion is restricted on a per file basis. That is, if the user specifies a '// coverage 
      off' pragma within a file and does not specify a '// coverage on' pragma later in the file, the next file to be parsed by Covered will be handled 
      as if coverage is on. Coverage pragmas can, however, span across multiple modules or other entities within the same file.
      </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.SCORE.PARAM"
>Overriding Parameters (-P option)</A
></H2
><P
>    The <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>defparam</I
></SPAN
> statement can override any parameter specified in the DUT from any module in the DUT. Since parameter information 
    is not typically specified in VCD/LXT dumpfiles, Covered needs to know about all parameter values at score time. Since all defparam statements are 
    ignored by the Covered parser (even those in the DUT being scored), the user must inform Covered of any parameters that need to be overridden. This 
    is accomplished with the -P option to the score command.
    </P
><P
>    The first value in the -P option is the hierarchical reference to the parameter that needs to be overridden. The second value (following the '=' 
    sign) specifies the value to assign the parameter to. This will override any default value assigned to that parameter. The user may not override the 
    same parameter value twice on the command-line. Additionally, if the parameter is already being overridden in the design via an inline parameter 
    override (parameter overrides specified in the '#(...)' part of the module instantiation).
    </P
><P
>    As an example of how to override a parameter value on the score command-line, let's assume that there is a parameter called 'google' in the module 
    called 'amod' used in the example in Section 9.3. The parameter definition in this module looks like the following:
    </P
><P
>      <FONT
COLOR="RED"
>parameter google = 4'hf;</FONT
>
    </P
><P
>    To override this value to a new value of 18, use the following option in the score command:
    </P
><P
>      <FONT
COLOR="RED"
>-P test.foo.a.google=18</FONT
>
    </P
><P
>    In this example, notice that we have not only changed the value of google, but we have also changed the bit-width of google from 4 bits to 32 bits 
    (the size of an integer). This is considered legal behavior by Covered.
    </P
><P
>    It is also possible to specify non-integer values to the parameter override option. Decimal, binary, octal and hexidecimal values may also be 
    specified, using the same syntax as they are specified in Verilog. The following examples would also be other ways to override the value to 18.
    </P
><P
>      <PRE
CLASS="PROGRAMLISTING"
>  -P test.foo.a.google=5'b10010
  -P test.foo.a.google=4'o22
  -P test.foo.a.google=12'h12
  -P test.foo.a.google='d18    
      </PRE
>
    </P
><P
>    In fact, you may specify any value (with the exception of real numbers) to override a parameter, including the following value types: 'x', 'X', 'z', 
    'Z', '_', '?'. This means that unknowns may be specified in a parameter. Note that this may generate user reported errors if parameters overridden 
    to unknown values are used in mathematical equations or are used to specify the width of wires, regs, etc.
    </P
><P
>    If a defparam statement is encountered in the DUT being scored, a warning message will be output to the user specifying that it has encountered a 
    defparam statement. The defparam statement is ignored by Covered; however, if the parameter that it is overridding is used in the DUT being scored, 
    the results of Covered may differ from actual simulation results. As such, please review all of these warning types to determine if the parameter 
    should be overridden or not. If defparams are not parsed (seen by Covered), no such warning will be output. Please review the DUT for defparams 
    which affect the DUT being scored.
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.SCORE.FSM"
>Scoring FSMs</A
></H2
><P
>    At this time Covered does not have the ability to automatically extract FSM information from the design. As a result, it is up to the user to 
    specify FSM information for Covered to use in scoring FSMs. The ability to automatically extract FSM information is planned to be supported in the 
    future; however, it is always a good idea to allow the user to specify and potentially override Covered's automatic extraction in the case where 
    Covered either misses an FSM or incorrectly determines logic to be an FSM in cases where none exists. The information specified in this section 
    describes how to tell Covered where an FSM exists within the design as of the current development version of Covered.
    </P
><P
>    First, we need to make a few assumptions about the type of FSMs that Covered will be able to handle and, in the future, identify.
    </P
><P
>      <P
></P
><OL
TYPE="1"
><LI
><P
>The FSM is a synchronous design with edge-triggered flip-flops.</P
></LI
><LI
><P
>There are no FSMs embedded in another FSM.</P
></LI
><LI
><P
>The FSM is not a pipe-lined system.</P
></LI
><LI
><P
>The entire FSM must exist within the same module.</P
></LI
><LI
><P
>All state registers/variables must be less than 2^16 bits in width.</P
></LI
></OL
>
    </P
><P
>    There is currently only one way, via the command-line, to specify to Covered where to find FSMs within the design. In the future, the inline 
    Verilog-2001 "$attribute" function will be used to also allow the user to specify to Covered where an FSM is located. Using the command-line method, 
    no changes need to be to source Verilog code for Covered's purposes.
    </P
><P
>    To specify where an FSM exists within the design, the -F option must be specified to Covered's score command. Each -F option specifies one FSM 
    within the design. Multiple -F options to the score command are allowed, allowing more than one FSM to be scored simultaneously. The -F option takes 
    one argument that is subdivided into two or three parts:
    </P
><P
>      <FONT
COLOR="RED"
>-F <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>module</I
></SPAN
>=(<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>input_state_expression</I
></SPAN
>,)<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>output_state_expression</I
></SPAN
></FONT
>
    </P
><P
>    The <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>module</I
></SPAN
> specifies the Verilog module where the FSM state variables exist. The <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>input_state_expression</I
></SPAN
> 
    specifies the name of the variable(s) that represent the input state of the state machine. The <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>output_state_expression</I
></SPAN
> 
    specifies the name of the variable(s) that represent the output state of the state machine. Most FSMs have one variable as the input state (in most 
    cases a registered version of the output state) such that the input variable is different than the output variable of the state machine. Specifying 
    both variables in the -F option provides the user to more accurately specify to Covered the FSM. In the case that an FSM has the same variable for 
    the input and output state, the user must specify only the output state variable (omitting the <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>input_state_expression</I
></SPAN
> and comma 
    character in the argument).
    </P
><P
>    The input and output expression to the -F command can represent any signals, parts of signals, or combinations of signals. Constant values or 
    parameters in the specification of the input/output expression is currently not supported (in fact, there are no future plans to support this 
    behavior unless user-feedback demands it). The following examples show various legal ways to specify input/output expressions. The syntax is limited 
    to what it shown in these examples.
    </P
><P
>      <FONT
COLOR="RED"
>-F foobar=a</FONT
>
    </P
><P
>    Example 1 specifies that the entire vector called "a" should be considered both the input and output state variable.
    </P
><P
>      <FONT
COLOR="RED"
>-F foobar=a[2]</FONT
>
    </P
><P
>    Example 2 specifies that bit 2 of the vector called "a" should be considered both the input and output state variable.
    </P
><P
>      <FONT
COLOR="RED"
>-F foobar=a[3:1]</FONT
>
    </P
><P
>    Example 3 specifies that bits 3:1 of the vector called "a" should be considered both the input and output state variable.
    </P
><P
>      <FONT
COLOR="RED"
>-F foobar={a,b}</FONT
>
    </P
><P
>    Example 4 specifies that vectors "a" and "b" should be concatenated to form the input/output state variable. Only one set of curly brackets may be 
    used to specify a concatenated state expression; however, 2 or more signals may be specified within those brackets.
    </P
><P
>    Any combination of the above four examples can be used to formalate the input state expression or the output state expression.
    </P
><P
>    If the user specifies an FSM that Covered is not able to find (either the module was not included in the design that Covered is scoring or the FSM 
    uses Verilog code that Covered is not able to handle), an error message is displayed to the user. It is then up to the user to determine if the FSM 
    was incorrectly specified to Covered or otherwise. This warning is not considered to be a bug in Covered (unless of course, it can be proven that 
    the FSM should have been found).
    </P
><P
>    At the current time, Covered does not have the ability to extract the states and state transitions of the specified FSM from the design. Currently, 
    it also doesn't have the ability to specify this information in other ways. To provide meaningful coverage information for the FSM, Covered outputs 
    all hit states and state transitions in the report when all achievable states and state transitions are not known. This information will be able to 
    be specified by the user in future versions of Covered, with the ability to automatically extract this information also in the works.
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.SCORE.OTHER"
>Other Notes</A
></H2
><P
>    When the Verilog files are parsed, a preprocessor is run on each file that is to be read in by Covered. The preprocessor generates an intermediate 
    form of each file, resolving defined values and included files. The intermediate form is output to a file which is called "tmpXXXXXX" where XXXXXX 
    represents some alphanumeric sequence chosen by the OS via the mkstemp() function. The file is guaranteed to be unique to all other files in the 
    directory and it is automatically removed by Covered when parsing is completed.
    </P
><P
>    If the user does not want Covered to use this naming convention for specifying this file, the user may use the -p option (see Options section above) 
    to override the default name. Covered will then use this filename instead of generating a unique name. Make sure that the file specified does not 
    contain any useful data since Covered will overwrite this file when the score command is run.
    </P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER.MERGE"
></A
>Chapter 10. The merge Command</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="SECTION.MERGE.USING"
>Usage</A
></H2
><P
>    The merge command is initiated with the following call:
    </P
><P
>      <FONT
COLOR="RED"
>covered merge [<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>options</I
></SPAN
>] <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>existing_CDD</I
></SPAN
> <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>CDD_to_merge</I
></SPAN
>+</FONT
>
    </P
><P
>    The <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>existing_CDD</I
></SPAN
> specifier relates to any existing CDD. If the -o option is not specified (see 
    below for details), this file will be replaced with the merged CDD created by the merge. This is important to 
    remember since merging is an irreversible operation (apart from generating a brand-new CDD from the design and 
    dumpfile using the score command).
    </P
><P
>    The <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>CDD_to_merge</I
></SPAN
> specifier relates to any existing CDD that is not the 
    <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>existing_CDD</I
></SPAN
>. Though it is not illegal to merge the same CDD to itself, the result is the same 
    as the original CDD. Note that all files treated as <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>CDD_to_merge</I
></SPAN
> are guaranteed not to be 
    modified by the merge command. These files are only read by Covered and then merged into the information contained 
    in the <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>existing_CDD</I
></SPAN
>.
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.MERGE.OPTIONS"
>Options</A
></H2
><P
>      <DIV
CLASS="TABLE"
><A
NAME="AEN1073"
></A
><P
><B
>Table 10-1. Options to merge Command</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><THEAD
><TR
><TH
>              Option
              </TH
><TH
>              Description
              </TH
></TR
></THEAD
><TBODY
><TR
><TD
>              -d <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>directory</I
></SPAN
>
              </TD
><TD
>              Directory to search for CDD files to include.  This option is used in conjunction with the -ext option 
              which specifies the file extension to use for determining which files in the directory are CDD files.
              </TD
></TR
><TR
><TD
>              -ext <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>extension</I
></SPAN
>
              </TD
><TD
>              Used in conjunction with the -d option.  If no -ext options are specified on the command-line, the 
              default value of '.cdd' is used.  Note that a period (.) should be specified.
              </TD
></TR
><TR
><TD
>              -f <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>filename</I
></SPAN
>
              </TD
><TD
>              Name of file containing additional arguments to parse. You may specify this option more than once on a 
              command-line.
              </TD
></TR
><TR
><TD
>              -h
              </TD
><TD
>              Outputs usage information for the merge command.
              </TD
></TR
><TR
><TD
>              -o <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>filename</I
></SPAN
>
              </TD
><TD
>              Name of CDD to write merged coverage information to (if not specified, the 
              <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>existing_CDD</I
></SPAN
> is overwritten with merged CDD).
              </TD
></TR
></TBODY
></TABLE
></DIV
>
    </P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER.REPORT"
></A
>Chapter 11. The report Command</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="SECTION.REPORT.USAGE"
>Usage</A
></H2
><P
>    The report command is initiated with the following call:
    </P
><P
>      <FONT
COLOR="RED"
>covered report (-view | [<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>options</I
></SPAN
>] <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>CDD_filename</I
></SPAN
>)</FONT
>
    </P
><P
>    The <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>CDD_filename</I
></SPAN
> refers to the name of the CDD to generate the report for. This CDD may be 
    either the result of a score or the result of merging CDDs.
    </P
><P
>    If the -view option is specified, Covered's GUI is run.  See <A
HREF="#CHAPTER.GUI.INTRO"
>Introduction to the GUI</A
>&#62; for instructions 
    on using the GUI for interactive coverage analysis.
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.REPORT.OPTIONS"
>Options</A
></H2
><P
>    The following table lists the options available for use with the report command.
    </P
><P
>      <DIV
CLASS="TABLE"
><A
NAME="AEN1118"
></A
><P
><B
>Table 11-1. Options to report Command</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><THEAD
><TR
><TH
>              Option
              </TH
><TH
>              Description
              </TH
></TR
></THEAD
><TBODY
><TR
><TD
>              -b
              </TD
><TD
>              If combinational logic verbose output is reported and the expression is a vector operation, this option 
              outputs the coverage information on a bitwise basis.
              </TD
></TR
><TR
><TD
>              -c
              </TD
><TD
>              Used in conjunction with the '-d d' or '-d v' option. If set, causes covered logic to be reported instead 
              of default behavior of reporting uncovered logic. See <A
HREF="#SECTION.REPORT.CU"
>Covered Vs. Uncovered</A
>&#62;
              </TD
></TR
><TR
><TD
>              -d (s|d|v)
              </TD
><TD
>              Level of report detail (s=summary, d=detailed, v=verbose). Default is to display summary coverage 
              information. See <A
HREF="#SECTION.REPORT.SDV"
>Summary Vs. Detailed Vs. Verbose</A
>&#62;.
              </TD
></TR
><TR
><TD
>              -f <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>filename</I
></SPAN
>
              </TD
><TD
>              Name of file containing additional arguments to parse. You may specify this option more than once on a 
              command-line.
              </TD
></TR
><TR
><TD
>              -h
              </TD
><TD
>              Outputs usage information for the report command.
              </TD
></TR
><TR
><TD
>              -i
              </TD
><TD
>              Generates report information for each instance (default is to generate per module). See 
              <A
HREF="#SECTION.REPORT.MI"
>Module Vs. Instance</A
>&#62;
              </TD
></TR
><TR
><TD
>              -m [l][t][c][f][r][a][m]
              </TD
><TD
>              Specifies type of coverage information to report (l=line, t=toggle, c=combinational logic, f=FSM 
              state/arc, r=race condition, a=assertion, m=memory). Default is ltcf.
              </TD
></TR
><TR
><TD
>              -o <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>filename</I
></SPAN
>
              </TD
><TD
>              Specifies output file to stream report to (default is standard output).
              </TD
></TR
><TR
><TD
>              -s
              </TD
><TD
>              Suppresses modules/instances that do not contain any coverage information from being output to the 
              coverage report. This may eliminate potentially meaningless information from the report.
              </TD
></TR
><TR
><TD
>              -view
              </TD
><TD
>              Starts the interactive Covered report viewer GUI.
              </TD
></TR
><TR
><TD
>              -w (<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>number</I
></SPAN
>)
              </TD
><TD
>              Specifies the maximum line width (in characters) that can be used to output Verilog information. If this 
              option is not specified, all Verilog code in the report will retain the same formatting as was specified 
              in the original Verilog code. If this option is specified, Verilog code will be formatted to use as much 
              of the current line as possible, wrapping text when the line reaches the maximum line width. The default 
              maximum line width is 115 characters (this value is used if no number is specified with the -w option). 
              If a number is specified with the -w option, this value is used for the maximum line width.
              </TD
></TR
></TBODY
></TABLE
></DIV
>
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.REPORT.SDV"
>Summary Vs. Detailed Vs. Verbose</A
></H2
><P
>    There are three forms of reports that can be generated by the Covered report function: summary, detailed, and 
    verbose. The three forms are described below.
    </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.REPORT.SUMMARY"
>Summary Report</A
></H3
><P
>      A summary report shows at a very high-level what the coverage for a specific module (or instance) is in terms of 
      line, toggle, combinational and/or FSM coverage (depending on which types are selected on the command line). Each 
      coverage metric for the module is given a percentage of items covered for that metric as well as the total number 
      of items per metric, the number of items "hit" during simulation and the number of items "missed" during 
      execution. See the chapter on "Reading the Report" for more information on understanding the formats of line, 
      toggle, combinational logic, and FSM summary information.
      </P
><P
>      The summary report is useful for understanding exactly which modules are missing coverage (and what type(s) of 
      coverage are missing) as well as what modules are fully covered. This can help guide you more easily in 
      understanding where you need to improve your code coverage without getting lost in all of the details that the 
      verbose reporting provides.
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.REPORT.DETAILED"
>Detailed Report</A
></H3
><P
>      The detailed report is useful for understanding where logic was found to be uncovered in the design along with 
      some higher-level information to understand why it was considered to be uncovered. This amount of detail is 
      between the minimum (summary coverage) and the maximum (verbose coverage) and should be used as the first 
      detailed report to be looked at since it is easier to read and comprehend the coverage results.
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.REPORT.VERBOSE"
>Verbose Report</A
></H3
><P
>      The verbose report contains all of the data that the summary report contains; however, in addition to the summary 
      information for a module (or instance), a more in-depth look at the exact cases that were "missed" during 
      simulation are provided. This report outputting option is useful for combinational logic report information when 
      a more in-depth look at why certain expressions did not reach full coverage is needed. This option allows the 
      user to look at all subexpressions of an expression that were not fully covered.
      </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.REPORT.MI"
>Module Vs. Instance</A
></H2
><P
>    Any report can be calculated by module or by instance. Both reports are of interest for verification purposes and 
    the differences are described as follows.
    </P
><P
>    Module reporting combines the results of all instances that come from the same module. That is, when a module is 
    instantiated multiple times in a design, the coverage results from all covered instances are merged together and 
    output as one combined module. This reporting format allows a test writer to see if any logic within a module has 
    not been touched during simulation.
    </P
><P
>    Instance reporting displays each instance in the covered design separately (no combining occurs). This reporting 
    format is useful for determining if certain instances within a design are being neglected. For instance, if a 
    module is instantiated four times (i.e., four instances of the same buffer), it may be that the first buffer is 
    used more often than the other three buffers. This could indicate controller errors or just an indication that 
    there was not enough activity during simulation to fill the other buffers (need to bolster diagnostics or possibly 
    some buffers could be removed?) This type of information would not be viewable if only module reporting were 
    performed.
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.REPORT.CU"
>Covered Vs. Uncovered</A
></H2
><P
>    Covered has the ability the generate reports from any given CDD file that displays either uncovered logic (the 
    default behavior) or covered logic. It is understandable why one would want to generate reports displaying 
    uncovered logic (this is probably the reason why you are interested in this tool in the first place). However, why 
    would anyone be interested in reporting covered logic?
    </P
><P
>    The reason for having this option is two-fold (and maybe there are other reasons). First, this option is useful in 
    debugging the report command since it let's the user evaluate whether a particular signal or portion of logic was 
    actually fully covered or not. Second, it may be useful for user's of the tool to understand what logic is being 
    evaluated for coverage and what logic is not. If only uncovered logic was supplied for evaluation of the tool, one 
    could not evaluate the effectiveness of the tool. However, by allowing the user to see what logic is covered and 
    uncovered, a more full picture of the tool's capability can be understood.
    </P
><P
>    To generate a report that specifies what logic is not covered (output only available in verbose reporting mode), no 
    further options are needed. To generate a report that specifies what logic is being covered, simply specify the -c 
    option along with the -v option when calling the report command.
    </P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER.RANK"
></A
>Chapter 12. The rank Command</H1
><P
>  TBD
  </P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.RANK.OPTIONS"
>Options</A
></H2
><P
>      <DIV
CLASS="TABLE"
><A
NAME="AEN1194"
></A
><P
><B
>Table 12-1. Options to rank Command</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><THEAD
><TR
><TH
>              Option
              </TH
><TH
>              Description
              </TH
></TR
></THEAD
><TBODY
><TR
><TD
>              -depth <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>number</I
></SPAN
>
              </TD
><TD
>              Specifies the minimum number of CDD files to hit each coverage point. The value of 
              <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>number</I
></SPAN
> should be a value of 1 or more.  Default is 1.
              </TD
></TR
><TR
><TD
>              -d <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>directory</I
></SPAN
>
              </TD
><TD
>              Directory to search for CDD files to include.  This option is used in conjunction with the -ext option 
              which specifies the file extension to use for determining which files in the directory are CDD files.
              </TD
></TR
><TR
><TD
>              -ext <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>extension</I
></SPAN
>
              </TD
><TD
>              Used in conjunction with the -d option.  If no -ext options are specified on the command-line, the 
              default value of '.cdd' is used.  Note that a period (.) should be specified.
              </TD
></TR
><TR
><TD
>              -f <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>filename</I
></SPAN
>
              </TD
><TD
>              Name of file containing additional arguments to parse.
              </TD
></TR
><TR
><TD
>              -h
              </TD
><TD
>              Displays help information for the rank command.
              </TD
></TR
><TR
><TD
>              -names-only
              </TD
><TD
>              If specified, outputs only the needed CDD filenames that need to be run in the order they need to be run. 
              If this option is not set, a report-style output is provided with additional information.
              </TD
></TR
><TR
><TD
>              -o <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>filename</I
></SPAN
>
              </TD
><TD
>              Name of file to output ranking information to.  Default is stdout.
              </TD
></TR
><TR
><TD
>              -require <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>filename</I
></SPAN
>
              </TD
><TD
>              Name of file containing list of CDD files which are required to be in the list of ranked CDDs to be run.
              </TD
></TR
><TR
><TD
>              -weight-assert <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>number</I
></SPAN
>
              </TD
><TD
>              Specifies a relative weighting for assertion coverage used to rank non-unique coverage points.
              </TD
></TR
><TR
><TD
>              -weight-comb <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>number</I
></SPAN
>
              </TD
><TD
>              Specifies a relative weighting for combinational logic coverage used to rank non-unique coverage points.
              </TD
></TR
><TR
><TD
>              -weight-fsm <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>number</I
></SPAN
>
              </TD
><TD
>              Specifies a relative weighting for FSM state/state transition coverage used to rank non-unique coverage 
              points.
              </TD
></TR
><TR
><TD
>              -weight-line <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>number</I
></SPAN
>
              </TD
><TD
>              Specifies a relative weighting for line coverage used to rank non-unique coverage points.
              </TD
></TR
><TR
><TD
>              -weight-memory <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>number</I
></SPAN
>
              </TD
><TD
>              Specifies a relative weighting for memory coverage used to rank non-unique coverage points.
              </TD
></TR
><TR
><TD
>              -weight-toggle <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>number</I
></SPAN
>
              </TD
><TD
>              Specifies a relative weighting for toggle coverage used to rank non-unique coverage points.
              </TD
></TR
></TBODY
></TABLE
></DIV
>
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.RANK.INPUTTING"
>Methods for specifying CDDs to rank</A
></H2
><P
>    The rank command provides several mechanisms for specifying CDD files to rank.  Feel free to use any combination
    of methods for providing this information to Covered as it makes sense to do in your environment.  The following is 
    the list of input methods:
    </P
><P
>      <P
></P
><UL
><LI
><P
>          Specify each CDD file after the rank command options have been specified.  This method is best when there are
          a relatively small number of CDD files to rank as the length of the command-line in a shell is typically
          limited to a certain number of characters.
          </P
></LI
><LI
><P
>          Create a file containing the list of CDD files to rank and pass this file to the rank command's 
          <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>-f</B
></SPAN
> option.  Using this method, one can selectively specify a large number 
          of CDD files.
          </P
></LI
><LI
><P
>          Use shell commands to create a list of CDD files and pass them to Covered's standard input via command-line 
          piping and the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>-f -</B
></SPAN
> command-line option (the - means use standard input).
          The following line is an example of this usage:
          </P
><P
>            <PRE
CLASS="PROGRAMLISTING"
>  ls foo*.cdd | covered rank -f -          
            </PRE
>
          </P
></LI
><LI
><P
>          Use the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>-d <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>directory</I
></SPAN
></B
></SPAN
> and 
          <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>-ext <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>extension</I
></SPAN
></B
></SPAN
> options to tell
          Covered to retrieve all files found in the directory specified by <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>directory</I
></SPAN
> that contain
          the file extension of <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>extension</I
></SPAN
> (if the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>-ext</B
></SPAN
> option
          is not specified, the default extension of ".cdd" is used).  The following is an example of this usage: 
          </P
><P
>            <PRE
CLASS="PROGRAMLISTING"
>  covered rank -d /home/bubba/cdd_dir -ext .mycdd          
            </PRE
>
          </P
></LI
></UL
>
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.RANK.WEIGHTING"
>Specifying metric weights</A
></H2
><P
>    The rank command has several options that allow the user to weight any and all of the coverage metrics that Covered 
    supplies.  Weights are used to ascribe the importance of its metric in ranking the value of a CDD file.
    </P
><P
>    Weight values are non-negative numbers whose values are relative to each other.  A value of 0 effectively disables 
    the associated weight from consideration in ranking.  All other values are considered relative to each other.  In
    other words, if the line weight is set to a value of 5 while the toggle weight is set to 1, line coverage is 
    considered 5 times more important than toggle coverage in ranking.
    </P
><P
>    By default, each metric is given an equal weight of 1.  Adjust each of the metrics as necessary to potentially
    modify which CDD files are chosen and what order those CDD files are given in the ranked list of diagnostics to run.
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.RANK.ALGORITHM"
>Description of ranking algorithm</A
></H2
><P
>    This section describes the overall algorithm that is used to rank the specified CDD files. The algorithm is being 
    presented in this document for the purposes of providing an explanation for how diagnostics are selected for
    ranking and how they are ranked. Knowing this information is not necessary for using the rank command or 
    understanding its results.
    </P
><P
>    The algorithm makes use of three different types of structures.  The first structure is a bit-compressed structure
    where each bit corresponds to one coverage point in the associated CDD file. The purpose of this structure is to 
    store a large amount of information as concisely and immediately available as possible. In addition to coverage
    point information, each structure also contains the following information:
    </P
><P
>      <P
></P
><UL
><LI
><P
>          Name of CDD file that the structure is associated with (for reporting purposes only).
          </P
></LI
><LI
><P
>          The number of timesteps that occurred during the CDD simulation. This is used for calculating the average 
          number of coverage points hit during a single clock period -- used for ranking selection.
          </P
></LI
><LI
><P
>          The total number of coverage points hit by the CDD. This is used for calculating the average number of 
          coverage points hit during a single clock period -- used for ranking selection.
          </P
></LI
><LI
><P
>          The total number of coverage points that were hit by this CDD that were not hit by any other CDD listed in
          the rank command-line. This information is used to figure out which CDDs are absolutely necessary to be
          included in the ranked list.
          </P
></LI
><LI
><P
>          The current score associated with the CDD file. This value is updated for each selection iteration.
          </P
></LI
></UL
>
    </P
><P
>    Each of these structures are maintained in an array that is iterated on during the ranking process.
    </P
><P
>    The second structure is an array of 16-bit values where each value corresponds to a single coverage point. Its 
    value is a sum of the number of unranked CDD files that have hit that coverage point. Each value is decremented
    by one when a CDD file is moved from the unranked list to the ranked list and that CDD file hits the given
    coverage point. If a coverage point value is a value of 1 and a CDD file has its corresponding coverage bit set,
    we know that the CDD is the only one that hits the coverage point.
    </P
><P
>    The third structure is similar to the second and works similarly, except that it stores the number of CDD files in
    the ranked list that hit a particular coverage point.
    </P
><P
>    The specified CDD files are ranked in a series of steps, some of which are reiterated for each CDD that is
    selected to be ranked. Here is the basic algorithm (in pseudo-code):
    </P
><P
>      <PRE
CLASS="PROGRAMLISTING"
>      
  calculate the size of the compressed coverage point structure
  
  foreach CDD in CDD_list {
    convert CDD to compressed coverage point structure
  }
  
  foreach CDD in CDD_list {
    if this CDD contains uniquely hit coverage points {
      move the CDD file into the ranked list
    }
  }
  
  foreach CDD in unranked list {
    foreach CDD in unranked list {
      calculate score (((total_num_cov_points_hit / num_timesteps) * 100) * metric_weight_value)
      if any unranked elements are less than the -depth option value and are hit by this CDD {
        set unique_found to true
      }
      if our score &#62; highest score and a "unique" coverage point was found {
        set highest_score to our score
      }
    }
    move the CDD file indexed by highest_score from the unranked list to the ranked list
  }
  
  resort ranked list from most unique to least unique (if there is a tie, select the CDD that hit the most coverage
    points in the least amount of time)
      </PRE
>
    </P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER.READING"
></A
>Chapter 13. Reading the Report</H1
><P
>  This chapter describes the meanings of the textual report output that Covered generates when the report command is issued. It is well understood by the 
  developers of Covered that a code coverage tool is only as good as the output that it generates, and this, of course, includes the ability to discern the 
  information provided by the report.
  </P
><P
>  To help describe the various sections of a Covered report, we will use a relatively small Verilog file containing our DUT, generating the two main types of 
  reports (module and instance) based on the CDD generated for this file. This example file is provided <A
HREF="test/example.v.html"
TARGET="_top"
>here</A
>
  </P
><P
>  After being compiled and run, this module is scored with the following Covered command:
  </P
><P
>    <FONT
COLOR="RED"
>covered score -t main -v example.v -o example.cdd -vcd example.vcd</FONT
>
  </P
><P
>  The module-based verbose report can be viewed in its entirety <A
HREF="example.rptM.html"
TARGET="_top"
>example.rptM.html</A
> and is generated with the following command:
  </P
><P
>    <FONT
COLOR="RED"
>covered report -d v example.cdd</FONT
>
  </P
><P
>  The instance-based verbose report can be viewed in its entirety <A
HREF="example.rptI.html"
TARGET="_top"
>here</A
> and is generated with the following command:
  </P
><P
>    <FONT
COLOR="RED"
>covered report -i -d v example.cdd</FONT
>
  </P
><P
>  The instructions for analyzing each of the six types of coverage information from the report can be found on the following pages.
  </P
><P
>    <P
></P
><OL
TYPE="1"
><LI
><P
><A
HREF="#SECTION.READING.LINE"
>Reading Line Coverage</A
>&#62;</P
></LI
><LI
><P
><A
HREF="#SECTION.READING.TOGGLE"
>Reading Toggle Coverage</A
>&#62;</P
></LI
><LI
><P
><A
HREF="#SECTION.READING.MEMORY"
>Reading Memory Coverage</A
>&#62;</P
></LI
><LI
><P
><A
HREF="#SECTION.READING.LOGIC"
>Reading Combinational Logic Coverage</A
>&#62;</P
></LI
><LI
><P
><A
HREF="#SECTION.READING.FSM"
>Reading FSM Coverage</A
>&#62;</P
></LI
><LI
><P
><A
HREF="#SECTION.READING.ASSERT"
>Reading Assertion Coverage</A
>&#62;</P
></LI
></OL
>
  </P
><P
>  For information on reading race condition information in the report, please see the user guide page detailing race conditions and viewing the reports.
  </P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.READING.LINE"
>Reading Line Coverage</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="SECTION.READING.LINE.SUMMARY.MOD"
>Summary Information Description - Module-based</A
></H3
><P
>      For module-based reports, the summary table for line metrics includes information for the name of each module that was covered and the name of the 
      file in which the module is described in. Lines <A
HREF="test/example.rptM.html#15"
TARGET="_top"
>15 through 24</A
> of the module-based report show what 
      this information looks like in the report. We have three modules that were scored within our DUT: main, fsma and fsmb. The table shows that all three 
      modules were described in the file "example.v".
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.READING.LINE.SUMMARY.INST"
>Summary Information Description - Instance-based</A
></H3
><P
>      For instance-based reports, the summary table for line metrics includes information for the Verilog hierarchy pertaining to each instance on the 
      left-hand-side of each row. Lines <A
HREF="test/example.rptI.html#15"
TARGET="_top"
>test/example.rptI.html#15</A
> of the instance-based report show what this information looks like 
      in the report. In our DUT example, there are three instances within the design with the Verilog hierarchies of "main", "main.fsm1" and "main.fsm2".
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.READING.LINE.SUMMARY.BOTH"
>Summary Information Description - Both</A
></H3
><P
>      On the right-hand side of each row in the table are the hit, miss and total numbers for the line coverage, followed by a calculated percent of the 
      lines that were hit (calculated by taking the number of lines hit during simulation divided by the total number of lines that Covered simulated). The 
      hit value indicates how many lines were executed during the simulation; the miss value indicates the number of lines not executed during simulation; 
      and the total value indicates the total number of lines within the specified module/instance that Covered was able to simulate.
      </P
><P
>      If the percentage value in the far left of the summary table is 100%, this indicates that all lines that Covered was capable of simulating (for the 
      module/instance of this row) were executed. If the value of the percentage is less than 100%, this indicates that some number of lines were not 
      executed and full coverage was not achieved for that module/instance. Note that for a module/instance which does not contain any lines in which 
      Covered was able to simulate, the values of hit, miss, and total will be 0 while the hit percentage value will indicate 100%.
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.READING.LINE.VERBOSE.BOTH"
>Verbose Information Description - Both</A
></H3
><P
>      If the miss value for a particular module was not 0 (indicating that lines were missed during simulation) and the '-d v' option was specified on the 
      command-line (specifying to output verbose reporting information), the line that was missed during simulation will be output below the summary 
      information per module that contained missed lines. In our sample report, there was one line that was missed during simulation (according to the 
      summary output) for the module called "fsmb" (instance "main.fsmb"). The line number and Verilog line that was missed is output in lines <A
HREF="test/example.rptM.html#25"
TARGET="_top"
>25 through 29</A
> of the module-based report and in lines 
      <A
HREF="test/example.rptI.html#25"
TARGET="_top"
>25 through 29</A
> of the instance-based report.
      </P
><P
>      If a module does not contain any missed lines and the '-d v' option was specified, no verbose output will be displayed for this module. Likewise, if 
      a module/instance does not contain any lines that Covered could execute, no verbose output will be displayed.
      </P
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>      The definition of what Covered considers a line is a statement (ex. assignment, conditional, etc.). If a statement is written in such a way that it 
      consumes multiple file lines, Covered only counts the statement as one line. The user can assume that if the beginning of a statement is labeled as 
      missed, the entire expression was missed (not just the first line of the expression). For example, consider the following code:
      </P
><P
>        <PRE
CLASS="PROGRAMLISTING"
>  always @(posedge b)
    a &#60;= (b &#38; c) |
         (d &#38; e);      
        
        </PRE
>
      </P
><P
>      If the expression
      </P
><P
>        <PRE
CLASS="PROGRAMLISTING"
>  a &#60;= (b &#38; c) | (d &#38; e);      
        </PRE
>
      </P
><P
>      is not executed during simulation, Covered will indicate that only one line was missed during execution (not two), and it will display the missing 
      line (if verbose reporting is specified with the '-d v' option) as the following:
      </P
><P
>        <PRE
CLASS="PROGRAMLISTING"
>  2:      assign a &#60;= (b &#38; c) ...      
        </PRE
>
      </P
><P
>      The "..." notation at the end of the Verilog output indicates that the statement was a multiline statement in the source code but is only considered 
      one line.
      </P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.READING.TOGGLE"
>Reading Toggle Coverage</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="SECTION.READING.TOGGLE.SUMMARY.MOD"
>Summary Information Description - Module-based</A
></H3
><P
>      For module-based reports, the summary table for toggle metrics includes information for the name of each module that was covered and the name of the 
      file in which the module is described in. Lines <A
HREF="test/example.rptM.html#41"
TARGET="_top"
>41 through 51</A
> of the module-based report show what 
      this information looks like in the report. We have three modules that were scored within our DUT: main, fsma and fsmb. The table shows that all three 
      modules were described in the file "example.v".
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.READING.TOGGLE.SUMMARY.INST"
>Summary Information Description - Instance-based</A
></H3
><P
>      For instance-based reports, the summary table for toggle metrics includes information for the Verilog hierarchy pertaining to each instance on the 
      left-hand-side of each row. Lines <A
HREF="test/example.rptI.html#41"
TARGET="_top"
>41 through 51</A
> of the instance-based report show what this 
      information looks like in the report. In our DUT example, there are three instances within the design with the Verilog hierarchies of "main", 
      "main.fsm1" and "main.fsm2".
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.READING.TOGGLE.SUMMARY.BOTH"
>Summary Information Description - Both</A
></H3
><P
>      On the right-hand side of each row in the table are the hit, miss and total numbers for the toggle 0-&#62;1 coverage, followed by a calculated percent of 
      the signal bits that toggled from a value of 0 to a value of 1 (calculated by taking the number of bits that toggled from 0 to 1 during simulation 
      divided by the total number of signal bits). The hit value indicates how many signal bits were toggle from a value of 0 to 1 during simulation; the 
      miss value indicates the number of signal bits that were not toggled from a value of 0 to 1 during simulation; and the total value indicates the 
      total number of signal bits within the specified module/instance that Covered was able to simulate.
      </P
><P
>      To the right of this information is the hit, miss and total statistics for signal bits that toggled from a value of 1 to a value of 0.
      </P
><P
>      If the percentage values in the right of the summary table are 100%, this indicates that all signal bits toggled from a value of 0 to 1 and back to 0 
      during simulating (for the module/instance of this row). If the values of the percentage are less than 100%, this indicates that some signal bits did 
      not fully toggle during simulation and full toggle coverage was not achieved for that module/instance. Note that for a module/instance which does not 
      contain any signals in which Covered was able to simulate, the values of hit, miss, and total will be 0 while the hit percentage value will indicate 
      100%.
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.READING.TOGGLE.VERBOSE.BOTH"
>Verbose Information Description - Both</A
></H3
><P
>      If the miss value for a particular module/instance was not 0 (indicating that one or more signal bits did not fully toggle during simulation) and the 
      '-d v' option was specified on the command-line (specifying to output verbose reporting information), the signals that were missed during simulation 
      will be output below the summary information per module/instance that contained missed signal bit toggles. In our sample module-based report, there 
      were three signals in module "main" ("go", "state", and "error"), three signals in module "fsma" ("go", "state" and "next_state"), and three signals 
      in module "fsmb" ("go", "next_state" and "state") that were not fully toggled (see lines 
      <A
HREF="test/example.rptM.html#53"
TARGET="_top"
>53 through 90</A
>).
      </P
><P
>      For each signal in the verbose toggle table, the format is the following:
      </P
><P
>        <PRE
CLASS="PROGRAMLISTING"
>        &#60;signal_name&#62;          0-&#62;1: &#60;hexidecimal_value&#62;
        .......................1-&#62;0: &#60;hexidecimal_value&#62;
        
        </PRE
>
      </P
><P
>      The name of the signal is specified in the upper left corner. The bitwise toggle information for the signal from a value of 0 to a value of 1 is specified in the 
      upper right corner. The hexidecimal value represents bits in the signal, each bit corresponding to the matching bit of the signal. If a bit value is set to the 
      value 1, this indicates that this bit in the signal toggled from a value of 0 to a value of 1. If a bit value is set to the value 0, this indicates that this bit 
      in the signal did NOT toggle from a value of 0 to a value of 1; therefore, full toggle coverage was not achieved for this signal. For example, for the signal 
      called "go" in the module/instance "main", the verbose toggle information looks like:
      </P
><P
>        <PRE
CLASS="PROGRAMLISTING"
>  go         0-&#62;1: 1'b1
  ...........1-&#62;0: 1'b0      
        </PRE
>
      </P
><P
>      This is indicating that bit 0 of the signal called "go" successfully toggled from a value of 0 to 1 during simulation (because the bit value at bit location 0 is 
      a value of 1). However, the signal did not toggle from a value of 1 to a value of 0 during simulation, thus the signal was not considered fully toggled.
      </P
><P
>      It is important to note that the hexidecimal values are displayed with the least-significant bit of the signal being output on the far right of the value while 
      the most-significant bit of the signal is output on the far left of the value.
      </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.READING.MEMORY"
>Reading Memory Coverage</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="SECTION.READING.MEMORY.SUMMARY.MOD"
>Summary Information Description - Module-based</A
></H3
><P
>      For module-based reports, the summary table for memory metrics includes information for the name of each module, instantiating one or more memories, that was 
      analyzed and the name of the file in which the module is described in. Lines <A
HREF="test/example.rptM.html#93"
TARGET="_top"
>93 through 111</A
> of the module-based 
      report show what this information looks like in the report. We have three modules that were scored within our DUT: main, fsma and fsmb. The table shows that all 
      three modules were described in the file "example.v".
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.READING.MEMORY.SUMMARY.INST"
>Summary Information Description - Instance-based</A
></H3
><P
>      For instance-based reports, the summary table for memory metrics includes information for the Verilog hierarchy pertaining to each instance on the left-hand-side 
      of each row. Lines <A
HREF="test/example.rptI.html#93"
TARGET="_top"
>93 through 111</A
> of the instance-based report show what this information looks like in the report. 
      In our DUT example, there are three instances within the design with the Verilog hierarchies of "main", "main.fsm1" and "main.fsm2".
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.READING.MEMORY.SUMMARY.BOTH"
>Summary Information Description - Both</A
></H3
><P
>      On the right-hand side of each row in the table are the hit, miss and total numbers for the various memory coverage metrics, followed by a calculated percent of 
      each memory coverage metric that was hit (calculated by taking the number hit during simulation divided by the total number that Covered could have simulated). 
      The hit value indicates how many were executed during the simulation; the miss value indicates the number not executed during simulation; and the total value 
      indicates the total number within the specified module/instance that Covered can simulate. All four metrics (AME toggle 0-&#62;1, AME toggle 1-&#62;0, AME write and AME 
      read) are listed in the summary section.
      </P
><P
>      If the percentage value in the far left of the summary table is 100%, this indicates that all coverage points that Covered was capable of simulating (for the 
      module/instance of this row) were executed. If the value of the percentage is less than 100%, this indicates that some number of coverage points were not executed 
      and full coverage was not achieved for that module/instance. Note that for a module/instance which does not contain any coverage points in which Covered was able 
      to simulate, the values of hit, miss, and total will be 0 while the hit percentage value will indicate 100%.
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.READING.MEMORY.VERBOSE.BOTH"
>Verbose Information Description - Both</A
></H3
><P
>      When a module/instance is found to be not fully covered (i.e., the number of each hit coverage points is not equal to the associated number of attainable coverage 
      points), the missed coverage points for each AME in the memory are output to the report as follows:
      </P
><P
>        <PRE
CLASS="PROGRAMLISTING"
>  &#60;AME&#62;  Written: &#60;0 or 1&#62;  0-&#62;1: &#60;hexidecimal_value&#62;
  .....  Read:    &#60;0 or 1&#62;  1-&#62;0: &#60;hexidecimal_value&#62; ...      
        </PRE
>
      </P
><P
>      The answers to each of the questions listed above are specified with a 0 (meaning that the answer is "NO") or a 1 (meaning that the answer is "YES"). Note that in 
      the toggle coverage information, like toggle coverage verbose information, the individual bits are grouped together and displayed in hexidecimal form to conserve 
      space and make the task of figuring out exactly which bit positions did not toggle easier. See lines 
      <A
HREF="test/example.rptM.html#117"
TARGET="_top"
>117 through 151</A
> for an example of this output.
      </P
><P
>      If the -c option is used, Covered outputs the names of the memories that were fully covered during simulation only.
      </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.READING.LOGIC"
>Reading Combinational Logic Coverage</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="SECTION.READING.LOGIC.SUMMARY.MOD"
>Summary Information Description - Module-based</A
></H3
><P
>      For module-based reports, the summary table for combinational logic metrics includes information for the name of each module that was covered and the name of the 
      file in which the module is described in. Lines <A
HREF="test/example.rptM.html#154"
TARGET="_top"
>154 through 164</A
> of the module-based report show what this 
      information looks like in the report. We have three modules that were scored within our DUT: main, fsma, and fsmb. The table shows that all three modules were 
      described in the file "example.v".
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.READING.LOGIC.SUMMARY.INST"
>Summary Information Description - Instance-based</A
></H3
><P
>      For instance-based reports, the summary table for combinational logic metrics includes information for the Verilog hierarchy pertaining to each instance on the 
      left-hand-side of each row. Lines <A
HREF="test/example.rptI.html#154"
TARGET="_top"
>154 through 164</A
> of the instance-based report show what this information looks 
      like in the report. In our DUT example, there are three instances within the design with the Verilog hierarchies of "main", "main.fsm1", and "main.fsm2".
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.READING.LOGIC.SUMMARY.BOTH"
>Summary Information Description - Both</A
></H3
><P
>      On the right-hand side of each row in the table are the hit, miss and total numbers for the combinational logic coverage, followed by a calculated percent of the 
      combinational logic expression values that were hit (calculated by taking the number of combinational logic expression values hit during simulation divided by the 
      total number of expression values that Covered could have simulated). The hit value indicates how many expression values were achieved during the simulation; the 
      miss value indicates the number of expression values not achieved during simulation; and the total value indicates the total number of combinational logic 
      expression values that could have been achieved in the specified module/instance.
      </P
><P
>      If the percentage value in the far left of the summary table is 100%, this indicates that all combinational logic expression values that Covered was capable of 
      achieving (for the module/instance of this row) were hit. If the value of the percentage is less than 100%, this indicates that some number of expression values 
      were not achieved and full coverage was not achieved for that module/instance. Note that for a module/instance which does not contain any combinational logic 
      expressions in which Covered was able to simulate, the values of hit, miss, and total will be 0 while the hit percentage value will indicate 100%.
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.READING.LOGIC.VERBOSE.BOTH"
>Verbose Information Description - Both</A
></H3
><P
>      The verbose output for combinational coverage is a bit more sophisticated than the line or toggle. Basically, for each expression that was found to not be fully 
      covered (either the expression itself or some sub-expression in the tree was not fully covered), the expression is output with various sub-expressions underlined 
      and identified with a number. Each expression is also supplied with the line number that the expression started at in its module file. In our example, there is an 
      uncovered expression in the module called "main" (see lines <A
HREF="test/example.rptM.html#170"
TARGET="_top"
>170 through 205</A
> (numbered 5) which contains four 
      uncovered subexpressions (numbered 1 through 4).
      </P
><P
>      Below each expression, there will be one or more tables which specify a particular sub-expression that was not fully covered along with information describing 
      what cases were not covered for that sub-expression.
      </P
><P
>      In the report output above, we see that there was one expression in module "main" that did not achieve 100% coverage that starts on line 14 of the Verilog source. 
      The expression is output to the report with certain sub-expressions underlined and labeled with an integer value for reference.
      </P
><P
>      For this one expression, there were found to be four subexpressions (labeled 1, 2, 3, 4) that were found to not be 100% covered. Taking a look at subexpression 1 
      report output, the numbers to the right of the string "Expression 1" tell us the number of logical combinations of this subexpression that were hit (in this case 
      2 combinations were hit) and the total number of logical combinations that this subexpression can have (in this case 3 combinations were achievable). The 
      character string below this information tells us the type of subexpression that we are examining. For subexpression 1, the type is the bitwise AND operator.
      </P
><P
>      The table below this information for subexpression 1, lists the potential combinations that this subexpression could have reached with a '*' character placed 
      underneath the combination(s) that were missed. In the case of subexpression 1, the left and right subexpressions did not evaluate to values of 1 simultaneously 
      The letter 'L' above each possible combination indicates the value that the left subexpression achieved at the same time as the value under the right 
      subexpression indicated with the letter 'R'. Legal values for a subexpression are '0', '1' or '-' (which indicates that this subexpression value could either be 0 
      or 1).
      </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.READING.FSM"
>Reading FSM Coverage</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="SECTION.READING.FSM.SUMMARY.MOD"
>Summary Information Description - Module-based</A
></H3
><P
>      For module-based reports, the summary table for FSM metrics includes information for the name of each module that was covered and the name of the file in which 
      the module is described in. Lines <A
HREF="test/example.rptM.html#344"
TARGET="_top"
>344 through 354</A
> of the module-based report show what this information looks like 
      in the report. We have three modules that were scored within our DUT: main, fsma and fsmb. The table shows that all three modules were described in the file 
      "example.v".
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.READING.FSM.SUMMARY.INST"
>Summary Information Description - Instance-based</A
></H3
><P
>      For instance-based reports, the summary table for FSM metrics includes information for the Verilog hierarchy pertaining to each instance on the left-hand-side of 
      each row. Lines <A
HREF="test/example.rptI.html#344"
TARGET="_top"
>344 through 354</A
> of the instance-based report show what this information looks like in the report. 
      In our DUT example, there are three instances within the design with the Verilog hierarchies of "main", "main.fsm1" and "main.fsm2".
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.READING.FSM.SUMMARY.BOTH"
>Summary Information Description - Both</A
></H3
><P
>      On the right-hand side of each row in the table are the hit, miss and total numbers for the FSM state coverage, followed by a calculated percent of the FSM states 
      that were hit (calculated by taking the number of FSM states hit during simulation divided by the total number of FSM states that Covered could have simulated). 
      The hit value indicates how many FSM states were executed during the simulation; the miss value indicates the number of FSM states not executed during simulation; 
      and the total value indicates the total number of FSM states within the specified module/instance that Covered can simulate.
      </P
><P
>      To the right of the FSM state summary information is the FSM state-transition hit, miss, total and percentage hit summary information for each module/instance.
      </P
><P
>      If the percentage value in the far left of the summary table is 100%, this indicates that all FSM states and state-transitions that Covered was capable of 
      simulating (for the module/instance of this row) were executed. If the value of the percentage is less than 100%, this indicates that some number of FSM states 
      and/or FSM state-transitions were not executed and full coverage was not achieved for that module/instance. Note that for a module/instance which does not contain 
      any FSMs in which Covered was able to simulate, the values of hit, miss, and total will be 0 while the hit percentage value will indicate 100%.
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.READING.VERBOSE.BOTH"
>Verbose Information Description - Both</A
></H3
><P
>      The verbose output for FSM coverage is split into the state coverage information and the state transition coverage information. When an FSM is found to be not 
      fully covered (i.e., the number of hit states/state transitions is not equal to the number of attainable states/state transitions), the missed states are output 
      to the report as a list of state values in hexidecimal format as follows:
      </P
><P
>        <PRE
CLASS="PROGRAMLISTING"
>  &#60;hexidecimal value&#62;
        </PRE
>
      </P
><P
>      When an FSM is found to be not fully covered, the missed state transitions are output to the report as a list of state transitions in the format below:
      </P
><P
>        <PRE
CLASS="PROGRAMLISTING"
>  &#60;hexidecimal input state value&#62; -&#62; &#60;hexidecimal output state value&#62;
        </PRE
>
      </P
><P
>      If the -c option is used or the number of attainable state/state transitions are unknown for the specified FSM, Covered outputs this information in the same way 
      as the missed cases except that the title of the output is "Hit cases". If the number of attainable states/state transitions is unknown, providing the cases that 
      were hit during simulation is useful in aiding the user in determining coverage. In this case, the summary report will output question marks in the missed and 
      total categories, showing the user that this information was not known by Covered.
      </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.READING.ASSERT"
>Reading Assertion Coverage</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="SECTION.READING.ASSERT.SUMMARY.MOD"
>Summary Information Description - Module-based</A
></H3
><P
>      For module-based reports, the summary table for assertion metrics includes information for the name of each module, instantiating one or more assertions, that was 
      covered and the name of the file in which the module is described in. Lines <A
HREF="test/example.rptM.html#397"
TARGET="_top"
>397 through 405</A
> of the module-based 
      report show what this information looks like in the report. We have three modules that were scored within our DUT: main, fsma and fsmb. The table shows that all 
      three modules were described in the file "example.v".
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.READING.ASSERT.SUMMARY.INST"
>Summary Information Description - Instance-based</A
></H3
><P
>      For instance-based reports, the summary table for assertion metrics includes information for the Verilog hierarchy pertaining to each instance on the left-hand-
      side of each row. Lines <A
HREF="test/example.rptI.html#397"
TARGET="_top"
>397 through 405</A
> of the instance-based report show what this information looks like in the 
      report. In our DUT example, there are three instances within the design with the Verilog hierarchies of "main", "main.fsm1" and "main.fsm2".
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.READING.ASSERT.SUMMARY.BOTH"
>Summary Information Description - Both</A
></H3
><P
>      On the right-hand side of each row in the table are the hit, miss and total numbers for the assertion coverage points (ACP), followed by a calculated percent of 
      the ACPs that were hit (calculated by taking the number of ACPs hit during simulation divided by the total number of ACPs that Covered could have simulated). The 
      hit value indicates how many ACPs were executed during the simulation; the miss value indicates the number of ACPs not executed during simulation; and the total 
      value indicates the total number of ACPs within the specified module/instance that Covered can simulate. Note that more than one coverage point may exist within a 
      single assertion coverage module.
      </P
><P
>      If the percentage value in the far left of the summary table is 100%, this indicates that all ACPs that Covered was capable of simulating (for the module/instance 
      of this row) were executed. If the value of the percentage is less than 100%, this indicates that some number of ACPs were not executed and full coverage was not 
      achieved for that module/instance. Note that for a module/instance which does not contain any ACPs in which Covered was able to simulate, the values of hit, miss, 
      and total will be 0 while the hit percentage value will indicate 100%.
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.READING.ASSERT.VERBOSE.BOTH"
>Verbose Information Description - Both</A
></H3
><P
>      When a module/instance is found to be not fully covered (i.e., the number of hit ACPs is not equal to the number of attainable ACPs), the missed coverage points 
      are output to the report as follows:
      </P
><P
>        <PRE
CLASS="PROGRAMLISTING"
>  &#60;Instance Name&#62;	&#60;Assertion Name&#62;	&#60;Coverage Point Description&#62;
        </PRE
>
      </P
><P
>      If the -c option is used, Covered outputs this information in the same way as the missed cases except that the title of the output is "Hit cases" and the number 
      of times each ACP was hit is indicated.
      </P
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER.DEBUG"
></A
>Chapter 14. Debugging</H1
><P
>  As much as it pains the developers of Covered to admit, there will be times when a user of Covered will encounter a 
  problem in the resimulation process or will experience a performance issue during certain runs and will want to 
  investigate the issue a bit themselves before posting a bug report. There may also be people out there who just 
  might want to learn more about how Covered operates "under the hood". For those people whom I have just mentioned, 
  this section is for you.
  </P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.DEBUG.OUTPUT"
>Verbose Debug Output</A
></H2
><P
>    The brute force method of understanding Covered's internals is to generate verbose debug output using the global "-D" 
    option to any of Covered's commands. The user of this method should take care to note that using this option may 
    generate an <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>extremely</I
></SPAN
> large amount of output and will definitely cause Covered's runtime performance 
    to degrade considerably. If this option is used, its output should probably be redirected to a file for 
    post-processing purposes. It should be noted that the verbose debug output is most useful for the developer's of 
    Covered and is not meant to be of much help to the normal user.
    </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1501"
>Building Covered for Verbose Debug Outputting</A
></H3
><P
>      Because generating verbose debug output can have a tremendous degradation in performance when it is even compiled, 
      Covered requires the user to specify an option to the configuration/build process to enable this feature. To enable 
      verbose debug outputting, simply specify the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>--enable-debug</B
></SPAN
> option to the configure 
      script. This will cause Covered to compile in verbose debug output support and enable the use of the -D global option.
      </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>        If the user has not specified the --enable-debug option to the configuration script but proceeds to specify the -D global option, 
        Covered will emit a warning message that it is unable to output verbose debug information due to the lack of the --enable-debug 
        option being specified. It will then proceed to ignore the -D option.
        </P
></BLOCKQUOTE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.CLI"
>Command-Line Interface (CLI)</A
></H2
><P
>    As an alternative to simply outputting the verbose debug output from Covered, the score command comes equipped with its own 
    interactive debugging mechanism called the CLI (Command-Line Interface). This interface is a command-line driven utility that 
    starts at the beginning of the resimulation. Its purpose is to allow the user to step through simulation execution and view 
    the contents of signals, time, scopes, code and internal thread queues for the purposes of debugging and/or understanding 
    Covered. This utility works much in the same way as simulator CLIs and the GDB debugging utility.
    </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1510"
>Building Covered for the CLI</A
></H3
><P
>      Because interactive command-line debugging has a small performance penalty when compiled in and is closely associated with 
      the verbose debug output option, Covered requires the user to specify an option to the configuation/build process to enable 
      this feature. To enable the CLI, simply specify the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>--enable-debug</B
></SPAN
> option to the configure 
      script. This will cause Covered to compile in CLI capabilities and enable the user of the -cli score command option.
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1514"
>Using the CLI</A
></H3
><P
>      To allow the score command to use the CLI for interactive resimulation, simply specify the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>-cli 
      [<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>filename</I
></SPAN
>]</B
></SPAN
> option to the score command. If filename is specified to this option, the contents 
      of this file will be parsed and executed once the score command has reached the resimulation process. The contents of this 
      file are a series of CLI commands (one command per line) in ASCII format and can be automatically produced with the "savehist" 
      CLI command (see below). This feature allows a user to quickly save off the CLI commands made during one score run and reuse 
      them in a subsequent score run without having to remember and manually input the same commands.
      </P
><P
>      Once the -cli option is invoked, Covered will run the score command until it gets to the beginning of the resimulation process. 
      At this time, if the optional filename is specified, it will parse the contents of this file and execute the CLI commands found 
      there until all commands are executed. If filename was not specified, a prompt will be displayed and the resimulation execution 
      will halt until the user has specified otherwise via command-line options. After entering a command-line option, simply press 
      return to invoke that command. In the event that the command was a step, next or continue option, resimulation will resume 
      until it reaches the next stop point.
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1520"
>CLI commands</A
></H3
><P
>      The following is a list of all of the CLI options available to the user:
      </P
><DIV
CLASS="TABLE"
><A
NAME="AEN1523"
></A
><P
><B
>Table 14-1. CLI Command-line Options</B
></P
><TABLE
BORDER="1"
FRAME="border"
RULES="all"
CLASS="CALSTABLE"
><COL
WIDTH="1*"><COL
WIDTH="2*"><THEAD
><TR
><TH
>Option</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
>              step [<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>num</I
></SPAN
>]
              </TD
><TD
>              Advances to the next statement if <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>num</I
></SPAN
> is not specified; otherwise, advances <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>num</I
></SPAN
> 
              statements before returning to the CLI prompt.
              </TD
></TR
><TR
><TD
>              next [<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>num</I
></SPAN
>]
              </TD
><TD
>              Advances to the next timestep if <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>num</I
></SPAN
> is not specified; otherwise, advances <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>num</I
></SPAN
> 
              timesteps before returning to the CLI prompt.
              </TD
></TR
><TR
><TD
>              goto <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>num</I
></SPAN
>
              </TD
><TD
>              Advances to the given timestep (or the next timestep after the given value if the timestep is not executed) specified by 
              <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>num</I
></SPAN
>.
              </TD
></TR
><TR
><TD
>              run
              </TD
><TD
>              Runs the simulation to completion.
              </TD
></TR
><TR
><TD
>              continue
              </TD
><TD
>              Continues running the simulation to completion.
              </TD
></TR
><TR
><TD
>              thread active
              </TD
><TD
>              Displays the current state of the internal active simulation queue. This queue consists of process threads that will be executed 
              in the current timestep.
              </TD
></TR
><TR
><TD
>              thread delayed
              </TD
><TD
>              Displays the current state of the internal delayed simulation queue. This queue consists of process threads that will be executed 
              at a later time as dictated by a delay statement.
              </TD
></TR
><TR
><TD
>              thread waiting
              </TD
><TD
>              Displays the current state of the internal waiting simulation queue. This queue consists of process threads that are not active 
              or delayed but may be activated by a value change in one of the signals in its expression tree.
              </TD
></TR
><TR
><TD
>              thread all
              </TD
><TD
>              Displays the current state of all process threads in the simulator.
              </TD
></TR
><TR
><TD
>              current
              </TD
><TD
>              Displays the current scope, block, filename and line number of the statement that is about to be executed in the active queue.
              </TD
></TR
><TR
><TD
>              time
              </TD
><TD
>              Displays the current simulation time.
              </TD
></TR
><TR
><TD
>              signal <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>name</I
></SPAN
>
              </TD
><TD
>              Displays the current value of the given net/variable.
              </TD
></TR
><TR
><TD
>              expr <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>num</I
></SPAN
>
              </TD
><TD
>              Displays the given expression and its current value where <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>num</I
></SPAN
> is the ID of the expression to output.
              </TD
></TR
><TR
><TD
>              debug [on | off]
              </TD
><TD
>              Turns verbose debug output from the simulator on or off. If 'on' or 'off' is not specified, displays the current debug mode.
              </TD
></TR
><TR
><TD
>              list [<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>num</I
></SPAN
>]
              </TD
><TD
>              Lists the contents of the file where the current statement is to be executed. If <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>num</I
></SPAN
> is specified, 
              outputs the given number of lines; otherwise, outputs 10 lines.
              </TD
></TR
><TR
><TD
>              savehist <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>filename</I
></SPAN
>
              </TD
><TD
>              Saves the current history to the specified file.
              </TD
></TR
><TR
><TD
>              history [(<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>num</I
></SPAN
> | all)]
              </TD
><TD
>              Displays the last 10 lines of command-line history. If 'all' is specified, the entire history contents will be displayed. 
              If <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>num</I
></SPAN
> is specified, the last <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>num</I
></SPAN
> commands will be displayed.
              </TD
></TR
><TR
><TD
>              !<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>num</I
></SPAN
>
              </TD
><TD
>              Executes the command at the <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>num</I
></SPAN
> position in history.
              </TD
></TR
><TR
><TD
>              !!
              </TD
><TD
>              Executes the last valid command.
              </TD
></TR
><TR
><TD
>              help
              </TD
><TD
>              Displays the available command-line options.
              </TD
></TR
><TR
><TD
>              quit
              </TD
><TD
>              Ends simulation immediately.
              </TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.PROFILING"
>Source Code Profiling</A
></H2
><P
>    The built-in source code profiling facility allows the user to run any Covered command and understand performance metrics 
    about the internal Covered source code, such as how many times a given function was called, how much wall-clock time was 
    spent executing a given function, how many times a function allocated and deallocated memory from the heap, etc. This 
    information can be useful in understanding where performance bottlenecks are during a given Covered command run. This 
    feature does not provide the end-user any useful information about the design that they are testing.
    </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1618"
>Building Covered for Profiling</A
></H3
><P
>      Because internal source code profiling is not a function of obtaining Verilog code coverage and adds a performance 
      penalty for being compiled in and used, Covered requires the user to specify an option to the configuration/build 
      process to enable this feature. To enable internal source code profiling, simply specify the 
      <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>--enable-profiling</B
></SPAN
> option to the configure script. This will cause Covered to 
      compile in profiling capabilities and enable the use of the -P global option.
      </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>        If the user has not specified the --enable-profiling option to the configuration script but proceeds to specify the -P global option, Covered will emit a 
        warning message that it is unable to do profiling due to the lack of the --enable-profiling option being specified. It will then proceed to ignore the -P 
        option.
        </P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1624"
>Using Source Code Profiling</A
></H3
><P
>      Once Covered has had profiling functionality configured and built into it, the user may optionally enable profiling for any 
      command by specifying the -P [<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>filename</I
></SPAN
>] global option. If the -P option is specified without a filename 
      associated with it, the profiling report generated from the command run will be output to a file called "covered.prof" in the 
      same directory where Covered was run. If a filename is associated with the -P option, the contents of the profiling report 
      will be output to that file.
      </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>        The specified filename can be anything except "score", "merge" or "report" as this name will be interpreted by Covered's command-line parser to indicate the 
        type of command being run. If one of these command keywords are specified after the -P option, it is assumed that the user has not specified a filename and the 
        contents of the profiling report will be sent to the default file of "covered.prof".
        </P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1630"
>Understanding the Profiling Report</A
></H3
><P
>      After a command has been run with the global -P option specified, a report file will contain several profiling statistics, 
      including the following:
      </P
><P
>        <P
></P
><OL
TYPE="1"
><LI
><P
>The amount of time spent running the entire command</P
></LI
><LI
><P
>The number of times each executed function was called</P
></LI
><LI
><P
>The total amount of wall clock time spent executing each function</P
></LI
><LI
><P
>The average amount of time spent executing each function</P
></LI
><LI
><P
>The number of times each function allocated heap memory</P
></LI
><LI
><P
>The number of times each function deallocated heap memory</P
></LI
></OL
>
      </P
><P
>      In addition to providing this information on a per function basis, the profiling report also provides the information 
      in three different sections with each function ordered from most to least by the following statistic columns:
      </P
><P
>        <P
></P
><OL
TYPE="1"
><LI
><P
>The number of times each executed function was called</P
></LI
><LI
><P
>The total amount of wall clock time spent executing each function</P
></LI
><LI
><P
>The average amount of time spent executing each function</P
></LI
></OL
>
      </P
><P
>      By ordering this information, it will help the users and developers determine where the performance bottlenecks in execution 
      are for a given command run.
      </P
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="PART"
><A
NAME="AEN1657"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
>IV. Graphical User Interface</H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>15. <A
HREF="#CHAPTER.GUI.INTRO"
>Introduction to the GUI</A
></DT
><DT
>16. <A
HREF="#CHAPTER.GUI.MAIN"
>Navigating the Main Window</A
></DT
><DT
>17. <A
HREF="#CHAPTER.GUI.LINE"
>Navigating the Line Coverage Window</A
></DT
><DT
>18. <A
HREF="#CHAPTER.GUI.TOGGLE"
>Navigating the Toggle Coverage Window</A
></DT
><DT
>19. <A
HREF="#CHAPTER.GUI.MEMORY"
>Navigating the Memory Coverage Window</A
></DT
><DT
>20. <A
HREF="#CHAPTER.GUI.LOGIC"
>Navigating the Combinational Logic Window</A
></DT
><DT
>21. <A
HREF="#CHAPTER.GUI.FSM"
>Navigating the FSM State/State Transition Coverage Window</A
></DT
><DT
>22. <A
HREF="#CHAPTER.GUI.ASSERT"
>Navigating the Assertion Coverage Window</A
></DT
><DT
>23. <A
HREF="#CHAPTER.GUI.ASSERT.SOURCE"
>Navigating the Assertion Source Code Window</A
></DT
><DT
>24. <A
HREF="#CHAPTER.GUI.GENREPORT"
>Navigating the ASCII Report Generator Window</A
></DT
><DT
>25. <A
HREF="#CHAPTER.GUI.PREFERENCES"
>Navigating the Preferences Window</A
></DT
><DT
>26. <A
HREF="#CHAPTER.GUI.WIZARD"
>Navigating the Wizard Window</A
></DT
><DT
>27. <A
HREF="#CHAPTER.GUI.NEW"
>Creating a New CDD</A
></DT
></DL
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER.GUI.INTRO"
></A
>Chapter 15. Introduction to the GUI</H1
><P
>  The Covered report viewer GUI allows a user to view the coverage results from one or more CDD (Covered Design Database) files that have been previously 
  generated using the Covered score and/or merge commands.  The advantages of using the GUI versus using an ASCII file to view coverage results are the 
  following:
  </P
><P
>    <P
></P
><OL
TYPE="1"
><LI
><P
>        View code that is covered/uncovered within the actual source file text (more context)
        </P
></LI
><LI
><P
>        Quickly see which modules/instances were uncovered for each coverage metric.
        </P
></LI
><LI
><P
>        Ability to hide/unhide verbose information for uncovered code.
        </P
></LI
><LI
><P
>        Quickly find expressions that caused combinational logic cases to be uncovered.
        </P
></LI
><LI
><P
>        Allows user to focus on a particular expression/signal/module/instance that is uncovered.
        </P
></LI
><LI
><P
>        Non-useful coverage cases can be interactively excluded/included and summary information automatically recalculated.
        </P
></LI
></OL
>
  </P
><P
>  Because the nature of a GUI interface is much more interactive than a generated text file report, the Covered report viewer is meant to provide the user a 
  more in-depth look at the logic to identify the reasons for not achieving full coverage.  This is the ultimate goal of the GUI interface -- to be an 
  interactive tool for identifying and understanding why full code coverage was not achieved and how to write tests that will cover those areas.
  </P
><P
>  The GUI report viewer is invoked by specifying the '-view' option to the Covered report command.  The report viewer is part of the report command and is, 
  therefore, not used to parse/score a design.  However, merging maytake place with the GUI as multiple CDD files may be read, merged (assumingall of the CDD 
  files came from the same DUT) and saved in CDD file format.
  </P
><P
>  The rest of the user manual pages describe the various widgets and windows of the GUI and their functionality.  Additionally, this user manual contains 
  information on how to get the most out of the Covered GUI report viewer.
  </P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER.GUI.MAIN"
></A
>Chapter 16. Navigating the Main Window</H1
><P
>  <A
HREF="#FIGURE.GUI.MAIN.WINDOW"
>Covered Main Window</A
> shows the main window prior to a CDD file being loaded.  There are six main 
  components of the main window.  These components are the following (from top to bottom, left to right):
  </P
><P
>    <P
></P
><OL
TYPE="1"
><LI
><P
><A
HREF="#SECTION.GUI.MAIN.MENUBAR"
>The Main Menu Bar</A
></P
></LI
><LI
><P
><A
HREF="#SECTION.GUI.MAIN.COVBAR"
>The Coverage Type View Bar</A
></P
></LI
><LI
><P
><A
HREF="#SECTION.GUI.MAIN.SUMCOV"
>The Summary Coverage Bar</A
></P
></LI
><LI
><P
><A
HREF="#SECTION.GUI.MAIN.LISTBOX"
>Module/Instance Listbox</A
></P
></LI
><LI
><P
><A
HREF="#SECTION.GUI.MAIN.VIEWER"
>Coverage File Viewer</A
></P
></LI
><LI
><P
><A
HREF="#SECTION.GUI.MAIN.INFOBAR"
>The Information Bar</A
></P
></LI
></OL
>
  </P
><P
>    <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.MAIN.WINDOW"
></A
><P
><B
>Figure 16-1. Covered Main Window</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/main_window.gif"></P
></DIV
></DIV
>
  </P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.GUI.MAIN.MENUBAR"
>The Main Menu Bar</A
></H2
><P
>    The Main Menu Bar consists of four menus at the top of the main window.  <A
HREF="#FIGURE.GUI.MAIN.MENUBAR"
>Covered Main Window Highlighting the Menu Bar</A
> below shows the menu bar portion of the GUI 
    bordered in red.  These menus are the following:
    </P
><P
>      <P
></P
><OL
TYPE="1"
><LI
><P
>            <A
HREF="#SECTION.GUI.MAIN.FILEMENU"
>File</A
> - Creates, opens, merges, saves and closes CDD files, generates 
            reports, and exits the application.
          </P
></LI
><LI
><P
>            <A
HREF="#SECTION.GUI.MAIN.REPORTMENU"
>Report</A
> - Specifies what type of report to show.
          </P
></LI
><LI
><P
>            <A
HREF="#SECTION.GUI.MAIN.VIEWMENU"
>The View Menu</A
> - Provides additional viewing options.
          </P
></LI
><LI
><P
>            <A
HREF="#SECTION.GUI.MAIN.HELPMENU"
>The Help Menu</A
> - Provides access to online help manual and tool information.
          </P
></LI
></OL
>
    </P
><P
>      <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.MAIN.MENUBAR"
></A
><P
><B
>Figure 16-2. Covered Main Window Highlighting the Menu Bar</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/main_menu.gif"></P
></DIV
></DIV
>
    </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>      On Mac OS X, the main menubar does not exist in the application window.  Like most Mac OS X
      applications, the main menubar exists at the top of the display.
      </P
></BLOCKQUOTE
></DIV
><P
>      
    </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.GUI.MAIN.FILEMENU"
>The File Menu</A
></H3
><P
>      The file menu is used to open a new CDD file, merge a related CDD file (derived from the same design as the 
      currently opened CDD file, save the currently opened CDD file(s), close all opened CDD files, generate different 
      types of output and view the names of all currently opened CDD files.  Additionally, the user selects this menu 
      bar to exit the Covered report viewer GUI.  <A
HREF="#FIGURE.GUI.MAIN.FILEMENU"
>The File Menu</A
> shows the file menu 
      contents within the main window.
      </P
><P
>        <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.MAIN.FILEMENU"
></A
><P
><B
>Figure 16-3. The File Menu</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/file_menu.gif"></P
></DIV
></DIV
>
      </P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1746"
>Open/Merge CDDs...</A
></H4
><P
>        This menu option is used to either open a new CDD file or merge a related CDD file into the currently opened 
        CDD file(s).  This action needs to be performed before any coverage viewing can take place.  When this option 
        is selected, a standard file window is displayed allowing the user to select one (or possibly more depending on 
        your version of Tcl/Tk) CDD file to open or merge (see <A
HREF="#SECTION.GUI.MAIN.FILE.OPENMERGE"
>The Open/Merge CDD Selection Window</A
>&#62;).  To 
        select more than one CDD file with one call to this option, simply press and hold the Control key while 
        selecting files with the left mouse button.  If your version of Tcl/Tk supports this feature, you will see 
        multiple files highlighted for selection; otherwise, only the last selected file will be selected.  If no CDD 
        files currently are opened, any CDD file may be opened.  If one or more CDD files have been opened/merged, only 
        CDD files generated from the same design may be merged.
        </P
><P
>        Note that this option has an accelerator keystroke &lt;Control-o&gt;.  Hitting this keystroke combination will 
        also open new CDD file(s).
        </P
><P
>          <DIV
CLASS="FIGURE"
><A
NAME="SECTION.GUI.MAIN.FILE.OPENMERGE"
></A
><P
><B
>Figure 16-4. The Open/Merge CDD Selection Window</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/open_cdd.gif"></P
></DIV
></DIV
>
        </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1757"
>View Loaded CDD(s)...</A
></H4
><P
>        This menu option is only available after an initial CDD file has been opened using the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Open/Merge 
        CDDs...</B
></SPAN
> file menu option.  When this menu option is selected, a new window displaying all currently opened CDD files 
        is displayed (see <A
HREF="#SECTION.GUI.MAIN.FILE.VIEWER"
>The CDD Opened File Viewer</A
>&#62; below).  If another CDD file is merged and this window is 
        currently displayed, it is automatically updated with the newly added file.  If the 
        <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Close CDDs...</B
></SPAN
> file menu option is selected while this window is opened, all filenames will be 
        automatically removed to indicate this.  The <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>View Loaded CDD(s)...</B
></SPAN
> menu option is useful for 
        helping the user see exactly which files have been merged or not merged in the current viewer.  Simply click on the 
        <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Close</B
></SPAN
> button in the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Loaded CDD file viewer</B
></SPAN
> window to close the 
        window.
        </P
><P
>          <DIV
CLASS="FIGURE"
><A
NAME="SECTION.GUI.MAIN.FILE.VIEWER"
></A
><P
><B
>Figure 16-5. The CDD Opened File Viewer</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/file_viewer.gif"></P
></DIV
></DIV
>
        </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1772"
>Save CDD...</A
></H4
><P
>        This menu option is only available after one or more CDD files have been opened/merged.  It is used to save the opened or merged 
        CDD files as a single, merged CDD file than can be viewed as a separate CDD file or can be merged with other CDD files.  It is 
        also used to save any changes that the user has made to exclude/include coverage cases within the GUI.  If you would like to 
        retain this information, please save the CDD file.  By default, the name of the first loaded CDD file is placed in the "Save As" 
        window when this option is selected. The user may choose to replace the old CDD file with the new one, or the user may save it 
        under a different name.  Once a CDD file has been saved, this option is deselected until either a new CDD file is merged or the 
        user changes the exclude/include property of any coverage case within the GUI.
        </P
><P
>        Note that this option has an accelerator keystroke &lt;Control-s&gt;.  Hitting this keystroke combination will also save the 
        current CDD.
        </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1776"
>Close CDDs</A
></H4
><P
>        This menu option is used to close all opened/merged CDD files so that the user may view a different CDD file without needing to 
        exit and re-enter the GUI. The user may open and close as many times as needed without needing to reinvoke the GUI.  When CDD 
        files are closed, any opened coverage windows are automatically closed and all necessary GUI components are restored to their 
        original state as when the GUI is first invoked.  If the currently opened CDD file(s) have not been saved, a window (shown in 
        <A
HREF="#FIGURE.GUI.MAIN.CLOSE"
>The Close Warning Window</A
> below) is displayed to ask the user if they would like to save prior to closing.  To save 
        the CDD file, simply click "Yes" and a "Save As" window will prompt you for a location/name to save it as.  To close the CDD file 
        without saving, simply click "No".  To cancel the close operation, simply click <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Cancel</B
></SPAN
>.  To view 
        another CDD file after closing all CDD files, simply select the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Open/Merge CDDs...</B
></SPAN
> file menu 
        option.
        </P
><P
>        Note that this option has an accelerator keystroke &lt;Control-w&gt;.  Hitting this keystroke combination will also close all 
        opened CDD files.
        </P
><P
>          <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.MAIN.CLOSE"
></A
><P
><B
>Figure 16-6. The Close Warning Window</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/close_warn.gif"></P
></DIV
></DIV
>
        </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1789"
>Generate</A
></H4
><P
>        This option, when selected, displays a submenu of items that can be generated by the GUI.  The following options (with 
        descriptions) are available (see <A
HREF="#FIGURE.GUI.MAIN.GENERATE"
>The Generate Menu List</A
>).
        </P
><P
>          <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.MAIN.GENERATE"
></A
><P
><B
>Figure 16-7. The Generate Menu List</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/gen_menu.gif"></P
></DIV
></DIV
>
        </P
><P
>          <P
></P
><UL
><LI
><P
>              <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>ASCII Report...</B
></SPAN
>
              </P
><P
>              Selecting this submenu option will cause Covered to generate an ASCII version of the coverage report to a specified file 
              (note:  this can also be accomplished with the "report" command of Covered's command-line interface).  When this option is 
              selected, another window is created that lists the current report generation options as specified in the Preferences 
              window.  Additionally, the user may modify the report generation options and select the name of the coverage report file to 
              save.  See <A
HREF="#CHAPTER.GUI.GENREPORT"
>Navigating the ASCII Report Generator Window</A
> for more information on the navigation of this window.
              </P
><P
>              Note that this option has an accelerator keystroke &lt;Control-r&gt;. Hitting this keystroke combination will also cause 
              the ASCII report generator window to be displayed.
              </P
></LI
></UL
>
        </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1807"
>Exit</A
></H4
><P
>        This menu option will exit the entire GUI application, closing all opened windows created by this application.  Use this option 
        to exit the application.  If the currently opened CDD file(s) have not been saved, a window (shown in 
        <A
HREF="#FIGURE.GUI.MAIN.EXIT"
>The Exit Warning Window</A
> below) is displayed to ask the user if they would like to save prior to exiting.  To save 
        the CDD file, simply click <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Yes</B
></SPAN
> and a "Save As" window will prompt you for a location/name to 
        save it as.  To close the CDD file without saving, simply click <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>No</B
></SPAN
>.  To cancel the close 
        operation, simply click <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Cancel</B
></SPAN
>.
        </P
><P
>        Note that this option has an accelerator keystroke &lt;Control-x&gt;.  Hitting this keystroke combination will also close the 
        entire application.
        </P
><P
>          <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.MAIN.EXIT"
></A
><P
><B
>Figure 16-8. The Exit Warning Window</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/exit_warn.gif"></P
></DIV
></DIV
>
        </P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.GUI.MAIN.REPORTMENU"
>The Report Menu</A
></H3
><P
>      The report menu allows the user to display the currently opened CDD file contents in a number of different ways for analyzing.  The 
      options specified in this menu closely imitate the options in the "report" command.  The type of report can be changed at any point 
      in time while a CDD is loaded.  When a report menu option is selected, Covered will automatically convert all information in the 
      GUI to represent this report type.  <A
HREF="#FIGURE.GUI.MAIN.REPORT.MENU"
>The Report Menu</A
> below shows the contents of the report menu.  Each 
      menu item is described below the figure.
      </P
><P
>        <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.MAIN.REPORT.MENU"
></A
><P
><B
>Figure 16-9. The Report Menu</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/report_menu.gif"></P
></DIV
></DIV
>
      </P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1831"
>Module-Based</A
></H4
><P
>        When the diamond to the left of this option is selected, the generated report information will be in module-based representation.  
        A module-based report gathers all of the module instances that instantiate the same module and merges their results based on the 
        module name.  This is useful for understanding what logic in a module has been tested or untested without care to individual 
        instance contribution.  Selecting this report type (the default) will cause the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Instance-based</B
></SPAN
> 
        menu option to be automatically deselected (the two report types are mutually exclusive).
        </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1835"
>Instance-Based</A
></H4
><P
>        When the diamond to the left of this option is selected, the generated report information will be in instance-based 
        representation.  An instance-based report shows the coverage information for each module instance within the design.  This allows 
        the user to discern what logic is being covered in individual instances. Selecting this report type will cause the 
        <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Module-based</B
></SPAN
> menu option to be automatically deselected (the two report types are mutually 
        exclusive).
        </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1839"
>Show Uncovered</A
></H4
><P
>        When the square to the left of this option is selected (the default), all uncovered lines, toggles, logic, and FSM states/arcs 
        within the file viewer window will be highlighted for the user to quickly see what code was monitored by Covered but determined 
        to not be fully covered.  This option may be selected along with the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Show Covered</B
></SPAN
> menu option to 
        see both covered and uncovered logic within the same file.
        </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1843"
>Show Covered</A
></H4
><P
>        When the square to the left of this option is selected, all covered lines, toggles, logic, and FSM states/arcs within the file 
        viewer window will be highlighted for the user to quickly see what code was monitored by Covered and determined to be fully 
        covered.  This option is useful for the user of Covered to understand what logic was monitored during simulation.  This option 
        may be selected along with the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Show Uncovered</B
></SPAN
> menu option to see both covered and uncovered 
        logic within the same file.
        </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1847"
>Show Race Conditions</A
></H4
><P
>        When the square to the left of this option is selected, all logic lines that were found to contain a potential race condition and 
        was, therefore, eliminated from coverage consideration by Covered will be highlighted by the colors as selected in the preference 
        menu.  This option is useful for the user of Covered to understand what logic was not considered for coverage information due to 
        a detected potential race condition situation.  Please see <A
HREF="#CHAPTER.RACE"
>Race Condition Checking</A
> for more information on what Covered looks for in 
        logic to consider it to be a possible race condition.
        </P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.GUI.MAIN.VIEWMENU"
>The View Menu</A
></H3
><P
>      The View menu allows the user to select or change the current way the information in Covered is viewed.  
      <A
HREF="#FIGURE.GUI.MAIN.VIEW.MENU"
>The View Menu</A
> shows the contents of the View menu.
      </P
><P
>        <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.MAIN.VIEW.MENU"
></A
><P
><B
>Figure 16-10. The View Menu</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/view_menu.gif"></P
></DIV
></DIV
>
      </P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1861"
>Next Uncovered</A
></H4
><P
>        Causes the line containing the next uncovered metric to be visible in the <A
HREF="#SECTION.GUI.MAIN.VIEWER"
>Coverage File Viewer</A
>.  If the next uncovered line already visible, 
        this menu item will have no visible effect.  The search for the next uncovered line starts at (a) the top of the module (when the module is first displayed in 
        the the Coverage Viewer), (b) from the last uncovered line searched for with the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Next Uncovered</B
></SPAN
> or 
        <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Previous Uncovered</B
></SPAN
> calls, or (c) from the last currently selected line (only valid for toggle and combinational logic views).
        </P
><P
>        This menu item is only enabled when another uncovered line exists after the current uncovered line.  It can also be accessed with the accelerator keystroke 
        &lt;Control-n&gt; or the right arrow button in the Main Window.
        </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1868"
>Previous Uncovered</A
></H4
><P
>        Causes the line containing the previous uncovered metric to be visible in the <A
HREF="#SECTION.GUI.MAIN.VIEWER"
>Coverage File Viewer</A
>.  If the previous uncovered line is 
        already visible, this menu item will have no visible effect.  The search for the previous uncovered line starts at (a) the top of the module (when the module is 
        first displayed in the the Coverage Viewer), (b) from the last uncovered line  searched for with the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Next Uncovered</B
></SPAN
> or <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Previous Uncovered</B
></SPAN
> calls, or (c) from  the last currently selected line (only valid for toggle and combinational logic views).
        </P
><P
>        This menu item is only enabled when another uncovered line exists before the current uncovered line.  It can also be accessed with the accelerator keystroke 
        &lt;Control-p&gt; or the left arrow button in the Main Window.
        </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1875"
>Show Current Selection</A
></H4
><P
>        This menu item is only available if the current metric mode is not "Line", the  user has clicked on an uncovered segment of code, and the associated 
        <A
HREF="#CHAPTER.GUI.TOGGLE"
>Navigating the Toggle Coverage Window</A
>, <A
HREF="#CHAPTER.GUI.MEMORY"
>Navigating the Memory Coverage Window</A
>, <A
HREF="#CHAPTER.GUI.LOGIC"
>Navigating the Combinational Logic Window</A
>, <A
HREF="#CHAPTER.GUI.FSM"
>Navigating the FSM State/State Transition Coverage Window</A
> or 
        <A
HREF="#CHAPTER.GUI.ASSERT"
>Navigating the Assertion Coverage Window</A
> exists.  The currently selected line is visually identified in the <A
HREF="#SECTION.GUI.MAIN.VIEWER"
>Coverage File Viewer</A
> area on the left-
        hand-side of the line containing the uncovered code. If this line is not currently visible in the Coverage Viewer, selecting this menu item will cause it to be 
        visible.
        </P
><P
>        An accelerator keystroke &lt;Control-c&gt; will also invoke this menu item.
        </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1885"
>Wizard...</A
></H4
><P
>        Displays the Covered wizard window which normally opens upon starting the Covered GUI.  The Wizard window allows the user to easily create a new CDD file, open/
        merge existing CDD files, rank existing CDD files and get user documentation. See <A
HREF="#CHAPTER.GUI.WIZARD"
>Navigating the Wizard Window</A
> for more information.
        </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1889"
>Preferences...</A
></H4
><P
>        Causes the <A
HREF="#CHAPTER.GUI.PREFERENCES"
>Navigating the Preferences Window</A
> to be created if it currently does not exist or forces it into the foreground if it does exist.
        </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>          On Mac OS X, this menu item does not exist in the "Report Menu" but rather in the Covered application menu to remain consistent with the Mac OS X 
          environment.
          </P
></BLOCKQUOTE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.GUI.MAIN.HELPMENU"
>The Help Menu</A
></H3
><P
>      The help menu contains all of the user documentation for Covered. Additionally, information regarding the version of Covered used and other contact information for 
      application problems, suggestions, etc. can be found in this menu.
      </P
><P
>        <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.MAIN.HELP.MENU"
></A
><P
><B
>Figure 16-11. The Help Menu</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/help_menu.gif"></P
></DIV
></DIV
>
      </P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1904"
>Manual</A
></H4
><P
>        Selecting this menu item causes Covered to display the report viewer's user manual via HelpSystem &#38;165;.
        </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1907"
>About Covered</A
></H4
><P
>        Selecting this menu item causes Covered to bring up a window showing the current release number, developer contact information and credits.
        </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>          On Mac OS X, this menu item does not exist in the Help Menu but rather in the application's menu to remain consistent with the Mac OS X environment.
          </P
></BLOCKQUOTE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.GUI.MAIN.COVBAR"
>The Coverage Type View Bar</A
></H2
><P
>    <A
HREF="#FIGURE.GUI.MAIN.COVBAR"
>Covered Main Coverage Type View Bar</A
> shows the location of the coverage type view bar.  The bar contains a single selection button with the currently selected
    coverage metric displayed.  There are six main types of coverage metrics that Covered can provide:  line, toggle, memory, logic (combinational logic), FSM (state 
    and arc) and assert (assertion coverage).  When the Covered GUI is first invoked, the line coverage metric is the default mode.  To view a different metric, simply 
    left click, select the desired coverage metric, and left click again.  Doing so will automatically set the selection indicator to the new mode and display the new 
    metric information in the <A
HREF="#SECTION.GUI.MAIN.SUMCOV"
>The Summary Coverage Bar</A
>, <A
HREF="#SECTION.GUI.MAIN.LISTBOX"
>Module/Instance Listbox</A
>, and <A
HREF="#SECTION.GUI.MAIN.VIEWER"
>Coverage File Viewer</A
>.
    </P
><P
>      <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.MAIN.COVBAR"
></A
><P
><B
>Figure 16-12. Covered Main Coverage Type View Bar</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/main_cov.gif"></P
></DIV
></DIV
>
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.GUI.MAIN.SUMCOV"
>The Summary Coverage Bar</A
></H2
><P
>    The summary coverage bar contains the high-level coverage information for the currently selected module/instance and coverage metric.  Typically, this information will 
    tell the user the number of coverage points that were hit out of the total number of coverage points that Covered measured during simulation.  If the number hit is less 
    than the total, the currently selected module/instance was found to be not fully covered, and the name of the module/instance will be highlighted in the 
    <A
HREF="#SECTION.GUI.MAIN.LISTBOX"
>Module/Instance Listbox</A
> with the uncovered color scheme.
    </P
><P
>      <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.MAIN.SUMBAR"
></A
><P
><B
>Figure 16-13. Covered Main Summary Coverage Bar</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/main_summary.gif"></P
></DIV
></DIV
>
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.GUI.MAIN.LISTBOX"
>The Module/Instance Listbox</A
></H2
><P
>    After a CDD file has been opened in the GUI, the module/instance selection box (shown in 
    <A
HREF="#FIGURE.GUI.MAIN.LISTBOX"
>Populated Module/Instance Selection Box</A
> below) will contain either a list of all of the modules within the 
    specified design or a list of all of the instances within the design, based on the type of report selected in the 
    <A
HREF="#SECTION.GUI.MAIN.REPORTMENU"
>Report</A
> menu.  Left-clicking on a module/instance name within this box will 
    cause that file to be output in the <A
HREF="#SECTION.GUI.MAIN.VIEWER"
>Coverage File Viewer</A
> to the right of the selection box.
    </P
><P
>    In addition to the names of the modules or instances of the design, each line also contains a summary view of the 
    coverage for the currently selected metric for each module or instance.  The summary coverage information includes 
    the number of hits, number of misses, total number and hit percentage.  Each column in the table can be resized by 
    clicking on the separator bar between the column headers and sliding the column to the left or to the right.  
    Additionally, columns may be hidden or shown in the module/instance selection box by clicking on the button at the 
    right-hand side of the column header bar (and above the vertical scrollbar).  When this button is left-clicked, a 
    popup menu will be displayed showing which columns are currently shown (a check to the left of the column name) and 
    which are hidden (no check).  To change the display for a particular column, simply click on the column name in the 
    popup window.  This will cause the associated column to be hidden or shown and will close the popup window.  If the 
    popup window is displayed and the user does not wish to change the display values of any of the shown columns, 
    simply click anywhere on the screen but on the popup window.  This will cause the popup window to disappear and no 
    column display values will be changed.
    </P
><P
>    Depending on the selected coverage metric (specified in the <A
HREF="#SECTION.GUI.MAIN.COVBAR"
>The Coverage Type View Bar</A
>) and the 
    coverage results for each module/instance, a module/ instance item will be highlighted in the uncovered logic color 
    if the corresponding module/instance was found to have uncovered logic within that module/instance.  If the 
    specified module/instance was found to be fully covered for the currently selected metric, it will be highlighted 
    with the selected covered logic color.  This can help the user quickly identify modules/instances that contain 
    uncovered logic cases.  Note that when a different coverage metric is selected, the highlights will be recalculated 
    for that metric.  Additionally, the currently selected module/instance will be displayed in a darker version of the 
    covered/uncovered color.
    </P
><P
>      <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.MAIN.LISTBOX"
></A
><P
><B
>Figure 16-14. Populated Module/Instance Selection Box</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/populated_lb.gif"></P
></DIV
></DIV
>
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.GUI.MAIN.VIEWER"
>The Coverage File Viewer</A
></H2
><P
>    <A
HREF="#FIGURE.GUI.MAIN.VIEWER"
>Covered Main Coverage File Viewer</A
> shows the area of the main window where the coverage file viewer window is 
    located.
    </P
><P
>      <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.MAIN.VIEWER"
></A
><P
><B
>Figure 16-15. Covered Main Coverage File Viewer</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/main_viewer.gif"></P
></DIV
></DIV
>
    </P
><P
>    The coverage file viewer shows the currently selected module (indicated in the 
    <A
HREF="#SECTION.GUI.MAIN.INFOBAR"
>The Information Bar</A
>) Verilog source.  The coverage file viewer provides a read-only view of the 
    original source code so all editing of the file must be done in a separate editor.  Each source code line in the 
    viewer window is numbered to the left of the line to aid in debugging and finding the lines in an editor.
    </P
><P
>    Depending on the coverage metric currently selected in the <A
HREF="#SECTION.GUI.MAIN.COVBAR"
>The Coverage Type View Bar</A
> and the 
    covered/uncovered/race condition selections in the <A
HREF="#SECTION.GUI.MAIN.REPORTMENU"
>Report</A
>, the lines that are 
    found to be uncovered, covered, and/or considered a race condition are highlighted in their respective color 
    schemes in the coverage file viewer window.  Using the scrollbars to the right and below the coverage file viewer, 
    the user can find the missed/hit lines quickly for further analysis.
    </P
><P
>    The coverage file viewer is the place where the user can invoke the toggle, memory,combinational logic, FSM and/or 
    assertion detail windows.  To view one of these windows, do the following:
    </P
><P
>      <P
></P
><OL
TYPE="1"
><LI
><P
>          Select either the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Toggle</B
></SPAN
>, <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Memory</B
></SPAN
>, 
          <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Logic</B
></SPAN
>, <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>FSM</B
></SPAN
> or 
          <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Assert</B
></SPAN
> coverage metric radio button in the 
          <A
HREF="#SECTION.GUI.MAIN.COVBAR"
>The Coverage Type View Bar</A
>.
          </P
></LI
><LI
><P
>          Select a module/instance that contains uncovered code in the <A
HREF="#SECTION.GUI.MAIN.LISTBOX"
>Module/Instance Listbox</A
>.
          </P
></LI
><LI
><P
>          In the coverage file viewer, find code that is highlighted as being uncovered.
          </P
></LI
><LI
><P
>          Left click on the uncovered piece of logic.  Doing so will automatically bring up either the 
          <A
HREF="#CHAPTER.GUI.TOGGLE"
>Navigating the Toggle Coverage Window</A
>, the <A
HREF="#CHAPTER.GUI.MEMORY"
>Navigating the Memory Coverage Window</A
>, the 
          <A
HREF="#CHAPTER.GUI.LOGIC"
>Navigating the Combinational Logic Window</A
>, the <A
HREF="#CHAPTER.GUI.FSM"
>Navigating the FSM State/State Transition Coverage Window</A
> or the 
          <A
HREF="#CHAPTER.GUI.ASSERT"
>Navigating the Assertion Coverage Window</A
>.
          </P
></LI
></OL
>
    </P
><P
>    Additionally, the logical blocks that have been disregarded by Covered due to a potential race condition existing 
    are highlighted.  By placing the cursor over one of these logical blocks, the reason for why the logical block was 
    disregarded is output in the <A
HREF="#SECTION.GUI.MAIN.INFOBAR"
>The Information Bar</A
>.
    </P
><P
>    To view a new module/instance, simply left click on one in the Module/Instance Listbox. The source code for the 
    selected module/instance will be immediately loaded into the coverage file viewer in the currently selected 
    coverage metric.
    </P
><P
>    To view a new coverage metric, simply left click on one of the coverage metrics in the Coverage Type Bar.  The 
    currently selected module/instance will be immediately updated in the coverage file viewer, highlighting the 
    uncovered/covered code for the current metric.
    </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.GUI.MAIN.VIEWER.SEARCH.UNCOV"
>Searching for an Uncovered Line in the Coverage Viewer</A
></H3
><P
>      To find the next or previous line containing uncovered logic for the current metric mode, click the 
      left arrow (Previous) or right arrow (Next) buttons.  Doing so will cause the next or previous uncovered line to 
      be visible in the Coverage File Viewer.  Clicking these buttons has the same effect as the "Next Uncovered" or 
      "Previous Uncovered" menu items in the <A
HREF="#SECTION.GUI.MAIN.VIEWMENU"
>The View Menu</A
>.
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.GUI.MAIN.VIEWER.SEARCH.STRING"
>Searching for a String in the Coverage Viewer</A
></H3
><P
>      The Coverage Viewer contains a <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Find:</B
></SPAN
> button, an entry field, and a 
      <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Clear</B
></SPAN
> button for performing text searches in the Coverage File Viewer.  The user 
      may type in any string (wildcards and pattern matching is not supported) in the entry field. Hitting the "return" 
      key or the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Find:</B
></SPAN
> button will cause the string search to commence.
      </P
><P
>      If a match to the search value is found, it is made visible in the Coverage File Viewer and highlighted.  The 
      user may search on the value again by clicking the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Find:</B
></SPAN
> button.  To clear the 
      current value in the entry field, click on the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Clear</B
></SPAN
> button.  If a match occurs, 
      the specified value in the entry field will remain until either a new value is entered or the 
      <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Clear</B
></SPAN
> button is clicked.  If a match was not found for the given string, a 
      message window will pop-up specifying that the given string was not found.  Clicking the 
      <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>OK</B
></SPAN
> button will cause this message window to close and the entry field will 
      automatically be cleared.
      </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.GUI.MAIN.INFOBAR"
>The Information Bar</A
></H2
><P
>    The information bar at the bottom of each window in the report viewer provides information about the current mode, 
    file, or operation the user should take next. All information is state and context sensitive.  If you are in doubt 
    of what to do next, first see the information bar.
    </P
><P
>      <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.MAIN.INFOBAR"
></A
><P
><B
>Figure 16-16. Covered Main Information Bar</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/main_info.gif"></P
></DIV
></DIV
>
    </P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER.GUI.LINE"
></A
>Chapter 17. Navigating the Line Coverage Window</H1
><P
>  Line coverage is the quickest way to determine what logic in your design is being exercised and which logic has not 
  be exercised during simulation.  If a line was found to not be simulated, this is an indication that there was some 
  event that did not occur or did not occur at the proper time to cause a previous conditional expression to be 
  evaluated to true or false.  For example, if a block of code looked something like:
  </P
><P
>    <PRE
CLASS="PROGRAMLISTING"
>  always @(posedge clock)  // Line 1
    if( a )                // Line 2
      b &#60;= 1'b0;           // Line 3
    else                   // Line 4
      b &#60;= 1'b1;           // Line 5
    </PRE
>
  </P
><P
>  If line 3 was shown to be not covered, this would indicate that at the positive edge of the term "clock", the value 
  of "a" never evaluated to a value of 1 (true).  To make line 3 become covered, we would need to setup a situation in 
  the diagnostic that caused "a" to become true at the positive edge of the term "clock".
  </P
><P
>  On the other hand, if all lines 2 - 5 were found to be uncovered, this would indicate the the term "clock" never made 
  a transition from some value to a 1 (true) value during simulation.
  </P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.GUI.LINE.UNCOV"
>Viewing Uncovered Lines</A
></H2
><P
>    To view line coverage for all uncovered lines for a specific module/instance, do the following:
    </P
><P
>      <P
></P
><OL
TYPE="1"
><LI
><P
>          Make sure that the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Show Uncovered</B
></SPAN
> menu item in the 
          <A
HREF="#SECTION.GUI.MAIN.REPORTMENU"
>Report</A
> is selected.
          </P
></LI
><LI
><P
>          Select the line coverage metric in the <A
HREF="#SECTION.GUI.MAIN.COVBAR"
>The Coverage Type View Bar</A
> by left-clicking on selection 
          button to the left of "Line".
          </P
></LI
><LI
><P
>          Select one of the modules/instances that is highlighted in the uncovered color scheme (to change this color 
          scheme, see <A
HREF="#CHAPTER.GUI.PREFERENCES"
>Navigating the Preferences Window</A
>) in the <A
HREF="#SECTION.GUI.MAIN.LISTBOX"
>Module/Instance Listbox</A
>.  This 
          will cause the selected module/instance source code to be displayed in the 
          <A
HREF="#SECTION.GUI.MAIN.VIEWER"
>Coverage File Viewer</A
>.
          </P
></LI
></OL
>
    </P
><P
>    Once the selected module/instance has been displayed, scroll down in the Coverage File Viewer window (using the 
    scroll bars to the right and below the Coverage File Viewer window) until you have reached a line that is 
    highlighted in the uncovered color scheme. The line number of the highlighted line will be printed to the left of 
    the source code line.  This line represents a line that was found to not be hit during the simulation of this 
    module/instance.
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.GUI.LINE.EXCL"
>Excluding/Included Uncovered Lines from Line Coverage</A
></H2
><P
>    Any uncovered line in the design may be included/excluded from coverage consideration.  To the left of each 
    uncovered line is an underlined "I" (line is included in coverage) or "E" (line is excluded in coverage). Clicking 
    on this character will change the coverage exclusion property of the line by recalculating the summary line 
    coverage information, redisplaying it in the <A
HREF="#SECTION.GUI.MAIN.SUMCOV"
>The Summary Coverage Bar</A
>, changing the background 
    color of the line from the uncovered background color to the covered background color, and changing the leftmost 
    character of the line to the opposite value to indicate its current status. 
    <A
HREF="#FIGURE.GUI.LINE.INCLUDE"
>Example of uncovered line included for line coverage consideration</A
> shows an uncovered line that is included for coverage consideration. 
    <A
HREF="#FIGURE.GUI.LINE.EXCLUDE"
>Example of uncovered line excluded for line coverage consideration</A
> shows the same line which is now excluded from coverage consideration.
    </P
><P
>      <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.LINE.INCLUDE"
></A
><P
><B
>Figure 17-1. Example of uncovered line included for line coverage consideration</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/line_incl.gif"></P
></DIV
></DIV
>
    </P
><P
>      <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.LINE.EXCLUDE"
></A
><P
><B
>Figure 17-2. Example of uncovered line excluded for line coverage consideration</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/line_excl.gif"></P
></DIV
></DIV
>
    </P
><P
>    In addition to changing the line coverage information, the combinational logic coverage information for an 
    uncovered statement on that line will also be implicitly excluded from coverage (though the exclude properties for 
    each subexpression of the statement will not change).
    </P
><P
>    If the user excludes any line in the design, the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Save CDD...</B
></SPAN
> option in the 
    <A
HREF="#SECTION.GUI.MAIN.FILEMENU"
>File</A
> menu will be enabled.  This allows the user to save the excluded property 
    either back to the CDD file (or to a newly named CDD file). Doing so will allow the user to load the CDD file at a 
    different time and retain the knowledge of which lines have been excluded/included for coverage.  Additionally, if 
    a saved CDD file with coverage exclusion is merged with another CDD file, the excluded line information is 
    preserved for the resulting merged CDD file.
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.GUI.LINE.COV"
>Viewing Covered Lines</A
></H2
><P
>    To view line coverage for all covered lines for a specific module/instance, do the following:
    </P
><P
>      <P
></P
><OL
TYPE="1"
><LI
><P
>          Make sure that the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Show Covered</B
></SPAN
> menu item in the 
          <A
HREF="#SECTION.GUI.MAIN.REPORTMENU"
>Report</A
> menu is selected.
          </P
></LI
><LI
><P
>          Select the line coverage metric in the <A
HREF="#SECTION.GUI.MAIN.COVBAR"
>The Coverage Type View Bar</A
> by left-clicking on the 
          selection button to the left of "Line".
          </P
></LI
><LI
><P
>          Select one of the modules/instances in the <A
HREF="#SECTION.GUI.MAIN.LISTBOX"
>Module/Instance Listbox</A
> that shows that at least 
          one line was considered coverable by Covered.
          </P
></LI
></OL
>
    </P
><P
>    Once the selected module/instance has been displayed, scroll down in the Coverage File Viewer window (using the 
    scroll bars to the right and below the Coverage File Viewer window) until you have reached a line that is 
    highlighted in the covered color scheme. The line number of the highlighted line will be printed to the left of the 
    source code line.  This line represents a line that was found to be hit during the simulation of this 
    module/instance.
    </P
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>    You may see both the covered and uncovered line coverage simultaneously by selecting both the 
    <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Show Uncovered</B
></SPAN
> and <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Show Covered</B
></SPAN
> items in the 
    <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Report</B
></SPAN
> menu.  This is sometimes useful to see what logic Covered was not able to 
    provide coverage support for (all lines which contain code that are not highlighted in either the uncovered or 
    covered color schemes).
    </P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER.GUI.TOGGLE"
></A
>Chapter 18. Navigating the Toggle Coverage Window</H1
><P
>  The verbose toggle window allows the user to see which bits for a given signal have toggled from a 0-&gt;1 or a 
  1-&gt;0 during simulation. To display this window, simply click on a highlighted/underlined uncovered signal in the 
  <A
HREF="#SECTION.GUI.MAIN.VIEWER"
>Coverage File Viewer</A
> of the main window.  This will cause the verbose toggle viewer to be created 
  for the specified signal as well as display a "--&gt;" symbol in the Coverage Viewer on the same line as the selected 
  signal.  This symbol is simply meant to help the user identify in the Coverage Viewer which signal is currently 
  displayed in the Toggle Viewer window.  <A
HREF="#FIGURE.GUI.TOGGLE"
>Verbose Toggle Window</A
> shows the Toggle Viewer loaded with a 
  4-bit signal called "err_vec" in which bits 3:2 have successfully toggled from a 0-&gt;1.
  </P
><P
>    <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.TOGGLE"
></A
><P
><B
>Figure 18-1. Verbose Toggle Window</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/toggle_full.gif"></P
></DIV
></DIV
>
  </P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.GUI.TOGGLE.LAYOUT"
>Understanding the Layout</A
></H2
><P
>    The bit vector displayed is a binary bit vector, each value (0 or 1) represents whether that bit in the signal 
    either toggled (1) or did not toggle (0) during simulation.  There are two bit vectors displayed for the signal, 
    the top vector shows the 0-&gt;1 toggle information while the bottom vector shows the 1-&gt;0 toggle information.
    </P
><P
>    The name of the signal along with its MSB:LSB information is displayed at the bottom of the window; however, if the 
    mouse cursor is placed over a specific bit in the toggle box, the MSB:LSB will be changed to show the displayed 
    bit, making it easy for the user to discern exactly which bit has toggled/not toggled.  If the width of the signal 
    exceeds the given space for the toggle window, a scrollbar will be allowed to slide left and right to view the rest 
    of the toggle information.
    </P
><P
>    To exit this window, simply click on <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Close</B
></SPAN
> button.  To see this help page from the 
    toggle window, click on the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Help</B
></SPAN
> button.
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.GUI.TOGGLE.EXCL"
>Excluding/Including a Signal for Toggle Coverage</A
></H2
><P
>    The user may exclude/include any uncovered signal in the design for toggle coverage by simply clicking on the 
    <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Excluded</B
></SPAN
> checkbutton.  If this checkbutton is checked, the summary coverage 
    information will automatically be recalculated and redisplayed in the <A
HREF="#SECTION.GUI.MAIN.SUMCOV"
>The Summary Coverage Bar</A
> and 
    the background color of the underlined signal in the <A
HREF="#SECTION.GUI.MAIN.VIEWER"
>Coverage File Viewer</A
> will change from the 
    uncovered background color to the covered background color.  However, the signal will still remain underlined, 
    allowing the user to see the verbose toggle coverage information, if necessary.  If the 
    <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Excluded</B
></SPAN
> checkbutton is unchecked, the summary coverage information and background 
    colors will be readjusted to include the coverage information for this signal.
    </P
><P
>    If the user excludes any signal for toggle coverage in the design, the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Save CDD...</B
></SPAN
> 
    option in the <A
HREF="#SECTION.GUI.MAIN.FILEMENU"
>File</A
> menu will be enabled.  This allows the user to save the 
    excluded property either back to the CDD file (or to a newly named CDD file).  Doing so will allow the user to load 
    the CDD file at a different time and retain the knowledge of which signals have been excluded/included for toggle 
    coverage.  Additionally, if a saved CDD file with coverage exclusion is merged with another CDD file, the excluded 
    signal information is preserved for the resulting merged CDD file.
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.GUI.TOGGLE.DISPLAY"
>Displaying a New Signal for Toggle Coverage</A
></H2
><P
>    If the Verbose Toggle Coverage window is currently displayed with a signal, the user may select a new signal in the 
    <A
HREF="#SECTION.GUI.MAIN.VIEWER"
>Coverage File Viewer</A
> of the Main window.  When a new signal is selected, its value immediately 
    replaces the currently selecting signal value.  This feature allows many different signals to be viewed one after 
    the other without having to create/destroy a new window for each signal.
    </P
><P
>    The user may also see the previous or next uncovered signal in the main viewer by clicking either the left arrow 
    button (for previous signal viewing) or the right arrow button (for next signal viewing).  Note that the left arrow 
    button will be disabled if there is not a signal previous to the current signal in the given module and the right 
    arrow button will be disabled if there is not a signal after the current signal in the given module.
    </P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER.GUI.MEMORY"
></A
>Chapter 19. Navigating the Memory Coverage Window</H1
><P
>  The verbose memory window allows the user to interactively view all of the coverage information for a selected 
  memory, including the following for each addressable memory element:
  </P
><P
>    <P
></P
><OL
TYPE="1"
><LI
><P
>Have all bits toggled from 0 -&gt; 1 and from 1 -&gt; 0?</P
></LI
><LI
><P
>Has the entry been written?</P
></LI
><LI
><P
>Has the entry been read?</P
></LI
></OL
>
  </P
><P
>  To display this window, simply click on a highlighted/underlined uncovered memory in the 
  <A
HREF="#SECTION.GUI.MAIN.VIEWER"
>Coverage File Viewer</A
>.  This will cause the verbose memory viewer to be created for the specified 
  memory as well as display a "--&gt;" symbol in the Coverage Viewer on the same line as the selected memory.  This 
  symbol is simply meant to help the user identify in the Coverage Viewer which memory is currently displayed in the 
  Memory Viewer window.  Figure 1 shows the Memory Viewer loaded with a 4-dimensional memory called "mem" in which two 
  of the dimensions are unpacked (all combinations of unpacked dimensions make up the total number of addressable 
  elements in the memory), creating a total of 18 addressable elements.  The first addressable element "[0][0]" is 
  shown in the lower frame in which only a single bit has been toggled from 0 to 1, the element has been written, but 
  it has not been read.
  </P
><P
>    <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.MEMORY"
></A
><P
><B
>Figure 19-1. Verbose Memory Window</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/memory_full.gif"></P
></DIV
></DIV
>
  </P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.GUI.MEMORY.LAYOUT"
>Understanding the Layout</A
></H2
><P
>    The Memory Coverage window is split up into three main frames stacked from top to bottom.  These frames, in order 
    from top to bottom, are the "Addressable Memory Elements" frame, the "Element Coverage" frame, and the button 
    frame.  Each are described in detail below.
    </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.GUI.MEMORY.LAYOUT.AME"
>Addressable Memory Elements Frame</A
></H3
><P
>      The uppermost frame contains all of the addressable memory elements (AMEs) of the memory.  An AME is a single 
      memory entry that is addressed by specifying a unique combination of values for each of the unpacked dimensions 
      of the memory.  For example, consider the following memory:
      </P
><P
>        <PRE
CLASS="PROGRAMLISTING"
>  reg [15:0] foo[0:1][0:3];      
        </PRE
>
      </P
><P
>      This memory called "foo" contains three dimensions.  One packed dimension which is a 16-bit little endian value 
      and two unpacked dimensions, containing two entries of four entries (for a total of eight addressable memory 
      elements).  Each AME being 16 bits wide.  The AMEs for this memory would be:
      </P
><P
>        <P
></P
><UL
><LI
><P
>foo[0][0]</P
></LI
><LI
><P
>foo[0][1]</P
></LI
><LI
><P
>foo[0][2]</P
></LI
><LI
><P
>foo[0][3]</P
></LI
><LI
><P
>foo[1][0]</P
></LI
><LI
><P
>foo[1][1]</P
></LI
><LI
><P
>foo[1][2]</P
></LI
><LI
><P
>foo[1][3]</P
></LI
></UL
>
      </P
><P
>      The upper frame will contain all of the AMEs for the selected memory.  The uncovered AMEs will be highlighted in 
      the uncovered color scheme (as specified in the <A
HREF="#CHAPTER.GUI.PREFERENCES"
>Navigating the Preferences Window</A
>) while all fully covered 
      AMEs will remain unhighlighted.  To view the coverage information for any uncovered AME, simply click on it and 
      the information will be viewable in the "Element Coverage" frame below it.
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.GUI.MEMORY.LAYOUT.ELEM"
>Element Coverage Frame</A
></H3
><P
>      The Element Coverage frame shows all of the coverage information for the currently selected AME including toggle 
      coverage (which bits of the element toggled from 0-&gt;1 and 1-&gt;0), write coverage (was this entry written to) 
      and read coverage (was this entry accessed).
      </P
><P
>      The bit vector displayed in the toggle window is a binary bit vector, where each value (0 or 1) represents 
      whether that bit in the signal either toggled (1) or did not toggle (0) during simulation. There are two bit 
      vectors displayed for the AME, the top vector shows the 0-&gt;1 toggle information while the bottom vector shows 
      the 1-&gt;0 toggle information.
      </P
><P
>      The name of the memory along with its dimensional range information is displayed below the toggle window; 
      however, if the mouse cursor is placed over a specific bit in the toggle box, the packed dimensional range 
      information will be changed to show the displayed bit, making it easy for the user to discern exactly which bit 
      has toggled/not toggled.  If the width of the AME exceeds the given space for the toggle window, a scrollbar will 
      be allowed to slide left and right to view the rest of the toggle information.
      </P
><P
>      Below the memory name are two other pieces of coverage information about the AME.  The value to the right of the 
      <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Written:</B
></SPAN
> label will be set to either "Yes" or "No".  If the value is "Yes", this 
      indicates that the currently selected AME was written during simulation and value will be highlighted with the 
      covered color scheme (as selected in the <A
HREF="#CHAPTER.GUI.PREFERENCES"
>Navigating the Preferences Window</A
>).  If the value is "No", this 
      indicates that the currently selected AME was not written during simulation and the value will be highlighted 
      with the uncovered color scheme.
      </P
><P
>      To the right of the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Written</B
></SPAN
> information is the 
      <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Read</B
></SPAN
> label which will also be set to either a value of "Yes" or "No".  If the 
      value is "Yes", this indicates that the currently selected AME was accessed during simulation and the value will 
      be highlighted with the covered color scheme. If the value is "No", this indicates that the currently selected 
      AME was not accessed during simulation and the value will be highlighted with the uncovered color scheme.
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.GUI.MEMORY.LAYOUT.BUTTON"
>Button Frame</A
></H3
><P
>      The button frame contains buttons for closing the Memory Coverage window, displaying this help page, or moving to 
      the next/previous uncovered memory in the same module/instance.
      </P
><P
>      To exit this window, simply click on <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Close</B
></SPAN
> button.  To see this help page from 
      the toggle window, click on the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Help</B
></SPAN
> button.
      </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.GUI.MEMORY.EXCL"
>Excluding/Including a Memory for Memory Coverage</A
></H2
><P
>    The user may exclude/include any uncovered memory in the design for memory coverage by simply clicking on the 
    <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Excluded</B
></SPAN
> checkbutton in the upper right-hand portion of the Memory Coverage 
    window. If this checkbutton is checked, the summary coverage information will automatically be recalculated and 
    redisplayed in the <A
HREF="#SECTION.GUI.MAIN.SUMCOV"
>The Summary Coverage Bar</A
> and the background color of the underlined memory in 
    the <A
HREF="#SECTION.GUI.MAIN.VIEWER"
>Coverage File Viewer</A
> will change from the uncovered background color to the covered 
    background color.  However, the memory will still remain underlined, allowing the user to see the verbose memory 
    coverage information, if necessary.  If the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Excluded</B
></SPAN
> checkbutton is unchecked, the 
    summary coverage information and background colors will be readjusted to include the coverage information for this 
    memory.
    </P
><P
>    If the user excludes any memory for memory coverage in the design, the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Save CDD...</B
></SPAN
> 
    option in the <A
HREF="#SECTION.GUI.MAIN.FILEMENU"
>File</A
> menu.  This allows the user to save the excluded property 
    either back to the CDD file (or to a newly named CDD file).  Doing so will allow the user to load the CDD file at a 
    different time and retain the knowledge of which memories have been excluded/included for memory coverage. 
    Additionally, if a saved CDD file with coverage exclusion is merged with another CDD file, the excluded memory 
    information is preserved for the resulting merged CDD file.
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.GUI.MEMORY.DISPLAYING"
>Displaying a New Memory for Memory Coverage</A
></H2
><P
>    If the Verbose Memory Coverage window is currently displayed with a memory, the user may select a new memory in 
    the <A
HREF="#SECTION.GUI.MAIN.VIEWER"
>Coverage File Viewer</A
> of the Main window.  When a new memory is selected, its value 
    immediately replaces the currently selecting memory value.  This feature allows many different memories to be 
    viewed one after the other without having to create/destroy a new window for each memory.
    </P
><P
>    The user may also see the previous or next uncovered memory in the main viewer by clicking either the left arrow 
    button (for previous memory viewing) or the right arrow button (for next memory viewing).  Note that the left arrow 
    button will be disabled if there is not a memory previous to the current memory in the given module and the right 
    arrow button will be disabled if there is not a memory after the current memory in the given module.
    </P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER.GUI.LOGIC"
></A
>Chapter 20. Navigating the Combinational Logic Window</H1
><P
>  The Verbose Combinational Logic viewer allows the user to look at the subexpressions of a selected statement to 
  determine exactly why a statement did not achieve 100% coverage. The window is split up into two text frames.  The 
  top frame displays the selected statement, underlining and numbering subexpressions that were found to not achieve 
  full coverage. The bottom frame displays which combinations of a selected subexpression were hit/missed, allowing the 
  user to discern which combinations of logic are still in need of verification.  Figure 1 shows the verbose 
  combination logic window.
  </P
><P
>    <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.LOGIC"
></A
><P
><B
>Figure 20-1. Example of the verbose combinational logic window</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/comb_complex.gif"></P
></DIV
></DIV
>
  </P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.GUI.LOGIC.NAVIGATE"
>Navigating a Statement</A
></H2
><P
>    To understand what subexpressions of a statement caused it to not achieve 100% coverage, the viewer window allows 
    the user to traverse uncovered subexpressions, displaying the coverage information for each subexpression in the 
    lower frame.  To see an uncovered subexpression in the lower frame, simply click the left mouse on the underlined 
    subexpression.  If the subexpression has one or more children subexpressions, these will be individually underlined 
    and numbered.  If the subexpression is a leaf subexpression of the statement, only its coverage information will be 
    displayed in the lower pane.  To traverse upward in a subexpression, simply click the right mouse button on the 
    underlined subexpression.  This will cause the parent subexpression to be underlined and its parent (if one exists) 
    will have its coverage information displayed in the lower frame.
    </P
><P
>    To exit this window, simply click on <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Close</B
></SPAN
> button. To see this help page for the 
    combinational logic window, click on the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Help</B
></SPAN
> button.
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.GUI.LOGIC.INFO"
>Understanding the Coverage Information</A
></H2
><P
>    The coverage information for a selected subexpression can be one of four different types:
    </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.GUI.LOGIC.INFO.EVENT"
>Event Subexpression</A
></H3
><P
>      These subexpressions do not have any children expressions.  Their coverage is in terms of:
      </P
><P
>        <P
></P
><UL
><LI
><P
>Did this event occur?</P
></LI
></UL
>
      </P
><P
>      The following operators are considered events:
      </P
><P
>        <P
></P
><UL
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>At-event operators</B
></SPAN
>:</P
><P
>              <PRE
CLASS="PROGRAMLISTING"
>  @(posedge &#60;expression&#62;)
  @(negedge &#60;expression&#62;)
  @(&#60;expression&#62;)
  @*
              </PRE
>
            </P
></LI
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Event trigger operator</B
></SPAN
>:</P
><P
>              <PRE
CLASS="PROGRAMLISTING"
>  -&#62; &#60;event_variable&#62;            
              </PRE
>
            </P
></LI
></UL
>
      </P
><P
>        <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.LOGIC.UNCOV.EVENT"
></A
><P
><B
>Figure 20-2. Example Coverage Output for an Uncovered Event Subexpression</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/comb_event.gif"></P
></DIV
></DIV
>
      </P
><P
>      In this diagram, we see that a certain <FONT
COLOR="RED"
>@(posedge clock)</FONT
> expression never occured.
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.GUI.INFO.UNARY"
>Unary Subexpression</A
></H3
><P
>      These subexpressions do not have any children expressions.  Their coverage is in terms of:
      </P
><P
>        <P
></P
><UL
><LI
><P
>Did this expression evaluate to a value of 0?</P
></LI
><LI
><P
>Did this expression evaluate to a non-zero value?</P
></LI
></UL
>
      </P
><P
>      The following operators are considered unary subexpressions:
      </P
><P
>        <P
></P
><UL
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Signal/Bit Selectors</B
></SPAN
>:</P
><P
>              <PRE
CLASS="PROGRAMLISTING"
> &#60;signal_value&#62;
 &#60;signal_value&#62;[&#60;expression&#62;]
 &#60;signal_value&#62;[&#60;value&#62;:&#60;value&#62;]
 &#60;signal_value&#62;[&#60;expression&#62;+:&#60;value&#62;]
 &#60;signal_value&#62;[&#60;expression&#62;-:&#60;value&#62;]          
              </PRE
>
            </P
></LI
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Function call</B
></SPAN
>:</P
><P
>              <PRE
CLASS="PROGRAMLISTING"
>  &#60;function_name&#62;( ... )            
              </PRE
>
            </P
></LI
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Relational operators</B
></SPAN
>:</P
><P
>              <PRE
CLASS="PROGRAMLISTING"
>  !&#60;expression&#62;
  &#60;expression&#62;  &#60;    &#60;expression&#62;
  &#60;expression&#62;  &#62;    &#60;expression&#62;
  &#60;expression&#62;  &#60;=   &#60;expression&#62;
  &#60;expression&#62;  &#62;=   &#60;expression&#62;
  &#60;expression&#62;  ==   &#60;expression&#62;
  &#60;expression&#62;  !=   &#60;expression&#62;
  &#60;expression&#62;  ===  &#60;expression&#62;
  &#60;expression&#62;  !==  &#60;expression&#62;            
              </PRE
>
            </P
></LI
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Shift operators</B
></SPAN
>:</P
><P
>              <PRE
CLASS="PROGRAMLISTING"
>  &#60;expression&#62; &#60;&#60;  &#60;value&#62;
  &#60;expression&#62; &#62;&#62;  &#60;value&#62;
  &#60;expression&#62; &#60;&#60;&#60; &#60;value&#62;
  &#60;expression&#62; &#62;&#62;&#62; &#60;value&#62;            
              </PRE
>
            </P
></LI
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Conditional operator</B
></SPAN
>:</P
><P
>              <PRE
CLASS="PROGRAMLISTING"
>  &#60;expression&#62; ? &#60;expression&#62; : &#60;expression&#62;            
              </PRE
>
            </P
></LI
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Unary operators</B
></SPAN
>:</P
><P
>              <PRE
CLASS="PROGRAMLISTING"
>  &#60;expression&#62;
  &#38;&#60;expression&#62;
  |&#60;expression&#62;
  ^&#60;expression&#62;
  ~&#38;&#60;expression&#62;
  ~|&#60;expression&#62;
  ~^&#60;expression&#62;            
              </PRE
>
            </P
></LI
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Concatenation operators</B
></SPAN
>:</P
><P
>              <PRE
CLASS="PROGRAMLISTING"
>  {&#60;value&#62;{&#60;expression&#62;} }
  {&#60;expression, &#60;expression&#62;, ... }            
              </PRE
>
            </P
></LI
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Case equality</B
></SPAN
></P
></LI
></UL
>
      </P
><P
>        <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.LOGIC.UNCOV.UNARY"
></A
><P
><B
>Figure 20-3. Example Coverage Output for an Uncovered Unary Subexpression</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/comb_unary.gif"></P
></DIV
></DIV
>
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.GUI.LOGIC.SIMPLE"
>Simple Combinational Subexpression</A
></H3
><P
>      These subexpressions have two child expressions (L=left and R=right).  There are three flavors of simple 
      combinational subexpressions:  AND-type, OR-type and other.  The differences are explained below.
      </P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2302"
>Simple AND-type Combinational Subexpressions</A
></H4
><P
>        These subexpressions have three possible combinational outcomes:
        </P
><P
>          <P
></P
><UL
><LI
><P
>Did the left expression evaluate to 0?</P
></LI
><LI
><P
>Did the right expression evaluate to 0?</P
></LI
><LI
><P
>Did the left expression evaluate to 1 when the right expression evaluated to 1?</P
></LI
></UL
>
        </P
><P
>        The following operators are considered simple AND-like combinational subexpressions:
        </P
><P
>          <P
></P
><UL
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Logical operators</B
></SPAN
>:</P
><P
>                <PRE
CLASS="PROGRAMLISTING"
>  &#60;expression&#62;  &#38;   &#60;expression&#62;
  &#60;expression&#62;  ~&#38;  &#60;expression&#62;
  &#60;expression&#62;  &#38;&#38;  &#60;expression&#62;              
                </PRE
>
              </P
></LI
></UL
>
        </P
><P
>          <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.INFO.SIMPLE.AND"
></A
><P
><B
>Figure 20-4. Example Coverage Output for an Uncovered Simple AND-type Combinational Subexpression</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/comb_simple_and.gif"></P
></DIV
></DIV
>
        </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2327"
>Simple OR-type Combinational Subexpressions</A
></H4
><P
>        These subexpressions have three possible combinational outcomes:
        </P
><P
>          <P
></P
><UL
><LI
><P
>Did the left expression evaluate to 1?</P
><P
>Did the right expression evaluate to 1?</P
><P
>Did the left expression evaluate to 0 when the right expression evaluated to 0?</P
></LI
></UL
>
        </P
><P
>        The following operators are considered simple OR-like combinational subexpressions:
        </P
><P
>          <P
></P
><UL
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Logical operators</B
></SPAN
></P
></LI
><LI
><P
>                <PRE
CLASS="PROGRAMLISTING"
>  &#60;expression&#62;  |   &#60;expression&#62;
  &#60;expression&#62;  ~|  &#60;expression&#62;
  &#60;expression&#62;  ||  &#60;expression&#62;              
                </PRE
>
              </P
></LI
></UL
>
        </P
><P
>          <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.INFO.SIMPLE.OR"
></A
><P
><B
>Figure 20-5. Example Coverage Output for an Uncovered Simple OR-type Combinational Subexpression</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/comb_simple_or.gif"></P
></DIV
></DIV
>
        </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2351"
>Simple Other-type Combinational Subexpressions</A
></H4
><P
>        These subexpressions have four possible combinational outcomes:
        </P
><P
>          <P
></P
><UL
><LI
><P
>Did the left expression evaluate to 0 when the right expression evaluated to 0?</P
></LI
><LI
><P
>Did the left expression evaluate to 0 when the right expression evaluated to 1?</P
></LI
><LI
><P
>Did the left expression evaluate to 1 when the right expression evaluated to 0?</P
></LI
><LI
><P
>Did the left expression evaluate to 1 when the right expression evaluated to 1?</P
></LI
></UL
>
        </P
><P
>        The following operators are considered simple combinational subexpressions:
        </P
><P
>          <P
></P
><UL
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Mathematical operators</B
></SPAN
>:</P
><P
>                <PRE
CLASS="PROGRAMLISTING"
>  &#60;expression&#62; + &#60;expression&#62;
  &#60;expression&#62; - &#60;expression&#62;              
                </PRE
>
              </P
></LI
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Logical operators</B
></SPAN
>:</P
><P
>                <PRE
CLASS="PROGRAMLISTING"
>  &#60;expression&#62; ^  &#60;expression&#62;
  &#60;expression&#62; ~^ &#60;expression&#62;              
                </PRE
>
              </P
></LI
></UL
>
        </P
><P
>          <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.INFO.SIMPLE.OTHER"
></A
><P
><B
>Figure 20-6. Example Coverage Output for an Uncovered Simple Combinational Subexpression</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/comb_simple.gif"></P
></DIV
></DIV
>
        </P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.GUI.LOGIC.COMPLEX"
>Complex Combinational Subexpression</A
></H3
><P
>      These subexpression have three or more child expressions that all are connected by the same operator.  For 
      example, the statement <FONT
COLOR="RED"
>a = (b &#38; c &#38; d)</FONT
> would contain the complex combinational 
      subexpression of <FONT
COLOR="RED"
>(b &#38; c &#38; d)</FONT
> where b, c and d are the three child expressions all 
      combined using the bitwise AND operator.
      </P
><P
>      The effect of each subexpression on the value of the entire subexpression as well as the combination of each 
      child toward the parent is displayed.  For example, if the combinational operator is a bitwise OR, each child is 
      checked to see if it evaluated to TRUE (in an OR operation, only one subexpression needs to evaluate to TRUE for 
      the entire subexpression to be TRUE).  Additionally, all child subexpressions are checked to see if all evaluated 
      to 0 simultaneously (this is the only way to get the whole subexpression to evaluate to 0).
      </P
><P
>      The unique identifier below each subexpression is used in the displayed coverage information for these types of 
      subexpressions for identifying which subexpression did not behave correctly.
      </P
><P
>      All simple combinational subexpressions can be output as complex combinational subexpressions if there are three 
      or more child subexpressions to the operation.
      </P
><P
>        <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.LOGIC.COMPLEX"
></A
><P
><B
>Figure 20-7. Example Coverage Output for an Uncovered Complex Combinational Subexpression</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/comb_complex.gif"></P
></DIV
></DIV
>
      </P
><P
>      In this example, subexpression 1 never evaluated to a value of TRUE (which would have made the entire expression 
      TRUE) and all three subexpressions 1, 2, and 3 were never a value of 0 simultaneously (which would have made the 
      entire expression FALSE).  However, subexpressions 2 and 3 both evaluated to TRUE at some point.
      </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.GUI.LOGIC.EXCL"
>Excluding/Including a Subexpression</A
></H2
><P
>    For any displayed subexpression within a statement, the user may choose to disregard the coverage information for 
    that subexpression by clicking on the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Excluded</B
></SPAN
> checkbutton on the right side of 
    the window.  If this option is checked, Covered will recalculate combinational logic summary coverage information 
    for the current module/instance by adding to the "Hit" count the number of uncovered combinational logic values for 
    the given subexpression (and all subexpressions below this expression within the expression tree).  This new 
    summary information will be redisplayed on the <A
HREF="#SECTION.GUI.MAIN.SUMCOV"
>The Summary Coverage Bar</A
>. The subexpression 
    background color in the top frame will also change from the uncovered background color to the covered background 
    color.  However, the subexpression will still contain an underline that may be clicked on at any time to view its 
    coverage information or the coverage information for any subexpressions that are uncovered.  To include a 
    previously excluded subexpression, simply uncheck the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Excluded</B
></SPAN
> checkbutton. This 
    will automatically cause the summary information and background color to be updated for the given subexpression. 
    <A
HREF="#FIGURE.GUI.LOGIC.EXCL"
>Exit Warning Window</A
> below shows an example of a subexpression that has been excluded from 
    coverage consideration.
    </P
><P
>      <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.LOGIC.EXCL"
></A
><P
><B
>Figure 20-8. Example of an excluded subexpression</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/exit_warn.gif"></P
></DIV
></DIV
>
    </P
><P
>    If an expression tree has been entirely excluded from coverage (all subexpressions have the 
    <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Excluded</B
></SPAN
> checkbutton checked), the background color in the 
    <A
HREF="#SECTION.GUI.MAIN.VIEWER"
>Coverage File Viewer</A
> will change from an uncovered background color to the covered background 
    color to indicate at the top-level that this entire statement has been excluded from coverage.  However, the 
    statement will still be underlined in the Main Coverage File Viewer to allow the user to view the statement, if 
    necessary.
    </P
><P
>    If the user excludes any subexpression in the design, the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Save CDD...</B
></SPAN
> option in 
    the <A
HREF="#SECTION.GUI.MAIN.FILEMENU"
>File</A
> menu will be enabled.  This allows the user to save the excluded 
    property either back to the CDD file (or to a newly named CDD file).  Doing so will allow the user to load the CDD 
    file at a different time and retain the knowledge of which subexpressions have been excluded/included for coverage. 
    Additionally, if a saved CDD file with coverage exclusion is merged with another CDD file, the excluded 
    subexpression information is preserved for the resulting merged CDD file.
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.GUI.LOGIC.DISPLAY"
>Displaying a New Statement</A
></H2
><P
>    If the Verbose Combinational Logic Coverage window is currently displayed with a statement, the user may select a 
    new statement in the <A
HREF="#SECTION.GUI.MAIN.VIEWER"
>Coverage File Viewer</A
> of the Mainwindow.  When a new statement is selected, 
    its value immediately replaces the currently selected statement.  This feature allows many different statements to 
    be viewed one after the other without having to create/destroy a new window for each.
    </P
><P
>    The user may also see the previous or next uncovered statement in the main viewer by clicking either the left arrow 
    button (for previous signal viewing) or the right arrow button (for next signal viewing).  Note that the left arrow 
    button will be disabled if there is not a signal previous to the current signal in the given module and the right
    arrow button will be disabled if there is not a signal after the current signal in the given module.
    </P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER.GUI.FSM"
></A
>Chapter 21. Navigating the FSM State/State Transition Coverage Window</H1
><P
>  The Verbose FSM State/State Transition Coverage window allows the user to see which states and state transitions of a 
  currently selected FSM have been covered or are uncovered.  To view this window, simply select the "FSM" coverage 
  metric mode in the <A
HREF="#SECTION.GUI.MAIN.COVBAR"
>The Coverage Type View Bar</A
> in the main window and select an underlined FSM state 
  variable in the <A
HREF="#SECTION.GUI.MAIN.VIEWER"
>Coverage File Viewer</A
>.  This will cause the FSM Coverage window to be displayed 
  with the currently selected FSM information loaded.  <A
HREF="#FIGURE.GUI.FSM"
>Verbose FSM Coverage Window</A
> below shows an example of this 
  window.
  </P
><P
>    <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.FSM"
></A
><P
><B
>Figure 21-1. Verbose FSM Coverage Window</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/fsm_window.gif"></P
></DIV
></DIV
>
  </P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.GUI.FSM.NAVIGATE"
>Navigating the FSM Window</A
></H2
><P
>    The Verbose FSM window is split into two main frames.  The top frame contains the expressions that make up the 
    input and output states of the selected FSM.  The bottom frame contains a two-dimensional table showing the covered 
    and/or uncovered states and state transitions.
    </P
><P
>    The state/state transition table is a two-dimensional table with all possible values of the input states in the 
    left-most column, the output states in the upper-most row, and the state transitions in the rest of the table.
    </P
><P
>    To determine which states have been uncovered in the table, simply find all state values in the input column or 
    output row (both show the same information) which are highlighted with the "Uncovered" color selection specified in 
    the <A
HREF="#CHAPTER.GUI.PREFERENCES"
>Navigating the Preferences Window</A
>. To determine which states have been covered in the table, simply 
    find all state values in the input column or output row which are highlighted with the "Covered" color selection. 
    All other state values which are not highlighted are either impossible values (if all of the state transitions were 
    specified in the Verilog file) or are unknown for coverage (if not all of the state transitions were specified in 
    the Verilog file).
    </P
><P
>    To determine which state transitions have been uncovered in the table, simply find all empty boxes in the table 
    that are highlighted with the "Uncovered" background color.  If one of these exist, it specifies that the 
    transition of "input state" (the value specified in the left-most column in the same row) to "output state" (the 
    value specified in the upper-most row in the same column) did not occur.  In the example above, we can see that the 
    following state transitions did not occur:
    </P
><P
>      <P
></P
><UL
><LI
><P
>1 -&gt; 2</P
></LI
><LI
><P
>3 -&gt; 1</P
></LI
><LI
><P
>2 -&gt; 3</P
></LI
><LI
><P
>2 -&gt; 2 (loopback case)</P
></LI
></UL
>
    </P
><P
>    Follow the same procedure for finding all covered state transitions in the table except that these boxes will be 
    highlighted with the "Covered" background color.  In the example above, we can see that the following state 
    transitions occurred:
    </P
><P
>      <P
></P
><UL
><LI
><P
>0 -&gt; 0 (loopback case)</P
></LI
><LI
><P
>0 -&gt; 1</P
></LI
><LI
><P
>1 -&gt; 3</P
></LI
><LI
><P
>3 -&gt; 0</P
></LI
></UL
>
    </P
><P
>    All other state transition boxes that are not highlighted are either impossible state transitions (if all state 
    transitions were specified in the Verilog source code) or are unknown in their coverage (either not hit or 
    impossible transition if all state transitions were not specified in the Verilog source code).
    </P
><P
>    To exit this window, simply click on <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Close</B
></SPAN
> button. To see this help page for the 
    FSM window, click on the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Help</B
></SPAN
> button.
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.GUI.FSM.EXCL"
>Excluding/Including a State Transition</A
></H2
><P
>    Uncovered state transitions can be excluded/included for FSM coverage consideration.  This is done by clicking on 
    the "I" (state transition is currently included in coverage results) or "E" (state transition is currently excluded 
    from coverage results) character in the middle of a state transition square.  Changing a state transition from an 
    "I" to an "E" will automatically cause the state transition summary coverage information in the 
    <A
HREF="#SECTION.GUI.MAIN.SUMCOV"
>The Summary Coverage Bar</A
> to be updated and the background color of the state transition box will 
    change from the uncovered color to the covered color.  Changing a state transition from an "E" to an "I" will 
    automatically cause the state transition summary coverage information in the Main Window Summary Bar to be updated 
    and the background color of the state transition box will change from the covered color to the uncovered color. 
    <A
HREF="#FIGURE.GUI.FSM.EXCL"
>Example of excluded state transitions</A
> below shows an example of the <A
HREF="#FIGURE.GUI.FSM"
>Verbose FSM Coverage Window</A
> state machine 
    coverage information with a couple of state transitions excluded from coverage.
    </P
><P
>      <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.FSM.EXCL"
></A
><P
><B
>Figure 21-2. Example of excluded state transitions</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/fsm_excl.gif"></P
></DIV
></DIV
>
    </P
><P
>    If all of the state transitions for a state machine have been excluded for coverage consideration, the output state 
    variable in the <A
HREF="#SECTION.GUI.MAIN.VIEWER"
>Coverage File Viewer</A
> will change its background from the uncovered to the 
    covered background color.  However, the underline will remain under the variable to allow the user to still examine 
    the verbose FSM information for that state machine.
    </P
><P
>    If the user excludes any state transition in the design, the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Save CDD...</B
></SPAN
> option in 
    the <A
HREF="#SECTION.GUI.MAIN.FILEMENU"
>File</A
> menu will be enabled.  This allows the user to save the excluded 
    property either back to the CDD file (or to a newly named CDD file).  Doing so will allow the user to load the CDD 
    file at a different time and retain the knowledge of which state transitions have been excluded/included for 
    coverage.  Additionally, if a saved CDD file with coverage exclusion is merged with another CDD file, the excluded 
    state transition information is preserved for the resulting merged CDD file.
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.GUI.FSM.DISPLAY"
>Displaying a New FSM</A
></H2
><P
>    If the Verbose FSM Coverage window is currently displayed, the user may select a new FSM state variable in the 
    <A
HREF="#SECTION.GUI.MAIN.VIEWER"
>Coverage File Viewer</A
> of the Main window. When a new FSM is selected, its information 
    immediately replaces the currently selected FSM.  This feature allows many different FSMs to be viewed one after 
    the other without having to create/destroy a new window for each.
    </P
><P
>    The user may also see the previous or next uncovered FSM in the main viewer by clicking either the left arrow 
    button (for previous signal viewing) or the right arrow button (for next signal viewing). Note that the left arrow 
    button will be disabled if there is not a signal previous to the current signal in the given module and the right 
    arrow button will be disabled if there is not a signal after the current signal in the given module.
    </P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER.GUI.ASSERT"
></A
>Chapter 22. Navigating the Assertion Coverage Window</H1
><P
>  The Verbose Assertion Coverage window allows the user to see exactly which coverage points were hit or missed for a 
  selected assertion instantiation in the design and, if hit, how many times the assertion coverage point (ACP) was hit 
  during simulation.  Additionally, this window allows you to bring up the <A
HREF="#CHAPTER.GUI.ASSERT.SOURCE"
>Navigating the Assertion Source Code Window</A
> 
  to view the internal assertion module code for the currently selected assertion instance. This lets the user view the 
  code to determine what logically needs to occur to hit a given ACP.
  </P
><P
>  To view this window, select the "Assert" mode in the <A
HREF="#SECTION.GUI.MAIN.COVBAR"
>The Coverage Type View Bar</A
> in the main window and 
  click on an underlined assertion instance name in the <A
HREF="#SECTION.GUI.MAIN.VIEWER"
>Coverage File Viewer</A
>. Note that both 
  covered and uncovered assertion instance names can be selected. Doing so will cause the Verbose Assertion Coverage 
  Window to be displayed for the selected assertion instantiation.  <A
HREF="#FIGURE.GUI.ASSERT"
>Verbose Assertion Coverage Window</A
> shows an example 
  of a zero_one_hot assertion that had the "test_expr_change covered" ACP covered (hit twice during simulation) and the 
  other two ACPs uncovered during simulation.
  </P
><P
>    <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.ASSERT"
></A
><P
><B
>Figure 22-1. Verbose Assertion Coverage Window</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/assert_window.gif"></P
></DIV
></DIV
>
  </P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.GUI.ASSERT.NAVIGATE"
>Navigating the Assertion Coverage Window</A
></H2
><P
>    The window is made up of a simple table which contains the coverage point names within the selected assertion on 
    the left and the number of times each of these coverage points were hit during simulation on the right. If a 
    coverage point has not been hit, both the coverage point name and the number of hits (0) will be highlighted with 
    the "uncovered" color selection as selected in the <A
HREF="#CHAPTER.GUI.PREFERENCES"
>Navigating the Preferences Window</A
>. If a coverage point 
    has been hit at least once, both the coverage point name and the number of hits will be highlighted with the 
    "covered" color selection as selected in the Preferences window.
    </P
><P
>    Below the table the name of the currently selected assertion type is named.  To view the source code for this 
    assertion, simply click on the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Show Code</B
></SPAN
> button at the bottom right-hand portion 
    of the coverage table.  This will cause the source code for this assertion to be displayed in a new 
    <A
HREF="#CHAPTER.GUI.ASSERT.SOURCE"
>Navigating the Assertion Source Code Window</A
>.
    </P
><P
>    To exit this window, simply click on <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Close</B
></SPAN
> button. To see this help page for the 
    assertion coverage window, click on the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Help</B
></SPAN
> button.
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.GUI.ASSERT.EXCL"
>Excluding/Including Assertion Coverage Points</A
></H2
><P
>    Individual ACPs can be excluded/included for coverage consideration using the verbose assertion coverage window. 
    This is accomplished by clicking on the "0" (ACP is currently included in coverage) or "E" (ACP is current excluded 
    from coverage) value in the "# of hits" column.  Changing an ACP from "0" to "E" (excluding the ACP from coverage 
    consideration) will cause the summary assertion coverage information to be recalculated and redisplayed in the 
    <A
HREF="#SECTION.GUI.MAIN.SUMCOV"
>The Summary Coverage Bar</A
> and the background color of the ACP will change from the uncovered to the 
    covered background color.  Changing an ACP from "E" to "0" (including the ACP for coverage consideration) will 
    cause the summary assertion coverage information to be recalculated and redisplayed in the Main Window Summary Bar 
    and background color of the ACP will change from the covered to the uncovered background color. 
    <A
HREF="#FIGURE.GUI.ASSERT.EXCLUDE"
>Example of excluded ACP</A
> below shows the above assertion instance with the last coverage point 
    excluded from coverage.
    </P
><P
>      <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.ASSERT.EXCLUDE"
></A
><P
><B
>Figure 22-2. Example of excluded ACP</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/assert_excl.gif"></P
></DIV
></DIV
>
    </P
><P
>    If all ACPs for a given assertion instance have been excluded from coverage consideration, the 
    <A
HREF="#SECTION.GUI.MAIN.VIEWER"
>Coverage File Viewer</A
> will automatically change the background color of the assertion instance 
    name from the uncovered to the covered background color.  The assertion instance name will still be underlined, 
    allowing the user to still see the coverage information for that given assertion instance.
    </P
><P
>    If the user excludes any ACP in the design, the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Save CDD...</B
></SPAN
> option in the 
    <A
HREF="#SECTION.GUI.MAIN.FILEMENU"
>File</A
> menu will be enabled.  This allows the user to save the excluded 
    property either back to the CDD file (or to a newly named CDD file).  Doing so will allow the user to load the CDD 
    file at a different time and retain the knowledge of which ACPs have been excluded/included for coverage. 
    Additionally, if a saved CDD file with coverage exclusion is merged with another CDD file, the excluded ACP 
    information is preserved for the resulting merged CDD file.
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.GUI.ASSERT.DISPLAY"
>Displaying a New Assertion Instance</A
></H2
><P
>    If the Verbose Assertion Coverage window is currently displayed, the user may select a new assertion in the 
    <A
HREF="#SECTION.GUI.MAIN.VIEWER"
>Coverage File Viewer</A
> of the Main window. When a new assertion is selected, its information 
    immediately replaces the currently selected assertion. This feature allows many different assertions to be viewed 
    one after the other without having to create/destroy a new window for each.
    </P
><P
>    The user may also see the previous or next uncovered assertion in the main viewer by clicking either the left arrow 
    button (for previous signal viewing) or the right arrow button (for next signal viewing).  Note that the left arrow 
    button will be disabled if there is not a signal previous to the current signal in the given module and the right 
    arrow button will be disabled if there is not a signal after the current signal in the given module.
    </P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER.GUI.ASSERT.SOURCE"
></A
>Chapter 23. Navigating the Assertion Source Code Window</H1
><P
>  The Assertion Source Viewer window allows the user to see the source code for the current assertion in the 
  <A
HREF="#CHAPTER.GUI.ASSERT"
>Navigating the Assertion Coverage Window</A
>. To view this window, simply click the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Show Code</B
></SPAN
> 
  button in the Verbose Assertion Coverage window. <A
HREF="#FIGURE.GUI.ASSERT.SOURCE"
>Assertion Source Viewer Window</A
> shows a zero_one_hot OVL 
  assertion code with syntax highlighting applied.
  </P
><P
>    <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.ASSERT.SOURCE"
></A
><P
><B
>Figure 23-1. Assertion Source Viewer Window</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/assert_src.gif"></P
></DIV
></DIV
>
  </P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.GUI.ASSERT.SOURCE.NAVIGATE"
>Navigating the Source Code</A
></H2
><P
>    The source code for the current assertion will be automatically displayed in the text viewer when the window is 
    created.  However, the source code will be displayed as it is found in the file system, without preprocessing 
    applied to it.  This means that included files will not be displayed in an in-lined fashion.  To view included 
    files, simply click on the included filename (it will be underlined).  This will cause the included file to replace 
    its includer in the text viewer.  An infinite number of includes may be traversed in this manner. To go back to the 
    file that included the current file, simply click on the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Back</B
></SPAN
> button located in 
    the bottom left-hand corner of the window. This will cause the current source code to be replaced with its "parent" 
    source code.
    </P
><P
>    Note that the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Back</B
></SPAN
> button will be disabled when the top-level assertion file is 
    currently displayed.
    </P
><P
>    To exit this window, simply click on <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Close</B
></SPAN
> button. To see this help page for the 
    assertion source code window, click on the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Help</B
></SPAN
> button.
    </P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER.GUI.GENREPORT"
></A
>Chapter 24. Navigating the ASCII Report Generator Window</H1
><P
>  When the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>File-&#62;Generate-&#62;ASCII Report</B
></SPAN
> menu option is selected, the ASCII Report 
  Generator Window is created to allow the user to view the current report output options, edit those options, and 
  create a name for the report file.  Once the report has been generated, this window will automatically close. The 
  resulting report file can be viewed with any text file viewer and is equivalent to a report file generated with a 
  "covered report ..." command-line call.  <A
HREF="#FIGURE.GUI.GENREPORT"
>The ASCII Report Generate Window</A
> shows an example of this window.
  </P
><P
>    <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.GENREPORT"
></A
><P
><B
>Figure 24-1. The ASCII Report Generate Window</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/report_gen.gif"></P
></DIV
></DIV
>
  </P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.GUI.GENREPORT.NAVIGATE"
>Navigating the Window</A
></H2
><P
>    The "Create ASCII report" window contains three frames which are described below.
    </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.GUI.GENREPORT.NAVIGATE.OPTIONS"
>Selected ASCII Report Options Frame</A
></H3
><P
>        <P
></P
><UL
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Level of Detail</B
></SPAN
></P
><P
>            This value indicates the amount of information that is output to the report file.  The possible values are: 
            'Summary', 'Detailed' or 'Verbose'. Please see <A
HREF="#SECTION.REPORT.SDV"
>Summary Vs. Detailed Vs. Verbose</A
> for details.
            </P
></LI
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Accumulated By</B
></SPAN
></P
><P
>            This value indicats how the coverage information will be accumulated:  on a per module basis or on a per 
            instance basis. The possible values are:  'Module' or 'Instance'. Please see 
            <A
HREF="#SECTION.REPORT.MI"
>Module Vs. Instance</A
> for more details.
            </P
></LI
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Show Metrics</B
></SPAN
></P
><P
>            This value indicates which coverage metrics will be reported in the ASCII report file. The possible values 
            are: 'Line', 'Toggle', 'Memory', 'Logic', 'FSM', 'Assertion' and/or 'Race Conditions'.
            </P
></LI
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Coverage Type</B
></SPAN
></P
><P
>            This value indicates whether uncovered or covered coverage cases will be reported to the file. The possible 
            values are: 'Uncovered' or 'Covered'.  Please see <A
HREF="#SECTION.REPORT.CU"
>Covered Vs. Uncovered</A
> for more details.
            </P
></LI
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Line Width</B
></SPAN
></P
><P
>            This value indicates whether Verilog code output in the report file will be output in the same manner as is 
            found in the source code or if a user-specified line width (in characters) should be used instead. This 
            option allows the user to make the report file more easily readable. The possible values are 'Preformatted' 
            (to indicate that the line widths should be preserved from the original source code) or 'X characters' 
            where X indicates an integer value greater than 0. Please see the "-w" option description in 
            <A
HREF="#SECTION.REPORT.OPTIONS"
>Report Options</A
> for more details.
            </P
></LI
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Suppress Empty Modules</B
></SPAN
></P
><P
>            This value indicates where module/instances that contain no coverage information should still be output to 
            the report (where they will indicate 100% coverage complete in the summary information for each metric).
            </P
></LI
></UL
>
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.GUI.GENREPORT.FILE"
>Save To File Frame</A
></H3
><P
>      The middle frame of the ASCII Report window allows the user to specify a filename/location for the generated 
      output file.  By default, the report name is the same as the first CDD file loaded, substituting the .cdd 
      extension for a .rpt extension. By default, the directory location to store the generated report is the same 
      directory that the first CDD file exists in. To change this name/location, the user may either enter a value in 
      the entry field or click on the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Browse...</B
></SPAN
> button to display a "Save As" type 
      window.
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.GUI.GENREPORT.BUTTON"
>Bottom Button Frame</A
></H3
><P
>      The button bar on the bottom of the window contains three buttons.  Clicking the 
      <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Create</B
></SPAN
> button will generate a report file using the specified options and 
      filename specified in the upper two frames of this window. After the report has been created, the window will 
      automatically close and the generated file can be viewed with any text viewer. Clicking the 
      <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Cancel</B
></SPAN
> button will not generate a report and will cause the window to close. 
      Clicking the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Help</B
></SPAN
> button will display this help page.
      </P
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER.GUI.PREFERENCES"
></A
>Chapter 25. Navigating the Preferences Window</H1
><P
>  The preferences window allows the user to adjust the view of some of the GUI elements for the purpose of more easily 
  analyzing coverage information for a specific user. <A
HREF="#FIGURE.GUI.PREF.MAIN"
>Main Preferences Window</A
> shows the preferences 
  window that is created when the user selects the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Tools &#62; Preferences...</B
></SPAN
> menu option 
  from the main window.
  </P
><P
>    <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.PREF.MAIN"
></A
><P
><B
>Figure 25-1. Main Preferences Window</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/pref_main.gif"></P
></DIV
></DIV
>
  </P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.GUI.PREF.CATEGORIES"
>Option Categories</A
></H2
><P
>    On the left side of the preferences window is a list of option categories that can be modified. Selecting any one 
    of the items in the listbox will display the modifiable options to the frame to the right of the listbox. The 
    following option categories exist:
    </P
><P
>      <P
></P
><UL
><LI
><P
><A
HREF="#SECTION.GUI.PREF.GENERAL"
>Preferences General Pane</A
></P
></LI
><LI
><P
><A
HREF="#SECTION.GUI.PREF.COLOR"
>Preferences Color Pane</A
></P
></LI
><LI
><P
><A
HREF="#SECTION.GUI.PREF.GOALS"
>Preference Coverage Goals Pane</A
></P
></LI
><LI
><P
><A
HREF="#SECTION.GUI.PREF.SYNTAX"
>Preferences Syntax Highlighting Pane</A
></P
></LI
><LI
><P
><A
HREF="#SECTION.GUI.PREF.REPORT"
>Preferences ASCII Report Options Pane</A
></P
></LI
></UL
>
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.GUI.PREF.BUTTONS"
>Preference Buttons</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="SECTION.GUI.PREF.BUTTONS.APPLY"
>Apply Button</A
></H3
><P
>      Clicking on the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Apply</B
></SPAN
> button will cause the currently selected preference 
      options to be immediately updated in Covered but will not update the preference option values in the .coveredrc 
      file.  This has the effect of changing the preferences for the current application only. Clicking on this button 
      will not close the Preferences window.
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.GUI.PREF.BUTTONS.OK"
>OK Button</A
></H3
><P
>      Clicking on the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>OK</B
></SPAN
> button will cause the currently selected preference options 
      to be immediately updated in Covered and will update the .coveredrc file with the new values. This also causes 
      the Preferences window to close.
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.GUI.PREF.BUTTONS.CANCEL"
>Cancel Button</A
></H3
><P
>      Clicking on the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Cancel</B
></SPAN
> button will cause the the Preferences window to close 
      without updating Covered with the currently selected values and without updating the .coveredrc file.
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.GUI.PREF.BUTTONS.HELP"
>Help Button</A
></H3
><P
>      Clicking on the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Help</B
></SPAN
> button will cause the help page for the currently selected 
      'Option Category'.
      </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.GUI.PREF.CONFIGFILE"
>Preferences Configuration File</A
></H2
><P
>    User preferences are loaded from the ".coveredrc" file that is searched for in the following order:
    </P
><P
>      <P
></P
><OL
TYPE="1"
><LI
><P
>Current directory that the 'covered report -view' command was executed from.</P
></LI
><LI
><P
>The user's home directory.</P
></LI
><LI
><P
>The installation directory (by default this is /usr/local/share/covered).</P
></LI
></OL
>
    </P
><P
>    If user preferences are changed in this window and the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>OK</B
></SPAN
> button is pressed, the 
    settings are immediately saved back to a configuration file and the GUI is immediately updated to reflect the new 
    user changes.  If the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Cancel</B
></SPAN
> button is pressed, all changes are thrown away and 
    the configuration file remains unchanged. The location of the stored configuration file depends on which 
    configuration file location was initially loaded. The following table describes this correlation.
    </P
><P
>      <DIV
CLASS="TABLE"
><A
NAME="AEN2674"
></A
><P
><B
>Table 25-1. Location of Written .coveredrc File According to the Location of Read .coveredrc File</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><THEAD
><TR
><TH
>Loaded config file location</TH
><TH
>Stored config file location</TH
></TR
></THEAD
><TBODY
><TR
><TD
>Current directory</TD
><TD
>Current directory</TD
></TR
><TR
><TD
>Home directory</TD
><TD
>Home directory</TD
></TR
><TR
><TD
>Install directory</TD
><TD
>Current directory</TD
></TR
><TR
><TD
>None found</TD
><TD
>Current directory</TD
></TR
></TBODY
></TABLE
></DIV
>
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.GUI.PREF.GENERAL"
>Preferences General Pane</A
></H2
><P
>    The general preferences pane allows the user to control Covered's settings that are not specific to an individual
    task.  The following subsections describe the controls available within this pane.
    </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.GUI.PREF.GENERAL.WIZARD"
>Wizard Popup on Startup</A
></H3
><P
>      This checkbutton selects if Covered's <A
HREF="#CHAPTER.GUI.WIZARD"
>Navigating the Wizard Window</A
> popup window will be displayed upon
      starting Covered.  Simply check this button if you would like to see the wizard at the beginning of each startup
      or uncheck it to cause the wizard window to not be displayed on startup. On the wizard window itself, there is
      an option to change this behavior as well.
      </P
><P
>      Note that you can always display the wizard window by selecting its menu option in the 
      <A
HREF="#SECTION.GUI.MAIN.VIEWMENU"
>The View Menu</A
> menu.
      </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.GUI.PREF.COLOR"
>Preferences Color Pane</A
></H2
><P
>    The color preference pane allows the user to adjust the foreground and background colors for all code that is 
    considered covered, uncovered, or in a race condition state.
    </P
><P
>      <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.PREF.COLOR"
></A
><P
><B
>Figure 25-2. The Color Preferences Pane</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/pref_color.gif"></P
></DIV
></DIV
>
    </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.GUI.PREF.COLOR.SET"
>Set Highlight Color</A
></H3
><P
>      This frame contains six buttons that affect the foreground and background colors used to highlight code in the 
      <A
HREF="#SECTION.GUI.MAIN.VIEWER"
>Coverage File Viewer</A
> portion of the main window. The currently selected foreground/background 
      colors are displayed to the left of the corresponding buttons to allow the user to see the selections prior to 
      committing to them by clicking the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Apply</B
></SPAN
> or <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>OK</B
></SPAN
> 
      buttons at the bottom of the Preferences window.
      </P
><P
>      The "F" button controls the foreground color while the "B" button controls the background color.  Clicking one
      of these buttons will bring up a color selection window that you can use to modify the current color to one of
      your choosing.
      </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.GUI.PREF.GOALS"
>Preference Coverage Goals Pane</A
></H2
><P
>    The coverage goals preference pane allows the user to change the acceptable coverage goals for each coverage metric.
    </P
><P
>      <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.PREF.GOALS"
></A
><P
><B
>Figure 25-3. Coverage Goals Window</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/pref_goals.gif"></P
></DIV
></DIV
>
    </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.GUI.PREF.GOALS.ACCEPTABLE"
>Set Acceptable Coverage Goals Frame</A
></H3
><P
>      This frame contains four spinner boxes that contains values between 0 and 100. These values correspond to a 
      coverage percentage for each coverage metric that the user deems to be "good enough". These values are used by 
      the <A
HREF="#SECTION.GUI.MAIN.LISTBOX"
>Module/Instance Listbox</A
> to help visually identify modules/instances that are meeting or 
      exceeding these goals and which modules are not meeting these goals. If a coverage percentage for a 
      module/instance is less than this value, the module is colored red. If the coverage percentage is greater than or 
      equal to this value, the module/instance is colored yellow (or green which indicates that the module/instance 
      reached 100% coverage for a given metric).
      </P
><P
>      To increase the specified percentage value, simply click on the "Up" button to the right of the percentage until 
      the desired value is displayed. To decrease the specified percentage value, simply click on the "down" button to 
      the right of the percentage until the desired value is displayed.
      </P
><P
>        <P
></P
><UL
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Line Coverage %</B
></SPAN
></P
><P
>            Sets the coverage goal of line coverage to the specified percentage to the right. If line coverage for a 
            given module/instance meets or exceeds this percentage value, it will be displayed yellow in the 
            Module/Instance listbox on the Main window.
            </P
></LI
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Toggle Coverage %</B
></SPAN
></P
><P
>            Sets the coverage goal of toggle coverage to the specified percentage to the right. If toggle coverage for 
            a given module/instance meets or exceeds this percentage value, it will be displayed yellow in the 
            Module/Instance listbox on the Main window.
            </P
></LI
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Memory Coverage %</B
></SPAN
></P
><P
>            Sets the coverage goal of memory coverage to the specified percentage to the right. If memory coverage for 
            a given module/instance meets or exceeds this percentage value, it will be displayed yellow in the 
            Module/Instance listbox on the Main window.
            </P
></LI
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Combinational Logic Coverage %</B
></SPAN
></P
><P
>            Sets the coverage goal of combinational coverage to the specified percentage to the right. If combinational 
            logic coverage for a given module/instance meets or exceeds this percentage value, it will be displayed 
            yellow in the Module/Instance listbox on the Main window.
            </P
></LI
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>FSM State/Arc Coverage %</B
></SPAN
></P
><P
>            Sets the coverage goal of FSM state/arc coverage to the specified percentage to the right. If FSM state/arc 
            coverage for a given module/instance meets or exceeds this percentage value, it will be displayed yellow in 
            the Module/Instance listbox on the Main window.
            </P
></LI
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Assertion Coverage %</B
></SPAN
></P
><P
>            Sets the coverage goal of assertion coverage to the specified percentage to the right. If assertion 
            coverage for a given module/instance meets or exceeds this percentage value, it will be displayed yellow in 
            the Module/Instance listbox on the Main window.
            </P
></LI
></UL
>
      </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.GUI.PREF.SYNTAX"
>Preferences Syntax Highlighting Pane</A
></H2
><P
>    The syntax highlighting preferences pane allows the user to adjust the syntax highlighting mode and colors for any 
    displayed Verilog source code.
    </P
><P
>      <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.PREF.SYNTAX"
></A
><P
><B
>Figure 25-4. Syntax Highlighting Preferences Pane</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/pref_syntax.gif"></P
></DIV
></DIV
>
    </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.GUI.PREF.SYNTAX.HIGHLIGHTING"
>Set Syntax Highlighting Options</A
></H3
><P
>      This frame allows the user to specify if syntax highlighting should be performed in all Verilog source viewers or 
      not. When the square to the left of the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Turn on syntax highlighting mode</B
></SPAN
> is 
      selected, syntax highlighting will occur; otherwise, it will not perform syntax highlighting. The various colored 
      buttons below the selection mode allow the user to select the foreground color of the text associated with its 
      specified syntax type (Comments, Preprocessor Keywords, Verilog Keywords, Strings, Constant Values, and Operation 
      Symbols). Simply click on one of the buttons to change its color. Doing so will cause a color selection window 
      (see <A
HREF="#FIGURE.GUI.PREF.SYNTAX"
>Syntax Highlighting Preferences Pane</A
> above) to be displayed.
      </P
><P
>      If the syntax highlighting mode is disabled by the user, the color selection buttons will be disabled.
      </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.GUI.PREF.REPORT"
>Preferences ASCII Report Options Pane</A
></H2
><P
>    The ASCII report preferences pane allows the user to modify the options passed to the ASCII report generator.
    </P
><P
>      <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.PREF.REPORT"
></A
><P
><B
>Figure 25-5. ASCII Report Preferences Pane</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/pref_report.gif"></P
></DIV
></DIV
>
    </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.GUI.PREF.REPORT.NAVIGATE"
>Navigating the Set ASCII Report Generation Options pane</A
></H3
><P
>      This pane contains six categories of options that can be modified for report generation purposes. These 
      categories are described below:
      </P
><P
>        <P
></P
><UL
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Limit line width</B
></SPAN
></P
><P
>           Be default, all Verilog code output in the report file will be displayed retaining the line breaks that are 
           found in the source code.  However, Covered allows the user to override this behavior by limiting the number 
           of characters that can be displayed on a line. To accept the default behavior, make sure that the 
           checkbutton to the left of this option is not checked. To override the default behavior, check the 
           checkbutton and enter a numerical value in the entry box that represents the maximum number of characters 
           allowed on a given line. Only valid numbers will be allowed to be entered in this field. Attempting to enter 
           a non-numerical value will cause a bell sound to occur and no value will be entered in the entry field.
           </P
></LI
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Suppress Modules/Instances from Output</B
></SPAN
></P
><P
>           By default, all modules simulated for coverage will appear in reports for all selected metrics; however, for 
           modules/instances that contain no coverage information, their appearance in the coverage reports can add 
           more information than is necessary. If the user wants to omit any modules/instances that contain no coverage 
           information (either covered or uncovered), select this option.
           </P
></LI
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Level of Detail</B
></SPAN
></P
><P
>           This set of options allows the user to generate a summary report, a detailed report (more descriptive than 
           the summary window but less terse than a verbose report) or a verbose report. Only one of these options can 
           be selected at a given time. To change the level of detail provided in the report, simply click on the 
           button to the left of the associated option.
           </P
></LI
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Accumulate By</B
></SPAN
></P
><P
>           This category allows the user to report coverage on a per module or instance basis. Module accumulation 
           takes all instances of the same module and merges their coverage information together to give the user an 
           idea of which logic within a module has been tested. Instance accumulation reports the coverage individually 
           for each instance, allowing the user to see which logic for each instance has been tested. Only one of these 
           options can be selected at a given time. To change the accumulation algorithm for the report, simply click 
           on the radiobutton to the left of the associated option.
           </P
></LI
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Show Metrics</B
></SPAN
></P
><P
>           This category contains a list of all of the metrics to output in the ASCII coverage report. Each metric can 
           be invidually selected/deselected using the checkbutton to the left of each option.
           </P
></LI
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Coverage Type</B
></SPAN
></P
><P
>           The coverage type category allows the user to generate a report that shows all uncovered or all covered 
           coverage cases. Uncovered information is useful for understanding which logic is untested. Covered 
           information is useful for understanding what logic Covered is examining. Only one of the options can be 
           selected at a given time. To change the coverage type for the report, simply click on the radiobutton to the 
           left of the associated option.
           </P
></LI
></UL
>
      </P
><P
>      When the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Apply</B
></SPAN
> or <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>OK</B
></SPAN
> button is clicked at the 
      bottom of the preferences window, the ASCII reporting options will be updated in the 
      <A
HREF="#CHAPTER.GUI.GENREPORT"
>Navigating the ASCII Report Generator Window</A
> if that window is currently being displayed.
      </P
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER.GUI.WIZARD"
></A
>Chapter 26. Navigating the Wizard Window</H1
><P
>  The Wizard window starts up automatically at the start of the Covered GUI.  It allows the user to quickly perform
  some of the more regular tasks within the GUI. The window is not necessary for performing these tasks, but for the
  new user it makes figuring out how to perform these tasks a bit easier.  <A
HREF="#FIGURE.GUI.WIZARD"
>Covered GUI Wizard Window</A
> shows the
  layout of this window.
  </P
><P
>    <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.WIZARD"
></A
><P
><B
>Figure 26-1. Covered GUI Wizard Window</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/wizard.gif"></P
></DIV
></DIV
>
  </P
><P
>  The buttons at the top of the window are shortcuts to performing the tasks displayed on the button.  Clicking the
  associated button will cause a window to open to perform the given task.  The following are the available shortcut
  buttons:
  </P
><P
>    <P
></P
><UL
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Generate New CDD File</B
></SPAN
></P
><P
>        Allows the user to create a new CDD file for a given design by specifying the various scoring options needed
        to create the CDD file.
        </P
></LI
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Open/Merge CDD File(s)</B
></SPAN
></P
><P
>        Opens a CDD file for coverage viewing.  If one or more CDD files have previously been opened, this option
        opens and merges one or more CDD files with the coverage results of the previous CDD files for coverage viewing.
        </P
></LI
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Rank CDD Files</B
></SPAN
></P
><P
>        Allows the user to specify CDD files that will be compared with one another and ranked in the order that they
        should be run in a regression to achieve the most coverage in the least amount of time.  It also indicates which
        CDD files do not add any interesting coverage information and could, therefore, be excluded from regression for
        the purposes of code coverage.
        </P
></LI
></UL
>
  </P
><P
>  At the bottom of the wizard window, there is a checkbutton option that allows the user to not display the wizard
  window on startup.  This option can be changed in the <A
HREF="#SECTION.GUI.PREF.GENERAL"
>Preferences General Pane</A
> at any time.
  </P
><P
>  When the wizard window is closed, it can be redisplayed by clicking on the 
  <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>View -&#62; Wizard...</B
></SPAN
> menu item.  The window will automatically be closed when a button
  on the wizard window is clicked or when the user closes the window with the window manager's "X" button.
  </P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER.GUI.NEW"
></A
>Chapter 27. Creating a New CDD</H1
><P
>  Creating a new CDD file from the GUI can be accomplished by either clicking on the "Generate New CDD File" button in
  the Wizard window (see <A
HREF="#CHAPTER.GUI.WIZARD"
>Navigating the Wizard Window</A
> for more details on this window), by selecting the
  <FONT
COLOR="RED"
>File -&#62; Generate -&#62; New CDD...</FONT
> menu option, or using the shortcut "Shift-Control-N".  This file creation
  "wizard" allows the user to create a new CDD file that can be opened/merged into the GUI for coverage analysis.  The
  methods that the CDD creation GUI allows for creating a new CDD file are quite flexible and are completely compatible
  with the command-line commands.
  </P
><P
>  The following subsections describe the various windows used to create a GUI.  Note that the CDD creation wizard
  uses several "pages" to describe the various options to set for creating a new CDD file, using "Back" and "Next" 
  buttons on each page for navigation.  Clicking on the "Back" button will not cause previously filled in pages to be
  reverted to their default values but rather will remain populated with the user's data. Similarly, if a page has been
  filled in with data and the "Back" button is clicked and then the "Next" button is clicked, the page contents are
  retained.  The only way to clear out fields is to click the "Cancel" button at the bottom of each page and startup
  the CDD creation wizard again.
  </P
><P
>  Clicking the "Cancel" button at any time will cause the CDD creation wizard to immediately exit.  Clicking on the
  "Help" button at any time will bring up the user documentation for the current page (context sensitive help).
  </P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.GUI.NEW.SELECT"
>Navigating the New CDD Creation Option Selection Window</A
></H2
><P
>    Figure <A
HREF="#FIGURE.GUI.NEW.SELECT"
>CDD Creation Option Selection Page</A
> shows the look of this page of the CDD creation wizard.
    </P
><P
>      <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.NEW.SELECT"
></A
><P
><B
>Figure 27-1. CDD Creation Option Selection Page</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/new_cdd_selection.gif"></P
></DIV
></DIV
>
    </P
><P
>    The first page of the CDD creation window allows the user to select whether all options should be interactiely
    selected within the GUI or if a file should be read in which contains command-line options to the score command
    to use.  If the latter is chosen, the contents of that file are read in and are populated in the GUI, but the
    CDD creation wizard will continue in the same fashion as the first option, allowing the user to change, remove or
    add to the options found in that file.
    </P
><P
>    If the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Create CDD by interactively selecting options</B
></SPAN
> entry is currently selected 
    and the user wishes to not use a command-line file to populate the rest of the CDD creation pages, simply click on 
    the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Next</B
></SPAN
> button at the bottom of the page to continue.  If the 
    <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Create CDD by using option file</B
></SPAN
> entry is currently selected, the user must either 
    type a valid filename or select one by clicking the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Browse...</B
></SPAN
> button to the right 
    of the file entry area and select a valid file. Once a valid filename is selected, the 
    <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Next</B
></SPAN
> button will be enabled and the user may then click it to continue to the next 
    page. Note that any filename can be selected (whether it's a valid command file or not).  Only valid score command 
    options found in that file are used to populate the wizard entries. No error message will be displayed if the file 
    does not contain this information.
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.GUI.NEW.NAME"
>Navigating the New CDD Creation CDD Name Page</A
></H2
><P
>    This page is used to specify the name of the output CDD file.  Figure <A
HREF="#FIGURE.GUI.NEW.NAME"
>CDD Creation Output Name Page</A
> shows 
    the display of this page.
    </P
><P
>      <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.NEW.NAME"
></A
><P
><B
>Figure 27-2. CDD Creation Output Name Page</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/new_cdd_name.gif"></P
></DIV
></DIV
>
    </P
><P
>    The output CDD name must be specified and, as such, the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Next</B
></SPAN
> button is disabled
    until a name is specified in the entry field.  Any filename is allowed.  If the user wishes to make use of a
    "Save As" style window for creating a filename, click the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Browse...</B
></SPAN
> button and use
    the window for creating a filename. When the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Save</B
></SPAN
> button is clicked, the specified
    filename is placed in the entry field and the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Next</B
></SPAN
> button is enabled.
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.GUI.NEW.TYPE"
>CDD Creation Type Page</A
></H2
><P
>    This page is used to specify what type of CDD file to create. The three types CDD files that can be created are:
    </P
><P
>      <P
></P
><OL
TYPE="1"
><LI
><P
>          An unscored CDD file that was created by parsing the design. This CDD file can later be scored via a VCD or
          LXT dumpfile. 
          </P
><P
>          This option can be chosen by selecting the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Parse Design Only</B
></SPAN
> radiobutton.
          </P
></LI
><LI
><P
>          A scored CDD file created from the design and from a previously created VCD or LXT dumpfile. 
          </P
><P
>          This option can be chosen by selecting the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Dumpfile:</B
></SPAN
> option. If this option 
          is chosen, a VCD or LXT dumpfile is required to be specified before the next option page can be used. Either 
          specify this dumpfile name by typing in an existing dumpfile name in the entry field or use the 
          <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Browse...</B
></SPAN
> button to select a dumpfile.
          </P
></LI
><LI
><P
>          An unscored CDD file, a top-level Verilog file containing a PLI call to run Covered in VPI mode, and a PLI
          tab file that can be used by some simulators for compilation purposes. See <A
HREF="#SECTION.VPI"
>What is needed for VPI scoring?</A
> for
          details on how to use these files for simulation/scoring purposes. 
          </P
><P
>          This option can be chosen by selecting the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>VPI Module:</B
></SPAN
> radiobutton. If this 
          option is chosen, the name specified will be the name of the module created that is used to allow Covered
          to run in VPI mode within a simulation.
          </P
><P
>          In addition to providing a module name when this option is selected, the simulator type that will be used
          when scoring can be specified as well as the timescale information that can, optionally, be specified at the
          top of the generated module.
          </P
></LI
></OL
>
    </P
><P
>    Figure <A
HREF="#FIGURE.GUI.NEW.TYPE"
>CDD Creation Type Page</A
> displays the contents of this page. When all necessary fields have been
    specified, the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Next</B
></SPAN
> button will be enabled and clicking it will lead to the next
    option page.
    </P
><P
>      <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.NEW.TYPE"
></A
><P
><B
>Figure 27-3. CDD Creation Type Page</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/new_cdd_type.gif"></P
></DIV
></DIV
>
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.GUI.NEW.OPTIONS1"
>CDD Creation Options1 Page</A
></H2
><P
>    This page is used to specify several options to Covered's score command. See figure 
    <A
HREF="#FIGURE.GUI.NEW.OPTIONS1"
>CDD Creation Options1 Page</A
> for the layout of this window.
    </P
><P
>      <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.NEW.OPTIONS1"
></A
><P
><B
>Figure 27-4. CDD Creation Options1 Page</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/new_cdd_options.gif"></P
></DIV
></DIV
>
    </P
><P
>    The following is a description about each of the CDD creation options available on this page.
    </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.GUI.NEW.OPTIONS1.GENERAL"
>General Options</A
></H3
><P
>        <P
></P
><UL
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Toplevel module name</B
></SPAN
></P
><P
>Required? <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Yes</I
></SPAN
></P
><P
>            The name of the top-level module must be specified for a given design to be parsed and a CDD generated from
            that source.  Simply type in the name of the top-most module in the provided entry field.  Once a name
            is provided, the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Next</B
></SPAN
> button will be enabled to allow traversal to the
            next option page.
            </P
></LI
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Root pathname</B
></SPAN
></P
><P
>Required? <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>No</I
></SPAN
></P
><P
>            This entry field is an optional one to fill. This value is only necessary if the top-most module to be
            scored is not the top-most module of the simulator. If this is true, then the value that must be provided
            in the associated entry field must be the hierarchical reference to the module to be scored.
            </P
><P
>            An example of a valid root pathname would be something like:  <FONT
COLOR="RED"
>top.foo.bar.dut</FONT
>
            </P
><P
>            See <A
HREF="#SECTION.SCORE.T"
>Specifying What to Cover</A
> for more information.
            </P
></LI
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Delay Type</B
></SPAN
></P
><P
>            This value specifies which delay should be used when a delay type of #(delay_max:delay_typ:delay_min) is
            encountered in the scored design. If this type of delay specification is not encountered, there is no need
            to change this value in the GUI. If the delay specification is encountered in the design and this value has
            not been specified, the default of <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>typ</I
></SPAN
> will be used. Otherwise, the user can specify
            which delay value should be chosen by changing the displayed type to either <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>max</I
></SPAN
>,
            <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>typ</I
></SPAN
>, or <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>min</I
></SPAN
>.
            </P
></LI
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Race Condition Action</B
></SPAN
></P
><P
>            After the design has been parsed and elaborated, Covered performs a static race condition check on the
            design to verify that no potential race conditions exist. If a race condition exists in the design, this
            would cause the coverage results to potentially be errant.
            </P
><P
>            This parameter allows the user to tell Covered what to do if a race condition is found in the design. The
            valid values are:
            </P
><P
>              <P
></P
><UL
><LI
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Silent</I
></SPAN
></P
><P
>                  Specifies that no output should be generated. Any blocks with race conditions existing within them
                  will be automatically removed from coverage consideration.
                  </P
></LI
><LI
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Warning</I
></SPAN
></P
><P
>                  Specifies that race condition should be output and those blocks containing the race condition will
                  be automatically removed from coverage consideration.
                  </P
></LI
><LI
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Error</I
></SPAN
></P
><P
>                  Causes Covered to display the race condition violations and stop scoring after all race condition
                  checking has occurred.
                  </P
></LI
><LI
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Ignore</I
></SPAN
></P
><P
>                  Causes Covered to skip race condition checking completely. This option can be used if the user is
                  confident that no real race conditions exist in the design but Covered's static race condition checker
                  is displaying potential problems. If no race conditions actually exist, ignoring race condition
                  checking results allows more of the design to be considered for coverage.
                  </P
></LI
></UL
>
            </P
></LI
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Use embedded race condition pragmas</B
></SPAN
></P
><P
>            If this option is selected, a user-specified pragma ("racecheck" by default) is parsed and any potential 
            race conditions found between the off/on pragma pair are ignored by the race condition checker.
            </P
><P
>            See <A
HREF="#SECTION.RACE.AVOIDING"
>Avoiding Race Condition Checking</A
> for more details.
            </P
></LI
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Default Verilog Generation</B
></SPAN
></P
><P
>            Covered's parser supports parsing for Verilog-1995, Verilog-2001 and SystemVerilog, defaulting its parser to
            support SystemVerilog. However, for older designs which may contain names that are keywords in the newer
            versions, it may be necessary to change the parser of Covered for the entire design. This option specifies
            the version of the parser which is used for the entire design.
            </P
><P
>            For informatin regarding the ability to specify a certain version of the parser for a specific module,
            see <A
HREF="#SECTION.GUI.NEW.OPTIONS2.MODGEN"
>CDD Creation Module Generation Option</A
>.
            </P
></LI
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Include OVL Assertions</B
></SPAN
></P
><P
>            If this option is selected, any OVL assertion modules found within the scored design will have assertion
            coverage information extracted from them.
            </P
></LI
></UL
>
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.GUI.NEW.OPTIONS1.EXCLUDE"
>Exclude Options</A
></H3
><P
>        <P
></P
><UL
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Exclude Always Blocks</B
></SPAN
></P
><P
>            If this option is selected, all <FONT
COLOR="RED"
>always</FONT
> code blocks will be excluded from coverage
            consideration.
            </P
></LI
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Exclude Assign Blocks</B
></SPAN
></P
><P
>            If this option is selected, all <FONT
COLOR="RED"
>assign</FONT
> code blocks will be excluded from coverage
            consideration.
            </P
></LI
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Exclude Initial Blocks</B
></SPAN
></P
><P
>            If this option is selected, all <FONT
COLOR="RED"
>initial</FONT
> code blocks will be excluded from coverage
            consideration.
            </P
></LI
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Exclude Final Blocks</B
></SPAN
></P
><P
>            If this option is selected, all <FONT
COLOR="RED"
>final</FONT
> code blocks will be excluded from coverage consideration.
            </P
></LI
><LI
><P
><SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Exclude Within Pragma</B
></SPAN
></P
><P
>            If this option is selected, all code blocks will be excluded between the exclusion off/on pragmas. The name
            of the exclusion pragma is defaulted to "coverage" but can be changed within the associated entry field.
            </P
><P
>            See <A
HREF="#SECTION.SCORE.EP"
>Using the -ep Option for Exclusion</A
> for more information.
            </P
></LI
></UL
>
      </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.GUI.NEW.OPTIONS2"
>CDD Creation Options2 Page</A
></H2
><P
>    The second CDD creation options page contains a listbox which will contain the various user-specified options
    that have been inserted via the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Insert...</B
></SPAN
> menubutton. Any options that exist
    within this listbox can be edited by selecting the option and clicking on the 
    <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Edit...</B
></SPAN
> button or deleted by clicking on the 
    <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Delete</B
></SPAN
> button. Additionally, options may be reorganized within the listbox by
    simply clicking on an option and dragging it into the needed position. See figure 
    <A
HREF="#FIGURE.GUI.NEW.OPTIONS2"
>CDD Creation Options2 Page</A
> for the layout of this option page.
    </P
><P
>      <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.NEW.OPTIONS2"
></A
><P
><B
>Figure 27-5. CDD Creation Options2 Page</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/new_cdd_options2.gif"></P
></DIV
></DIV
>
    </P
><P
>    To add an option to the listbox, simply click on the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Insert...</B
></SPAN
> menubutton which
    will display a list of options. Select one of these options to display a window where the contents of that option
    can be specified. Clicking the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>OK</B
></SPAN
> button in one of those windows will cause the
    option to be added to the option listbox. Clicking <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Cancel</B
></SPAN
> in one of those windows
    will cause the option to not be added to the listbox. Clicking <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Help</B
></SPAN
> will display
    context-sensitive help information to be displayed about the current window.
    </P
><P
>    Figure <A
HREF="#FIGURE.GUI.NEW.OPTIONS2.INSMENU"
>CDD Creation Insert Menubutton</A
> shows the contents of the 
    <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Insert...</B
></SPAN
> menubutton. The following sections describe each option and its
    corresponding entry window.
    </P
><P
>      <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.NEW.OPTIONS2.INSMENU"
></A
><P
><B
>Figure 27-6. CDD Creation Insert Menubutton</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/new_cdd_insert_menu.gif"></P
></DIV
></DIV
>
    </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.GUI.NEW.OPTIONS2.SOURCE"
>Source File...</A
></H3
><P
>      TBD
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.GUI.NEW.OPTIONS2.LIBDIR"
>Library Directory...</A
></H3
><P
>      TBD
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.GUI.NEW.OPTIONS2.LIBEXT"
>Library Extension(s)...</A
></H3
><P
>      TBD
      </P
><P
>        <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.NEW.OPTIONS2.LIBEXT"
></A
><P
><B
>Figure 27-7. CDD Creation Library Extension Window</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/new_cdd_lib_ext.gif"></P
></DIV
></DIV
>
      </P
><P
>      TBD
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.GUI.NEW.OPTIONS2.INCDIR"
>Include Directory...</A
></H3
><P
>      TBD
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.GUI.NEW.OPTIONS2.DEFINE"
>Define...</A
></H3
><P
>      TBD
      </P
><P
>        <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.NEW.OPTIONS2.DEFINE"
></A
><P
><B
>Figure 27-8. CDD Creation Define Window</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/new_cdd_define.gif"></P
></DIV
></DIV
>
      </P
><P
>      TBD
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.GUI.NEW.OPTIONS2.PARAM"
>Parameter Override...</A
></H3
><P
>      TBD
      </P
><P
>        <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.NEW.OPTIONS2.PARAM"
></A
><P
><B
>Figure 27-9. CDD Creation Parameter Override Window</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/new_cdd_parm_oride.gif"></P
></DIV
></DIV
>
      </P
><P
>      TBD
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.GUI.NEW.OPTIONS2.FSM"
>FSM...</A
></H3
><P
>      TBD
      </P
><P
>        <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.NEW.OPTIONS2.FSM"
></A
><P
><B
>Figure 27-10. CDD Creation FSM Specification Window</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/new_cdd_fsm.gif"></P
></DIV
></DIV
>
      </P
><P
>      TBD
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.GUI.NEW.OPTIONS2.MODGEN"
>Module Generation...</A
></H3
><P
>      TBD
      </P
><P
>        <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.NEW.OPTIONS2.MODGEN"
></A
><P
><B
>Figure 27-11. CDD Creation Module Generation Window</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/new_cdd_mod_gen.gif"></P
></DIV
></DIV
>
      </P
><P
>      TBD
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.GUI.NEW.OPTIONS2.MODEXCL"
>Module Exclusion...</A
></H3
><P
>      TBD
      </P
><P
>        <DIV
CLASS="FIGURE"
><A
NAME="FIGURE.GUI.NEW.OPTIONS2.MODEXCL"
></A
><P
><B
>Figure 27-12. CDD Creation Module Exclusion Window</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="img/new_cdd_mod_excl.gif"></P
></DIV
></DIV
>
      </P
><P
>      TBD
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.GUI.NEW.OPTIONS2.CMDFILE"
>Command File...</A
></H3
><P
>      TBD
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3121"
>Other Notes</A
></H3
><P
>      After all options have been specified, the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Save Options to File...</B
></SPAN
> button can
      be clicked to cause all previously specified options to be saved to a file which can later be loaded by the new
      CDD creation window. Simply click the button and specify a filename to save the options under and click the
      <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Save</B
></SPAN
> button.
      </P
><P
>      When all options have been setup, click the <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Generate</B
></SPAN
> button to create the new CDD
      file. This button will advance to another page containing the output from Covered's score command.
      </P
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="PART"
><A
NAME="AEN3128"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
>V. FAQ</H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>28. <A
HREF="#CHAPTER.FAQ"
>FAQ</A
></DT
></DL
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER.FAQ"
></A
>Chapter 28. FAQ</H1
><P
>  This page contains a list of accummulated Frequently Asked Questions. If you are having difficulties using Covered or have questions that are not answered in the 
  User's Guide, please check this list for answers. If you do not find the information that you are looking for in the User's Guide or this FAQ, please send an e-mail 
  to:
  </P
><P
>    <CODE
CLASS="EMAIL"
>&#60;<A
HREF="mailto:phase1geo@gmail.com"
>phase1geo@gmail.com</A
>&#62;</CODE
>
  </P
><DIV
CLASS="QANDASET"
><DL
><DT
>1. <A
HREF="#AEN3137"
>          <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Is a CDD file generated from a newer version of Covered compatible with a CDD file generated from an older version?</B
></SPAN
>
        </A
></DT
><DT
>2. <A
HREF="#AEN3144"
>          <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>When I run the score command, Covered seems to take a long time to run. Is there anything that I can do to speed up scoring?</B
></SPAN
>
        </A
></DT
><DT
>3. <A
HREF="#AEN3174"
>          <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>I get an assertion error when running Covered, what should I do?</B
></SPAN
>
        </A
></DT
><DT
>4. <A
HREF="#AEN3182"
>          <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Covered is giving me a parser error for Verilog code that seems to be syntactically correct. What is wrong?</B
></SPAN
>
        </A
></DT
><DT
>5. <A
HREF="#AEN3188"
>          <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Is Covered's Verilog parser Verilog-2001 compliant?</B
></SPAN
>
        </A
></DT
><DT
>6. <A
HREF="#AEN3194"
>          <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>What is the difference between the stable release and the development release?</B
></SPAN
>
        </A
></DT
></DL
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN3137"
></A
><B
>1. </B
>          <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Is a CDD file generated from a newer version of Covered compatible with a CDD file generated from an older version?</B
></SPAN
>
        </P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
> </B
>        The answer to this question is, "Well, that depends...". Since the format of the CDD file is only used by Covered, the contents and format of this file may be 
        changed to suit the needs of Covered. This means that it is possible for a CDD file created from an older version of Covered to be incompatible with a newer 
        version. Additionally, the developers of Covered will not make any attempts to make sure that older CDD files can be properly read by a newer version of 
        Covered. It is suggested that any CDD files generated from a particular version of Covered be merged and/or reported on by that same version, and if Covered is 
        upgraded, new CDD files should be generated.
        </P
><P
>        This being said, it is also a possibility that between versions of Covered a "backwards compatibility" may be maintained if a change to this file's format is 
        not required.
        </P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN3144"
></A
><B
>2. </B
>          <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>When I run the score command, Covered seems to take a long time to run. Is there anything that I can do to speed up scoring?</B
></SPAN
>
        </P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
> </B
>        While Covered is continuously being enhanced to provide better performance for all commands (especially the score command), it may still take a while to 
        complete scoring if one or more of the following is true:
        </P
><P
>          <P
></P
><OL
TYPE="1"
><LI
><P
>The design being scored is sufficiently large</P
></LI
><LI
><P
>The VCD/LXT dumpfile is sufficiently large</P
></LI
><LI
><P
>The VCD/LXT dumpfile contains dump information for a part of the design not being scored</P
></LI
><LI
><P
>When Covered was configured, the --enable-debug and/or --enable-profiling options were specified</P
></LI
></OL
>
        </P
><P
>        If reason (1) is true, speeding up each run can be achieved by one of the following suggestions:
        </P
><P
>          <P
></P
><UL
><LI
><P
>              Reduce the scored design in size by eliminating modules or constructs from its design tree. (See <A
HREF="#SECTION.SCORE.T"
>Specifying What to Cover</A
>&#62; for more information 
              on how to accomplish this)
              </P
></LI
><LI
><P
>              Split up the design into smaller parts along module boundaries and generate coverage for those parts.
              </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>                It is not currently possible to append these modules into one file. Merging and reporting must be done on these smaller pieces independently from one 
                another.
                </P
></BLOCKQUOTE
></DIV
></LI
></UL
>
        </P
><P
>        If reason (2) is true, nothing can be done except to shorten the run time of the diagnostics to produce shorter dumpfiles.
        </P
><P
>        If reason (3) is true, the $dumpvars call in the simulator should be modified to only generate VCD/LXT dump information for the modules included in scoring. If 
        there are modules not being scored which are included in the $dumpvars calls, please remove these unnecessary modules from dumpfile output.
        </P
><P
>        If reason (4) is true, Covered should be reconfigured without these options specified. The debugging and profiling facilities are enormous performance degraders 
        and immediate simulation performance enhancement will be seen if Covered is rebuilt without these options specified.
        </P
><P
>        If you believe that you have a situation which is void of these prevailing reasons and Covered is still running slowly, please send an e-mail to me. I will 
        consider these problems to be of lower priority than actual bugs but will look into the situation to see where code can be optimized.
        </P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN3174"
></A
><B
>3. </B
>          <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>I get an assertion error when running Covered, what should I do?</B
></SPAN
>
        </P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
> </B
>        Covered uses C assertions to make sure that internal pointers are not be referenced when NULL and that certain internal situations do not arise. If you receive 
        some type of assertion error when running Covered, it means that something went wrong internally in Covered. The error is NOT due to user error. Please submit a 
        bug report containing the assertion error message, file and line number. Additionally, run the Covered command with the -D global option (covered -D 
        <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>command</I
></SPAN
>) and provide the output from doing this with the bug report (please only specify tail of output if the output is too lengthy).
        </P
><P
>        If Covered provides any other type of error message (something other than a core dump), Covered has found a user error that must be fixed by the user. Please do 
        not submit bug reports if these errors are encountered, unless you wish to add a question about it to the FAQ.
        </P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN3182"
></A
><B
>4. </B
>          <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Covered is giving me a parser error for Verilog code that seems to be syntactically correct. What is wrong?</B
></SPAN
>
        </P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
> </B
>        If Covered displays a syntax (parse) error during the score command and the Verilog code is written correctly, it is because Covered's parser is incomplete. 
        Please submit a bug or send an e-mail containing a code snippet of the unsupported Verilog.
        </P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN3188"
></A
><B
>5. </B
>          <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>Is Covered's Verilog parser Verilog-2001 compliant?</B
></SPAN
>
        </P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
> </B
>        This is currently being worked on. The parser should properly parse all code; however, not all Verilog-2001 constructs are considered for coverage due to lack 
        of support for them in Covered's core. If there is code that will not parse that should, please submit a bug report for this.
        </P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN3194"
></A
><B
>6. </B
>          <SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>What is the difference between the stable release and the development release?</B
></SPAN
>
        </P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
> </B
>        Covered's development consists of two active "branches": the stable branch and the development branch. When a new stable branch is created (ex. 0.4 or 0.5), it 
        represents the latest version of the development branch. As Covered's development branch is worked on (adding new features, changes to the core, etc.), the 
        stable branch remains in a feature frozen stage. Only bug fixes, documentation updates or minor enhancements (changes that will not affect the core code) are 
        made to the stable branch. When a number of these changes have been accumulated on the stable branch, a snapshot of the stable branch is made available for 
        public download (ex. 0.4.1). User's of the stable release should expect no major feature changes from minor rev to minor rev and should expect a somewhat 
        polished version of the project (few if any bugs and correct user documentation).
        </P
><P
>        User's of the development releases should expect to see more bugs and fewer documentation consistencies (although an attempt is made to minimize both) but 
        should expect lots of feature additions, optimizations, improvements, etc. from release to release. Bug findings found in the stable release are applied to the 
        development branch when applicable. It is important to note that both the stable and development releases contain a regression testbench that must fully pass 
        before either release is made. This should minimize bugs in both releases and give user's of either branch a level of confidence that the release is usable.
        </P
></DIV
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="PART"
><A
NAME="AEN3200"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
>VI. Epilogue</H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>29. <A
HREF="#CHAPTER.EPILOGUE"
>Epilogue</A
></DT
></DL
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER.EPILOGUE"
></A
>Chapter 29. Epilogue</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="SECTION.EPI.AUTHOR"
>Author</A
></H2
><P
>    Covered is programmed and documented by Trevor Williams (<CODE
CLASS="EMAIL"
>&#60;<A
HREF="mailto:phase1geo@gmail.com"
>phase1geo@gmail.com</A
>&#62;</CODE
>)
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.EPI.THANKS"
>Special Thanks</A
></H2
><P
>    I would like to acknowledge certain individuals for their help in making Covered the tool that it is today.
    </P
><P
>      <P
></P
><UL
><LI
><P
>          Ed Spittles - Thank you for your tireless efforts in logging bugs, providing suggestions on enhancements/optimizations (including the tip on using 
          of FIFOs to replace VCD/LXT file usage), your input into scoring optimizations for vectors and CDD ranking, and for allowing me access to needed 
          information for fixing those "hard to reproduce" bugs.
          </P
></LI
><LI
><P
>          Clifford E. Cummings - provided race condition checking rules and clarifications about those rules.
          </P
></LI
><LI
><P
>          Stephen Williams - Thanks for helping me understand some of the ins and outs of what's required "under the hood" to handle some of Verilog's 
          constructs.
          </P
></LI
><LI
><P
>          Daniel McMahill - testing and patches for 64-bit compatibility
          </P
></LI
></UL
>
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.EPI.BUGS"
>Reporting Bugs</A
></H2
><P
>    If you have read this user's guide, chances are that you might be a Covered user. As such, it is encouraged that any bugs that you might find while using 
    Covered get reported so that this project may become more stable for yourself and for other users. To submit a bug report or a request for enhancement, 
    you may either send an e-mail to Trevor Williams (see <A
HREF="#SECTION.EPI.AUTHOR"
>Author</A
>&#62; or, if you have a SourceForge login, can report a bug by going 
    to:
    </P
><P
>      <A
HREF="http://sourceforge.net/projects/covered"
TARGET="_top"
>http://sourceforge.net/projects/covered</A
>
    </P
><P
>    and clicking on the "Bugs" link.
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.EPI.MAILING.LIST"
>Mailing List</A
></H2
><P
>    The Covered project has a user mailing list. Whenever there are stable releases being made of the project, an e-mail will get sent out to this list 
    stating the new release is available. Additionally, the mailing list is a great way to bring up usability issues with the tool and, of course, bugs. The 
    mailing list can also be useful if you have a question about using Covered -- there is probably someone else who has encountered the same problem that 
    might be able to provide you with some help.
    </P
><P
>    To subscribe to this e-mail list, please visit the following URL, enter the prescribed information and click on the "Submit" button.
    </P
><P
>      <A
HREF="http://lists.sourceforge.net/lists/listinfo/covered-users"
TARGET="_top"
>http://lists.sourceforge.net/lists/listinfo/covered-users</A
>
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.EPI.HOMEPAGE"
>Homepage</A
></H2
><P
>    The Covered project homepage is established on <A
HREF="http://sourceforge.net"
TARGET="_top"
>SourceForge</A
> at the following URL address.
    </P
><P
>      <A
HREF="http://covered.sourceforge.net"
TARGET="_top"
>http://covered.sourceforge.net</A
>
    </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTION.EPI.LICENSE"
>Copyright and Licensing</A
></H2
><P
>    This program is distributed under the GNU Public License GPL.
    </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECTION.EPI.LICENSE.GNU"
>GNU GENERAL PUBLIC LICENSE</A
></H3
><P
>        <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Version 2, June 1991</I
></SPAN
>
      </P
><P
>      Copyright (C) 1989, 1991 Free Software Foundation, Inc. 675 Mass Ave, Cambridge, MA 02139, USA Everyone is permitted to copy and distribute verbatim 
      copies of this license document, but changing it is not allowed.
      </P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3248"
>Preamble</A
></H4
><P
>        The licenses for most software are designed to take away your freedom to share and change it. By contrast, the GNU General Public License is 
        intended to guarantee your freedom to share and change free software-to make sure the software is free for all its users. This General Public 
        License applies to most of the Free Software Foundation's software and to any other program whose authors commit to using it. (Some other Free 
        Software Foundation software is covered by the GNU Library General Public License instead.) You can apply it to your programs, too.
        </P
><P
>        When we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the 
        freedom to distribute copies of free software (and charge for this service if you wish), that you receive source code or can get it if you want it, 
        that you can change the software or use pieces of it in new free programs; and that you know you can do these things.
        </P
><P
>        To protect your rights, we need to make restrictions that forbid anyone to deny you these rights or to ask you to surrender the rights. These 
        restrictions translate to certain responsibilities for you if you distribute copies of the software, or if you modify it.
        </P
><P
>        For example, if you distribute copies of such a program, whether gratis or for a fee, you must give the recipients all the rights that you have. You 
        must make sure that they, too, receive or can get the source code. And you must show them these terms so they know their rights.
        </P
><P
>        We protect your rights with two steps: (1) copyright the software, and (2) offer you this license which gives you legal permission to copy, 
        distribute and/or modify the software.
        </P
><P
>        Also, for each author's protection and ours, we want to make certain that everyone understands that there is no warranty for this free software. If 
        the software is modified by someone else and passed on, we want its recipients to know that what they have is not the original, so that any problems 
        introduced by others will not reflect on the original authors' reputations.
        </P
><P
>        Finally, any free program is threatened constantly by software patents. We wish to avoid the danger that redistributors of a free program will 
        individually obtain patent licenses, in effect making the program proprietary. To prevent this, we have made it clear that any patent must be 
        licensed for everyone's free use or not licensed at all.
        </P
><P
>        The precise terms and conditions for copying, distribution and modification follow.
        </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3258"
>Terms and Conditions for Copying, Distribution, and Modification</A
></H4
><P
>          <P
></P
><UL
><LI
><P
>              [0.] This License applies to any program or other work which contains a notice placed by the copyright holder saying it may be distributed 
              under the terms of this General Public License. The ``Program'', below, refers to any such program or work, and a ``work based on the 
              Program'' means either the Program or any derivative work under copyright law: that is to say, a work containing the Program or a portion of 
              it, either verbatim or with modifications and/or translated into another language. (Hereinafter, translation is included without limitation in 
              the term ``modification''.) Each licensee is addressed as ``you''.
              </P
><P
>              Activities other than copying, distribution and modification are not covered by this License; they are outside its scope. The act of running 
              the Program is not restricted, and the output from the Program is covered only if its contents constitute a work based on the Program 
              (independent of having been made by running the Program). Whether that is true depends on what the Program does.
              </P
></LI
><LI
><P
>              [1.] You may copy and distribute verbatim copies of the Program's source code as you receive it, in any medium, provided that you 
              conspicuously and appropriately publish on each copy an appropriate copyright notice and disclaimer of warranty; keep intact all the notices 
              that refer to this License and to the absence of any warranty; and give any other recipients of the Program a copy of this License along with 
              the Program.
              </P
><P
>              You may charge a fee for the physical act of transferring a copy, and you may at your option offer warranty protection in exchange for a fee.
              </P
></LI
><LI
><P
>              [2.] You may modify your copy or copies of the Program or any portion of it, thus forming a work based on the Program, and copy and distribute 
              such modifications or work under the terms of Section 1 above, provided that you also meet all of these conditions:
              </P
><P
>                <P
></P
><UL
><LI
><P
>                    [a.] You must cause the modified files to carry prominent notices stating that you changed the files and the date of any change.
                    </P
></LI
><LI
><P
>                    [b.] You must cause any work that you distribute or publish, that in whole or in part contains or is derived from the Program or any 
                    part thereof, to be licensed as a whole at no charge to all third parties under the terms of this License.
                    </P
></LI
><LI
><P
>                    [c.] If the modified program normally reads commands interactively when run, you must cause it, when started running for such 
                    interactive use in the most ordinary way, to print or display an announcement including an appropriate copyright notice and a notice 
                    that there is no warranty (or else, saying that you provide a warranty) and that users may redistribute the program under these 
                    conditions, and telling the user how to view a copy of this License. (Exception: if the Program itself is interactive but does not 
                    normally print such an announcement, your work based on the Program is not required to print an announcement.)
                    </P
></LI
></UL
>
              </P
><P
>              These requirements apply to the modified work as a whole. If identifiable sections of that work are not derived from the Program, and can be 
              reasonably considered independent and separate works in themselves, then this License, and its terms, do not apply to those sections when you 
              distribute them as separate works. But when you distribute the same sections as part of a whole which is a work based on the Program, the 
              distribution of the whole must be on the terms of this License, whose permissions for other licensees extend to the entire whole, and thus to 
              each and every part regardless of who wrote it.
              </P
><P
>              Thus, it is not the intent of this section to claim rights or contest your rights to work written entirely by you; rather, the intent is to 
              exercise the right to control the distribution of derivative or collective works based on the Program.
              </P
><P
>              In addition, mere aggregation of another work not based on the Program with the Program (or with a work based on the Program) on a volume of a 
              storage or distribution medium does not bring the other work under the scope of this License.
              </P
></LI
><LI
><P
>              [3.] You may copy and distribute the Program (or a work based on it, under Section 2) in object code or executable form under the terms of 
              Sections 1 and 2 above provided that you also do one of the following:
              </P
><P
>                <P
></P
><UL
><LI
><P
>                    [a.] Accompany it with the complete corresponding machine-readable source code, which must be distributed under the terms of Sections 1 
                    and 2 above on a medium customarily used for software interchange; or,
                    </P
></LI
><LI
><P
>                    [b.] Accompany it with a written offer, valid for at least three years, to give any third party, for a charge no more than your cost of 
                    physically performing source distribution, a complete machine-readable copy of the corresponding source code, to be distributed under 
                    the terms of Sections 1 and 2 above on a medium customarily used for software interchange; or,
                    </P
></LI
><LI
><P
>                    [c.] Accompany it with the information you received as to the offer to distribute corresponding source code. (This alternative is 
                    allowed only for noncommercial distribution and only if you received the program in object code or executable form with such an offer, 
                    in accord with Subsection b above.)
                    </P
></LI
></UL
>
              </P
><P
>              The source code for a work means the preferred form of the work for making modifications to it. For an executable work, complete source code 
              means all the source code for all modules it contains, plus any associated interface definition files, plus the scripts used to control 
              compilation and installation of the executable. However, as a special exception, the source code distributed need not include anything that is 
              normally distributed (in either source or binary form) with the major components (compiler, kernel, and so on) of the operating system on 
              which the executable runs, unless that component itself accompanies the executable.
              </P
><P
>              If distribution of executable or object code is made by offering access to copy from a designated place, then offering equivalent access to 
              copy the source code from the same place counts as distribution of the source code, even though third parties are not compelled to copy the 
              source along with the object code.
              </P
></LI
><LI
><P
>              [4.] You may not copy, modify, sublicense, or distribute the Program except as expressly provided under this License. Any attempt otherwise to 
              copy, modify, sublicense or distribute the Program is void, and will automatically terminate your rights under this License. However, parties 
              who have received copies, or rights, from you under this License will not have their licenses terminated so long as such parties remain in 
              full compliance.
              </P
></LI
><LI
><P
>              [5.] You are not required to accept this License, since you have not signed it. However, nothing else grants you permission to modify or 
              distribute the Program or its derivative works. These actions are prohibited by law if you do not accept this License. Therefore, by modifying 
              or distributing the Program (or any work based on the Program), you indicate your acceptance of this License to do so, and all its terms and 
              conditions for copying, distributing or modifying the Program or works based on it.
              </P
></LI
><LI
><P
>              [6.] Each time you redistribute the Program (or any work based on the Program), the recipient automatically receives a license from the 
              original licensor to copy, distribute or modify the Program subject to these terms and conditions. You may not impose any further restrictions 
              on the recipients' exercise of the rights granted herein. You are not responsible for enforcing compliance by third parties to this License.
              </P
></LI
><LI
><P
>              [7.] If, as a consequence of a court judgment or allegation of patent infringement or for any other reason (not limited to patent issues), 
              conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not 
              excuse you from the conditions of this License. If you cannot distribute so as to satisfy simultaneously your obligations under this License 
              and any other pertinent obligations, then as a consequence you may not distribute the Program at all. For example, if a patent license would 
              not permit royalty-free redistribution of the Program by all those who receive copies directly or indirectly through you, then the only way 
              you could satisfy both it and this License would be to refrain entirely from distribution of the Program.
              </P
><P
>              If any portion of this section is held invalid or unenforceable under any particular circumstance, the balance of the section is intended to 
              apply and the section as a whole is intended to apply in other circumstances.
              </P
><P
>              It is not the purpose of this section to induce you to infringe any patents or other property right claims or to contest validity of any such 
              claims; this section has the sole purpose of protecting the integrity of the free software distribution system, which is implemented by public 
              license practices. Many people have made generous contributions to the wide range of software distributed through that system in reliance on 
              consistent application of that system; it is up to the author/donor to decide if he or she is willing to distribute software through any other 
              system and a licensee cannot impose that choice.
              </P
><P
>              This section is intended to make thoroughly clear what is believed to be a consequence of the rest of this License.
              </P
></LI
><LI
><P
>              [8.] If the distribution and/or use of the Program is restricted in certain countries either by patents or by copyrighted interfaces, the 
              original copyright holder who places the Program under this License may add an explicit geographical distribution limitation excluding those 
              countries, so that distribution is permitted only in or among countries not thus excluded. In such case, this License incorporates the 
              limitation as if written in the body of this License.
              </P
></LI
><LI
><P
>              [9.] The Free Software Foundation may publish revised and/or new versions of the General Public License from time to time. Such new versions 
              will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.
              </P
><P
>              Each version is given a distinguishing version number. If the Program specifies a version number of this License which applies to it and ``any 
              later version'', you have the option of following the terms and conditions either of that version or of any later version published by the 
              Free Software Foundation. If the Program does not specify a version number of this License, you may choose any version ever published by the 
              Free Software Foundation.
              </P
></LI
><LI
><P
>              [10.] If you wish to incorporate parts of the Program into other free programs whose distribution conditions are different, write to the 
              author to ask for permission. For software which is copyrighted by the Free Software Foundation, write to the Free Software Foundation; we 
              sometimes make exceptions for this. Our decision will be guided by the two goals of preserving the free status of all derivatives of our free 
              software and of promoting the sharing and reuse of software generally.
              </P
><P
></P
><P
></P
><P
>              NO WARRANTY
              </P
></LI
><LI
><P
>              [11.] BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT 
              WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM ``AS IS'' WITHOUT WARRANTY OF ANY KIND, EITHER 
              EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE 
              ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL 
              NECESSARY SERVICING, REPAIR OR CORRECTION.
              </P
></LI
><LI
><P
>              [12.] IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/
              OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL 
              DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR 
              LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY 
              HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
              </P
><P
>              END OF TERMS AND CONDITIONS
              </P
><P
></P
><P
></P
></LI
></UL
>
        </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3321"
>Appendix: How to Apply These Terms to Your New Programs</A
></H4
><P
>        If you develop a new program, and you want it to be of the greatest possible use to the public, the best way to achieve this is to make it free 
        software which everyone can redistribute and change under these terms.
        </P
><P
>        To do so, attach the following notices to the program. It is safest to attach them to the start of each source file to most effectively convey the 
        exclusion of warranty; and each file should have at least the ``copyright'' line and a pointer to where the full notice is found.
        </P
><A
NAME="AEN3325"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>          Copyright  20yy This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as 
          published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.
          </P
><P
>          This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
          FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
          </P
><P
>          You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 
          675 Mass Ave, Cambridge, MA 02139, USA.
          </P
></BLOCKQUOTE
></DIV
></DIV
></DIV
></DIV
></DIV
></DIV
></BODY
></HTML
>